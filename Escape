-- ============================================
-- loadstring(game:HttpGet("https://raw.githubusercontent.com/mzdtools/EBFT/main/Escape"))()
-- ============================================
-- MzD Hub v12.3 - ADAPTIVE COLORS + VALENTINE v2
-- NEW: Kleurschema past zich aan per map
-- NEW: Doom=paars/rood, Valentine=donkerrood/roze
-- NEW: Handmatige kleur override
-- ============================================
getgenv().MzD = {}
local M = getgenv().MzD

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Player = Players.LocalPlayer

-- ========== INIT ==========
M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots")
if not M.ActiveBrainrots then
	task.spawn(function() M.ActiveBrainrots = workspace:WaitForChild("ActiveBrainrots", 15) end)
end

M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks")
if not M.ActiveLuckyBlocks then
	task.spawn(function() M.ActiveLuckyBlocks = workspace:WaitForChild("ActiveLuckyBlocks", 15) end)
end

M.PlotAction = nil
pcall(function()
	M.PlotAction = game:GetService("ReplicatedStorage")
		:WaitForChild("Packages", 10)
		:WaitForChild("Net", 10)
		:WaitForChild("RF/Plot.PlotAction", 10)
end)

-- ============================================
-- COLOR SCHEMES
-- ============================================
local COLOR_SCHEMES = {
	Auto = nil, -- detecteert automatisch
	Default = {
		name = "Default",
		floor = Color3.fromRGB(15, 15, 15),
		stripe = Color3.fromRGB(255, 200, 50),
		stripeCenter = Color3.fromRGB(255, 215, 0),
		wall = Color3.fromRGB(10, 10, 10),
		wallText = Color3.fromRGB(255, 215, 0),
		wallStripe = Color3.fromRGB(255, 200, 50),
	},
	Doom = {
		name = "Doom",
		floor = Color3.fromRGB(35, 0, 55),
		stripe = Color3.fromRGB(255, 50, 0),
		stripeCenter = Color3.fromRGB(255, 80, 20),
		wall = Color3.fromRGB(25, 0, 40),
		wallText = Color3.fromRGB(255, 60, 0),
		wallStripe = Color3.fromRGB(255, 50, 0),
	},
	Valentine = {
		name = "Valentine",
		floor = Color3.fromRGB(50, 0, 20),
		stripe = Color3.fromRGB(255, 50, 150),
		stripeCenter = Color3.fromRGB(255, 80, 180),
		wall = Color3.fromRGB(40, 0, 15),
		wallText = Color3.fromRGB(255, 100, 180),
		wallStripe = Color3.fromRGB(255, 50, 150),
	},
	Ocean = {
		name = "Ocean",
		floor = Color3.fromRGB(0, 15, 40),
		stripe = Color3.fromRGB(0, 200, 255),
		stripeCenter = Color3.fromRGB(50, 220, 255),
		wall = Color3.fromRGB(0, 10, 30),
		wallText = Color3.fromRGB(0, 200, 255),
		wallStripe = Color3.fromRGB(0, 180, 240),
	},
	Emerald = {
		name = "Emerald",
		floor = Color3.fromRGB(0, 30, 15),
		stripe = Color3.fromRGB(0, 255, 100),
		stripeCenter = Color3.fromRGB(50, 255, 130),
		wall = Color3.fromRGB(0, 20, 10),
		wallText = Color3.fromRGB(0, 255, 100),
		wallStripe = Color3.fromRGB(0, 230, 90),
	},
	Void = {
		name = "Void",
		floor = Color3.fromRGB(10, 0, 25),
		stripe = Color3.fromRGB(150, 0, 255),
		stripeCenter = Color3.fromRGB(180, 50, 255),
		wall = Color3.fromRGB(8, 0, 20),
		wallText = Color3.fromRGB(150, 50, 255),
		wallStripe = Color3.fromRGB(130, 0, 240),
	},
	Blood = {
		name = "Blood",
		floor = Color3.fromRGB(40, 0, 0),
		stripe = Color3.fromRGB(255, 0, 0),
		stripeCenter = Color3.fromRGB(255, 40, 40),
		wall = Color3.fromRGB(30, 0, 0),
		wallText = Color3.fromRGB(255, 20, 20),
		wallStripe = Color3.fromRGB(220, 0, 0),
	},
	White = {
		name = "White",
		floor = Color3.fromRGB(200, 200, 200),
		stripe = Color3.fromRGB(40, 40, 40),
		stripeCenter = Color3.fromRGB(60, 60, 60),
		wall = Color3.fromRGB(180, 180, 180),
		wallText = Color3.fromRGB(30, 30, 30),
		wallStripe = Color3.fromRGB(50, 50, 50),
	},
}

local function detectMapType()
	local mapName = ""
	for _, c in pairs(workspace:GetChildren()) do
		if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
			if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or
				c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then
				mapName = c.Name:lower()
				break
			end
			local cnt = 0
			for _, d in pairs(c:GetDescendants()) do
				if d:IsA("BasePart") then cnt += 1 end
				if cnt > 10 then mapName = c.Name:lower() break end
			end
			if mapName ~= "" then break end
		end
	end

	-- Check doom indicators
	if mapName:find("doom") then return "Doom" end
	local doomFolder = workspace:FindFirstChild("DoomEventParts")
	if doomFolder and #doomFolder:GetChildren() > 0 then return "Doom" end

	-- Check valentine/candy
	if mapName:find("valentine") or mapName:find("candy") or mapName:find("love") or mapName:find("heart") then
		return "Valentine"
	end

	-- Check dark maps
	if mapName:find("void") or mapName:find("shadow") or mapName:find("dark") or mapName:find("night") then
		return "Void"
	end

	-- Check water/ocean maps
	if mapName:find("ocean") or mapName:find("water") or mapName:find("beach") or mapName:find("summer") then
		return "Ocean"
	end

	return "Default"
end

local function getActiveColorScheme()
	local schemeName = M.S.ColorScheme or "Auto"
	if schemeName == "Auto" then
		local detected = detectMapType()
		return COLOR_SCHEMES[detected] or COLOR_SCHEMES.Default, detected
	end
	return COLOR_SCHEMES[schemeName] or COLOR_SCHEMES.Default, schemeName
end

M._lastColorScheme = nil

-- ========== SETTINGS ==========
M.S = {
	Farming = false,
	SelectedBrainrots = {},
	TargetMutation = "None",
	TargetRarity = {"Common"},
	TweenSpeed = 9999,
	CorridorSpeed = 1500,
	AutoCollectMoney = false,
	InstantPickup = true,
	AntiAFK = false,
	AutoUpgrade = false,
	MaxLevel = 250,
	FactoryEnabled = false,
	FactorySlot = "5",
	FactoryRarity = "Common",
	FactoryMutation = "None",
	FactoryMaxLevel = 250,
	FarmMode = "Collect, Place & Max",
	FarmSlot = "5",
	ValentineEnabled = false,
	ValentineSpeed = 300,
	ArcadeEnabled = false,
	MapFixerEnabled = false,
	LuckyBlockEnabled = false,
	LuckyBlockRarity = {"Common"},
	LuckyBlockMutation = "Any",
	GodEnabled = false,
	GodWalkY = -2,
	GodFloorY = -5,
	DoomEnabled = false,
	DoomTowerEnabled = false,
	DoomTowerOffset = 0,
	ColorScheme = "Auto",
}

M.Status = {
	farm = "Idle", farmCount = 0,
	money = "Idle",
	afk = "Uit",
	placeCount = 0, upgradeCount = 0,
	upgrade = "Idle",
	factory = "Idle", factoryCount = 0,
	valentine = "Idle", valentineCount = 0, valentineHearts = 0,
	arcade = "Idle", arcadeCount = 0,
	mapFixer = "Uit",
	luckyBlock = "Idle", luckyBlockCount = 0,
	god = "Uit",
	doom = "Uit", doomCount = 0,
	doomTower = "Uit",
	colorScheme = "Auto",
}

-- ========== STATE ==========
M.baseGUID = nil
M.baseCFrame = nil
M.homePosition = nil
M.farmThread = nil
M.factoryThread = nil
M.moneyThread = nil
M.moneyRemoteThread = nil
M.afkThread = nil
M._afkSteppedConn = nil
M._instantConn = nil
M.upgradeThread = nil
M.valentineThread = nil
M.valentineCollectorConn = nil
M._valentineDescAddedConn = nil
M.arcadeThread = nil
M.mapFixerThread = nil
M.lastMapName = ""
M._valentineCachedParts = {}
M._valentineLastCacheScan = 0
M._valentineStationCF = nil
M._valentineStationObj = nil
M.luckyBlockThread = nil

M._isGod = false
M._godLoopThread = nil
M._godHealthConn = nil
M._godDiedConn = nil
M._godOriginalFloors = {}
M._godCreatedParts = {}
M._godKillParts = {}
M._godKillWatchThread = nil
M._godFloorCacheTime = 0

M._towerMoved = false
M._towerOriginalCF = nil
M._towerOriginalY = nil
M._towerWatchThread = nil
M._towerLastTargetY = nil
M._towerDetectedFloorY = nil
M._towerDetectedSource = nil

M._doomConn = nil
M._doomDescConn = nil
M._doomTowerDescConn = nil
M._doomCachedParts = {}
M._doomLastScan = 0
M._doomCollected = 0

M._wallZ_front = 207
M._wallZ_back = -207

local HIGH_RARITIES = {["Celestial"] = true, ["Divine"] = true, ["Infinity"] = true}
local VALENTINE_FARM_RARITIES = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret"}

-- ============================================
-- HELPER: Is dit een MzD eigen part?
-- ============================================
local function isMzDPart(obj)
	if not obj or not obj:IsA("BasePart") then return false end
	local n = obj.Name
	if n == "MzDGodFloor" or n == "MzDGodCatchFloor" or n == "MzDGodFloorStripe" then return true end
	local p = obj.Parent
	while p do
		if p.Name == "MzDHubWalls" or p.Name == "MzDGodPreview" then return true end
		p = p.Parent
	end
	return false
end

-- ============================================
-- RECOLOR: Update bestaande parts met nieuw schema
-- ============================================
local function recolorGodParts()
	local scheme = getActiveColorScheme()
	if not scheme then return end

	-- Recolor god floor parts
	for _, p in pairs(M._godCreatedParts) do
		if p and p.Parent then
			pcall(function()
				if p.Name == "MzDGodFloor" then
					p.Color = scheme.floor
				elseif p.Name == "MzDGodFloorStripe" then
					if p.Size.Z < 1.5 then
						p.Color = scheme.stripeCenter
					else
						p.Color = scheme.stripe
					end
				elseif p.Name == "MzDGodCatchFloor" then
					-- catch floor stays invisible
				end
			end)
		end
	end

	-- Recolor walls
	local map = nil
	for _, c in pairs(workspace:GetChildren()) do
		if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
			if c:FindFirstChild("MzDHubWalls") then map = c break end
		end
	end
	if map then
		local mf = map:FindFirstChild("MzDHubWalls")
		if mf then
			for _, w in pairs(mf:GetChildren()) do
				if w:IsA("BasePart") then
					pcall(function()
						if w.Name:find("FS_") or w.Name:find("BS_") then
							w.Color = scheme.wallStripe
						elseif w.Name:find("Wall") then
							w.Color = scheme.wall
							-- Update text labels
							for _, sg in pairs(w:GetChildren()) do
								if sg:IsA("SurfaceGui") then
									for _, tl in pairs(sg:GetChildren()) do
										if tl:IsA("TextLabel") then
											if tl.Text == "MzD Hub" then
												tl.TextColor3 = scheme.wallText
											end
										end
									end
								end
							end
						end
					end)
				end
			end
		end
	end

	M._lastColorScheme = scheme.name
	M.Status.colorScheme = scheme.name
end

-- ============================================
-- TOWER MOVER
-- ============================================
local function findTower()
	local ok, tower = pcall(function()
		return workspace.GameObjects.PlaceSpecific.root.Tower
	end)
	if ok and tower then return tower end
	for _, c in pairs(workspace:GetDescendants()) do
		if c.Name == "Tower" and c:IsA("Model") then
			local count = 0
			for _, d in pairs(c:GetDescendants()) do
				if d:IsA("BasePart") then count += 1 end
				if count > 5 then return c end
			end
		end
	end
	return nil
end

local function getTowerY()
	local tower = findTower()
	if not tower then return nil end
	local ok, pivot = pcall(function() return tower:GetPivot() end)
	if ok and pivot then return pivot.Position.Y end
	return nil
end

local function getTowerBottomY()
	local tower = findTower()
	if not tower then return nil end
	local minY = math.huge
	for _, part in pairs(tower:GetDescendants()) do
		if part:IsA("BasePart") then
			local bottom = part.Position.Y - part.Size.Y / 2
			if bottom < minY then minY = bottom end
		end
	end
	if minY == math.huge then return nil end
	return minY
end

local function detectFloorY()
	local floors = {}
	for _, c in pairs(workspace:GetChildren()) do
		if c:IsA("BasePart") and c.Name == "MzDGodFloor" then
			table.insert(floors, {y = c.Position.Y + c.Size.Y / 2, source = "GodFloor"})
		end
	end
	local map = nil
	for _, c in pairs(workspace:GetChildren()) do
		if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
			if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then
				map = c break
			end
			local cnt = 0
			for _, d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then cnt += 1 end if cnt > 10 then map = c break end end
			if map then break end
		end
	end
	if map then
		for _, name in pairs({"FirstFloor", "Ground", "Floor", "BridgeFloor"}) do
			local f = map:FindFirstChild(name)
			if f and f:IsA("BasePart") then table.insert(floors, {y = f.Position.Y + f.Size.Y / 2, source = "Map:" .. name}) end
		end
		local sp = map:FindFirstChild("Spawners")
		if sp then for _, s in pairs(sp:GetChildren()) do
			if s:IsA("BasePart") and s.Size.X > 15 and s.Size.Z > 5 and s.Size.Y < 20 and s.Position.Y > -15 and s.Position.Y < 30 then
				table.insert(floors, {y = s.Position.Y + s.Size.Y / 2, source = "Spawner"})
			end
		end end
		for _, c in pairs(map:GetChildren()) do
			if c:IsA("BasePart") and not isMzDPart(c) and c.Size.X > 30 and c.Size.Z > 15 and c.Size.Y < 15 and c.Position.Y > -15 and c.Position.Y < 30 then
				table.insert(floors, {y = c.Position.Y + c.Size.Y / 2, source = "MapPart"})
			end
		end
	end
	for _, c in pairs(workspace:GetChildren()) do
		if c.Name:find("SharedInstances") then
			local fl = c:FindFirstChild("Floors")
			if fl then for _, f in pairs(fl:GetChildren()) do
				if f:IsA("BasePart") and f.Size.X > 15 and f.Size.Z > 5 then
					table.insert(floors, {y = f.Position.Y + f.Size.Y / 2, source = "Shared"})
				end
			end end
		end
	end
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		local el = {} local tower = findTower() if tower then table.insert(el, tower) end
		params.FilterDescendantsInstances = el
		local result = workspace:Raycast(hrp.Position, Vector3.new(0, -100, 0), params)
		if result then table.insert(floors, {y = result.Position.Y, source = "Raycast"}) end
	end
	if #floors == 0 then
		if hrp then return hrp.Position.Y - 3, "PlayerFallback" end
		return 0, "Default"
	end
	table.sort(floors, function(a, b) return a.y > b.y end)
	return floors[1].y, floors[1].source
end

local function moveTowerToFloor(floorTopY, offset)
	local tower = findTower() if not tower then return false end
	if not M._towerOriginalCF then pcall(function() M._towerOriginalCF = tower:GetPivot() M._towerOriginalY = M._towerOriginalCF.Position.Y end) end
	local towerBottomY = getTowerBottomY() if not towerBottomY then return false end
	local targetBottom = floorTopY + offset
	local deltaY = targetBottom - towerBottomY
	if math.abs(deltaY) < 0.3 then return true end
	pcall(function() tower:PivotTo(tower:GetPivot() * CFrame.new(0, deltaY, 0)) end)
	pcall(function() for _, part in pairs(tower:GetDescendants()) do if part:IsA("BasePart") then part.Anchored = true end end end)
	M._towerMoved = true M._towerLastTargetY = targetBottom M._towerDetectedFloorY = floorTopY
	return true
end

local function restoreTower()
	if not M._towerOriginalCF then return false end
	local tower = findTower() if not tower then return false end
	pcall(function() tower:PivotTo(M._towerOriginalCF) end)
	M._towerMoved = false M._towerOriginalCF = nil M._towerOriginalY = nil M._towerLastTargetY = nil
	return true
end

local function startTowerWatcher()
	if M._towerWatchThread then pcall(task.cancel, M._towerWatchThread) end
	M._towerWatchThread = task.spawn(function()
		while M.S.DoomTowerEnabled and M._towerMoved do
			pcall(function()
				local tower = findTower()
				if tower and M._towerLastTargetY then
					local bottomY = getTowerBottomY()
					if bottomY and math.abs(bottomY - M._towerLastTargetY) > 3 then
						moveTowerToFloor(M._towerDetectedFloorY or detectFloorY(), M.S.DoomTowerOffset)
					end
					for _, part in pairs(tower:GetDescendants()) do if part:IsA("BasePart") then part.Anchored = true end end
				end
			end)
			task.wait(3)
		end
	end)
end

local function stopTowerWatcher()
	if M._towerWatchThread then pcall(task.cancel, M._towerWatchThread) M._towerWatchThread = nil end
end

function M.enableTowerDrop()
	M.S.DoomTowerEnabled = true
	local floorY, source = detectFloorY()
	M._towerDetectedFloorY = floorY M._towerDetectedSource = source
	local ok = moveTowerToFloor(floorY, M.S.DoomTowerOffset)
	if ok then startTowerWatcher() M.Status.doomTower = "Aan âœ“ (floor:" .. string.format("%.0f", floorY) .. " off:" .. M.S.DoomTowerOffset .. ")"
	else M.Status.doomTower = "Tower niet gevonden" end
	return ok
end

function M.disableTowerDrop()
	M.S.DoomTowerEnabled = false stopTowerWatcher() restoreTower()
	M._towerMoved = false M.Status.doomTower = "Uit"
end

-- ============================================
-- DOOM EVENT COLLECTOR
-- ============================================
local function scanDoomParts()
	M._doomCachedParts = {}
	local folder = workspace:FindFirstChild("DoomEventParts")
	if folder then
		for _, obj in pairs(folder:GetDescendants()) do
			if obj:IsA("BasePart") then table.insert(M._doomCachedParts, obj) end
			if obj:IsA("ProximityPrompt") then pcall(function() obj.HoldDuration = 0 obj.MaxActivationDistance = 99999 obj.RequiresLineOfSight = false end) end
		end
	end
	local tower = findTower()
	if tower then
		for _, obj in pairs(tower:GetDescendants()) do
			if obj:IsA("BasePart") and obj:FindFirstChild("TouchInterest") then
				local found = false for _, c in pairs(M._doomCachedParts) do if c == obj then found = true break end end
				if not found then table.insert(M._doomCachedParts, obj) end
			end
			if obj:IsA("ProximityPrompt") then pcall(function() obj.HoldDuration = 0 obj.MaxActivationDistance = 99999 obj.RequiresLineOfSight = false end) end
		end
	end
	M._doomLastScan = tick() return #M._doomCachedParts
end

local function fireAllDoomPrompts(parent)
	if not parent then return end
	for _, d in pairs(parent:GetDescendants()) do
		if d:IsA("ProximityPrompt") then
			pcall(function() d.HoldDuration = 0 d.MaxActivationDistance = 99999 d.RequiresLineOfSight = false end)
			pcall(function() fireproximityprompt(d) end)
		end
	end
end

local function handleDoomNewDesc(d)
	if not M.S.DoomEnabled then return end
	if d:IsA("BasePart") then
		table.insert(M._doomCachedParts, d)
		pcall(function() local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if hrp then firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end end)
	end
	if d:IsA("ProximityPrompt") then
		pcall(function() d.HoldDuration = 0 d.MaxActivationDistance = 99999 d.RequiresLineOfSight = false end)
		pcall(function() fireproximityprompt(d) end)
	end
end

function M.startDoomCollector()
	if M.S.DoomEnabled then return end
	M.S.DoomEnabled = true M._doomCollected = 0 M.Status.doomCount = 0
	local partCount = scanDoomParts()
	local folder = workspace:FindFirstChild("DoomEventParts")
	if not folder then
		task.spawn(function()
			folder = workspace:WaitForChild("DoomEventParts", 30)
			if folder and M.S.DoomEnabled then scanDoomParts() M._doomDescConn = folder.DescendantAdded:Connect(handleDoomNewDesc) end
		end)
	else
		if M._doomDescConn then pcall(function() M._doomDescConn:Disconnect() end) end
		M._doomDescConn = folder.DescendantAdded:Connect(handleDoomNewDesc)
	end
	local tower = findTower()
	if tower then
		if M._doomTowerDescConn then pcall(function() M._doomTowerDescConn:Disconnect() end) end
		M._doomTowerDescConn = tower.DescendantAdded:Connect(handleDoomNewDesc)
	end
	M._doomConn = RunService.Heartbeat:Connect(function()
		if not M.S.DoomEnabled then return end
		pcall(function()
			local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not hrp then return end
			if tick() - M._doomLastScan > 10 then
				local alive = {} for _, p in pairs(M._doomCachedParts) do if p and p.Parent then table.insert(alive, p) end end M._doomCachedParts = alive
				local f2 = workspace:FindFirstChild("DoomEventParts")
				if f2 then for _, obj in pairs(f2:GetDescendants()) do if obj:IsA("BasePart") then local fnd = false for _, c in pairs(M._doomCachedParts) do if c == obj then fnd = true break end end if not fnd then table.insert(M._doomCachedParts, obj) end end end end
				local tw = findTower()
				if tw then for _, obj in pairs(tw:GetDescendants()) do if obj:IsA("BasePart") and obj:FindFirstChild("TouchInterest") then local fnd = false for _, c in pairs(M._doomCachedParts) do if c == obj then fnd = true break end end if not fnd then table.insert(M._doomCachedParts, obj) end end end end
				M._doomLastScan = tick()
			end
			local collected = 0
			for _, p in pairs(M._doomCachedParts) do if p and p.Parent then pcall(function() firetouchinterest(hrp, p, 0) firetouchinterest(hrp, p, 1) end) collected += 1 end end
			local f3 = workspace:FindFirstChild("DoomEventParts") if f3 then fireAllDoomPrompts(f3) end
			local tw2 = findTower() if tw2 then fireAllDoomPrompts(tw2) end
			M._doomCollected = collected
		end)
	end)
	M.Status.doom = "Aan âœ“ (" .. partCount .. " parts)"
end

function M.stopDoomCollector()
	M.S.DoomEnabled = false
	if M._doomConn then pcall(function() M._doomConn:Disconnect() end) M._doomConn = nil end
	if M._doomDescConn then pcall(function() M._doomDescConn:Disconnect() end) M._doomDescConn = nil end
	if M._doomTowerDescConn then pcall(function() M._doomTowerDescConn:Disconnect() end) M._doomTowerDescConn = nil end
	M._doomCachedParts = {} M._doomCollected = 0 M.Status.doom = "Uit"
end

-- ============================================
-- GOD MODE v23 - MET ADAPTIVE COLORS
-- ============================================
local function godFindFloorParts()
	local floors = {}
	local map = nil
	for _, c in pairs(workspace:GetChildren()) do
		if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
			if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then map = c break end
		end
	end
	if not map then for _, c in pairs(workspace:GetChildren()) do if c:IsA("Model") and c.Name:find("Map") then local cnt = 0 for _, d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then cnt += 1 end if cnt > 10 then map = c break end end if map then break end end end end
	local function checkPart(p) if not p:IsA("BasePart") or isMzDPart(p) then return end if p.Size.X > 15 and p.Size.Z > 5 and p.Size.Y < 20 and p.Position.Y > -10 and p.Position.Y < 30 then table.insert(floors, p) end end
	if map then
		for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") and not isMzDPart(c) then local n = c.Name:lower() if n == "firstfloor" or n == "ground" or n == "floor" or n == "grass" or n == "path" or n == "road" or n == "platform" or n == "bridgefloor" then table.insert(floors, c) else checkPart(c) end end end
		local sp = map:FindFirstChild("Spawners") if sp then for _, s in pairs(sp:GetChildren()) do checkPart(s) end end
	end
	for _, c in pairs(workspace:GetChildren()) do if c.Name:find("SharedInstances") then local fl = c:FindFirstChild("Floors") if fl then for _, f in pairs(fl:GetChildren()) do checkPart(f) end end for _, f in pairs(c:GetChildren()) do checkPart(f) end end end
	return floors, map
end

local function godDetectMapXRange(map)
	local minX, maxX = math.huge, -math.huge local found = false
	local function chk(p) if not p:IsA("BasePart") or isMzDPart(p) then return end if p.Size.Y > p.Size.X and p.Size.Y > p.Size.Z then return end if p.Position.Y > 50 or p.Position.Y < -30 or p.Size.X < 5 then return end local l = p.Position.X - p.Size.X/2 local r = p.Position.X + p.Size.X/2 if l < minX then minX = l end if r > maxX then maxX = r end found = true end
	if map then for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") then chk(c) end end local sp = map:FindFirstChild("Spawners") if sp then for _, s in pairs(sp:GetChildren()) do chk(s) end end end
	for _, c in pairs(workspace:GetChildren()) do if c.Name:find("SharedInstances") then for _, f in pairs(c:GetChildren()) do if f:IsA("BasePart") then chk(f) end end local fl = c:FindFirstChild("Floors") if fl then for _, f in pairs(fl:GetChildren()) do chk(f) end end end end
	if found and maxX > minX then return minX - 20, maxX + 20 end return -50, 4500
end

local function godFindAllKillParts()
	local kills, seen = {}, {}
	for _, c in pairs(workspace:GetDescendants()) do
		if c:IsA("BasePart") and not seen[c] and not isMzDPart(c) then
			local ok, isKS = pcall(function() return c.Size.Y < 1 and c.Size.Z > 50 and c.Position.Y < 5 and c.Position.Y > -5 and c.Size.X < 5 end)
			if ok and isKS and not seen[c] then seen[c] = true table.insert(kills, c) end
			if not seen[c] then local n = c.Name:lower() if n:find("kill") or n:find("tsunamikill") or n:find("deathzone") or n:find("damagezone") or n:find("killbrick") or n:find("killpart") then seen[c] = true table.insert(kills, c) end end
		end
	end
	return kills
end

local function godDisableKillParts()
	M._godKillParts = {}
	for _, p in pairs(godFindAllKillParts()) do
		table.insert(M._godKillParts, {part = p, canCollide = p.CanCollide, canTouch = p.CanTouch, size = p.Size, position = p.Position, transparency = p.Transparency})
		pcall(function() p.CanCollide = false p.CanTouch = false p.Transparency = 1 p.Size = Vector3.new(0,0,0) p.Position = Vector3.new(0,-9999,0) end)
	end
	return #M._godKillParts
end

local function godRestoreKillParts()
	for _, d in pairs(M._godKillParts) do pcall(function() if d.part and d.part.Parent then d.part.Size = d.size d.part.Position = d.position d.part.CanCollide = d.canCollide d.part.CanTouch = d.canTouch d.part.Transparency = d.transparency end end) end
	M._godKillParts = {}
end

local function godStartKillWatcher()
	if M._godKillWatchThread then pcall(task.cancel, M._godKillWatchThread) end
	M._godKillWatchThread = task.spawn(function()
		while M._isGod do
			pcall(function()
				for _, d in pairs(M._godKillParts) do if d.part and d.part.Parent then d.part.CanCollide = false d.part.CanTouch = false d.part.Size = Vector3.new(0,0,0) d.part.Position = Vector3.new(0,-9999,0) end end
				for _, c in pairs(workspace:GetDescendants()) do
					if c:IsA("BasePart") and not isMzDPart(c) then
						local isKill = false
						pcall(function() if c.Size.Y < 1 and c.Size.Z > 50 and c.Position.Y < 5 and c.Position.Y > -5 and c.Size.X < 5 then isKill = true end end)
						if not isKill then local n = c.Name:lower() if n:find("kill") or n:find("deathzone") or n:find("damagezone") then isKill = true end end
						if isKill then
							local already = false for _, d in pairs(M._godKillParts) do if d.part == c then already = true break end end
							if not already then
								table.insert(M._godKillParts, {part = c, canCollide = c.CanCollide, canTouch = c.CanTouch, size = c.Size, position = c.Position, transparency = c.Transparency})
								pcall(function() c.CanCollide = false c.CanTouch = false c.Transparency = 1 c.Size = Vector3.new(0,0,0) c.Position = Vector3.new(0,-9999,0) end)
							end
						end
					end
				end
			end)
			task.wait(3)
		end
	end)
end

local function godBuildEgaleVloer(map)
	for _, p in pairs(M._godCreatedParts) do pcall(function() if p and p.Parent then p:Destroy() end end) end
	M._godCreatedParts = {}

	local scheme = getActiveColorScheme()
	local startX, endX = godDetectMapXRange(map)
	local floorY = M.S.GodFloorY
	local floorWidth = 420
	local floorThickness = 4
	local maxSeg = 2000
	local curX = startX

	while curX < endX do
		local segLen = math.min(maxSeg, endX - curX)
		local centerX = curX + segLen / 2
		local floor = Instance.new("Part")
		floor.Name = "MzDGodFloor"
		floor.Size = Vector3.new(segLen, floorThickness, floorWidth)
		floor.Position = Vector3.new(centerX, floorY, 0)
		floor.Anchored = true floor.CanCollide = true
		floor.Color = scheme.floor
		floor.Material = Enum.Material.SmoothPlastic
		floor.Transparency = 0
		floor.TopSurface = Enum.SurfaceType.Smooth floor.BottomSurface = Enum.SurfaceType.Smooth
		floor.Parent = workspace
		table.insert(M._godCreatedParts, floor)

		local topY = floorY + floorThickness / 2 + 0.1
		for _, zPos in pairs({floorWidth / 2 - 5, -floorWidth / 2 + 5}) do
			local s = Instance.new("Part")
			s.Name = "MzDGodFloorStripe" s.Size = Vector3.new(segLen, 0.2, 2)
			s.Position = Vector3.new(centerX, topY, zPos)
			s.Anchored = true s.CanCollide = false
			s.Color = scheme.stripe s.Material = Enum.Material.Neon
			s.Parent = workspace
			table.insert(M._godCreatedParts, s)
		end
		local sm = Instance.new("Part")
		sm.Name = "MzDGodFloorStripe" sm.Size = Vector3.new(segLen, 0.2, 1)
		sm.Position = Vector3.new(centerX, topY, 0)
		sm.Anchored = true sm.CanCollide = false
		sm.Color = scheme.stripeCenter sm.Material = Enum.Material.Neon
		sm.Parent = workspace
		table.insert(M._godCreatedParts, sm)
		curX = curX + segLen
	end

	local catch = Instance.new("Part")
	catch.Name = "MzDGodCatchFloor"
	catch.Size = Vector3.new(math.abs(endX - startX) + 200, 2, floorWidth + 100)
	catch.Position = Vector3.new((startX + endX) / 2, floorY - 15, 0)
	catch.Anchored = true catch.CanCollide = true catch.Transparency = 1
	catch.Parent = workspace
	table.insert(M._godCreatedParts, catch)

	M._lastColorScheme = scheme.name
	M.Status.colorScheme = scheme.name
	return true
end

local function godHideOriginalFloors()
	local floors, map = godFindFloorParts()
	M._godOriginalFloors = {}
	for _, p in pairs(floors) do
		table.insert(M._godOriginalFloors, {part = p, size = p.Size, position = p.Position, canCollide = p.CanCollide, transparency = p.Transparency, color = p.Color, material = p.Material, anchored = p.Anchored})
		pcall(function() p.CanCollide = false p.Transparency = 1 end)
	end
	if map then for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") and c.Name == "BridgeFloor" and not isMzDPart(c) then
		table.insert(M._godOriginalFloors, {part = c, size = c.Size, position = c.Position, canCollide = c.CanCollide, transparency = c.Transparency, color = c.Color, material = c.Material, anchored = c.Anchored})
		pcall(function() c.CanCollide = false c.Transparency = 1 end)
	end end end
	return map
end

local function godRestoreFloors()
	for _, d in pairs(M._godOriginalFloors) do pcall(function() if d.part and d.part.Parent then d.part.Size = d.size d.part.Position = d.position d.part.CanCollide = d.canCollide d.part.Transparency = d.transparency d.part.Color = d.color d.part.Material = d.material d.part.Anchored = d.anchored end end) end
	M._godOriginalFloors = {}
	for _, f in pairs(M._godCreatedParts) do pcall(function() if f and f.Parent then f:Destroy() end end) end
	M._godCreatedParts = {}
end

local function godTeleportUnder()
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not hrp then return end
	hrp.Velocity = Vector3.new(0, 0, 0) hrp.CFrame = CFrame.new(hrp.Position.X, M.S.GodWalkY, hrp.Position.Z)
end

local function godStartLoop()
	if M._godLoopThread then pcall(task.cancel, M._godLoopThread) end
	M._godLoopThread = task.spawn(function()
		while M._isGod do
			pcall(function()
				local ch = Player.Character if not ch then return end
				local hrp = ch:FindFirstChild("HumanoidRootPart")
				if tick() - M._godFloorCacheTime > 5 then
					for _, d in pairs(M._godOriginalFloors) do if d.part and d.part.Parent then d.part.CanCollide = false d.part.Transparency = 1 end end
					M._godFloorCacheTime = tick()
				end
				-- Check of kleurschema veranderd moet worden
				local currentScheme = getActiveColorScheme()
				if currentScheme and currentScheme.name ~= M._lastColorScheme then
					recolorGodParts()
				end
				if hrp then
					local curY = hrp.Position.Y
					if curY < M.S.GodWalkY - 30 then hrp.Velocity = Vector3.new(0,0,0) hrp.CFrame = CFrame.new(hrp.Position.X, M.S.GodWalkY, hrp.Position.Z) end
				end
			end)
			task.wait(0.5)
		end
	end)
end

local function godSetupHealth(char)
	if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) end
	if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) end
	local hum = char:WaitForChild("Humanoid", 5) if not hum then return end
	pcall(function() hum.MaxHealth = math.huge hum.Health = math.huge hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
	for _, ff in pairs(char:GetChildren()) do if ff:IsA("ForceField") then ff:Destroy() end end
	local ff = Instance.new("ForceField") ff.Visible = false ff.Parent = char
	M._godHealthConn = hum:GetPropertyChangedSignal("Health"):Connect(function() if not M._isGod then return end pcall(function() if hum.Health ~= math.huge then hum.Health = math.huge end end) end)
	M._godDiedConn = hum.Died:Connect(function() if not M._isGod then return end task.defer(function() pcall(function() hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false) hum:ChangeState(Enum.HumanoidStateType.GettingUp) hum.MaxHealth = math.huge hum.Health = math.huge end) end) end)
end

function M.enableGod()
	if M._isGod then return end
	M._isGod = true M.S.GodEnabled = true M._godFloorCacheTime = 0
	local killCount = godDisableKillParts() godStartKillWatcher()
	task.wait(0.1) local map = godHideOriginalFloors()
	task.wait(0.1) godBuildEgaleVloer(map)
	task.wait(0.2) godStartLoop()
	task.wait(0.1) godTeleportUnder()
	task.wait(0.1) if Player.Character then godSetupHealth(Player.Character) end
	local towerStatus = ""
	if M.S.DoomTowerEnabled then local tOk = M.enableTowerDrop() towerStatus = tOk and " | Tower âœ“" or " | Tower âœ—" end
	local scheme = getActiveColorScheme()
	M.Status.god = "Aan ðŸ›¡ï¸ " .. scheme.name .. " (Y=" .. M.S.GodWalkY .. " K:" .. killCount .. towerStatus .. ")"
end

function M.disableGod()
	M._isGod = false M.S.GodEnabled = false
	if M._godLoopThread then pcall(task.cancel, M._godLoopThread) M._godLoopThread = nil end
	if M._godKillWatchThread then pcall(task.cancel, M._godKillWatchThread) M._godKillWatchThread = nil end
	if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) M._godHealthConn = nil end
	if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) M._godDiedConn = nil end
	godRestoreFloors() godRestoreKillParts()
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then hrp.Velocity = Vector3.new(0,0,0) hrp.CFrame = CFrame.new(hrp.Position.X, 10, hrp.Position.Z) end
	local ch = Player.Character
	if ch then
		for _, ff2 in pairs(ch:GetChildren()) do if ff2:IsA("ForceField") then ff2:Destroy() end end
		local hum = ch:FindFirstChild("Humanoid")
		if hum then pcall(function() hum.MaxHealth = 100 hum.Health = 100 hum:SetStateEnabled(Enum.HumanoidStateType.Dead, true) end) end
	end
	M.Status.god = "Uit"
end

-- ========== EQUIP ==========
function M.safeEquip(tool) if not tool then return end local ch = Player.Character if not ch then return end local hum = ch:FindFirstChild("Humanoid") if not hum then return end pcall(function() hum:EquipTool(tool) end) task.wait(0.4) end
function M.safeUnequip() local ch = Player.Character if not ch then return end local hum = ch:FindFirstChild("Humanoid") if not hum then return end pcall(function() hum:UnequipTools() end) task.wait(0.2) end

-- ========== MAP HELPERS ==========
function M.mapFindCurrentMap()
	local best, bc = nil, 0
	for _, c in pairs(workspace:GetChildren()) do
		if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
			if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or c:FindFirstChild("RightWalls") or c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then return c end
			local cnt = 0 for _, d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then cnt += 1 end if cnt > 10 then return c end end
			if cnt > bc then bc = cnt best = c end
		end
	end
	return best
end

function M.detectWallZ()
	local map = M.mapFindCurrentMap() if not map then return end
	local mzwalls = map:FindFirstChild("MzDHubWalls") if not mzwalls then return end
	local fw = mzwalls:FindFirstChild("FrontWall_1") local bw = mzwalls:FindFirstChild("BackWall_1")
	if fw then M._wallZ_front = fw.Position.Z - fw.Size.Z / 2 - 3 end
	if bw then M._wallZ_back = bw.Position.Z + bw.Size.Z / 2 + 3 end
end

function M.getCorridorZ()
	M.detectWallZ()
	local homePos = M.getHomePosition().Position
	if homePos.Z >= 0 then return M._wallZ_front else return M._wallZ_back end
end

-- ========== BASE ==========
function M.findBase()
	local bases = workspace:FindFirstChild("Bases") if not bases then return end
	for _, base in pairs(bases:GetChildren()) do
		pcall(function()
			local pn = base.Title.TitleGui.Frame.PlayerName
			if pn.Text == Player.Name or pn.Text == Player.DisplayName then
				M.baseGUID = base.Name
				local s1 = base:FindFirstChild("slot 1 brainrot")
				if s1 and s1:FindFirstChild("Root") then M.baseCFrame = s1.Root.CFrame end
			end
		end)
	end
	if not M.homePosition then M.setHomePosition() end
end

function M.setHomePosition() local ch = Player.Character if not ch then return end local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return end M.homePosition = hrp.CFrame end
function M.getHomePosition() if M.homePosition then return M.homePosition end if M.baseCFrame then return M.baseCFrame end return CFrame.new(124, 3.8, 22) end

task.spawn(function() task.wait(3) M.findBase() end)

-- ========== RESPAWN ==========
Player.CharacterAdded:Connect(function(character)
	task.wait(1.5) if M.S.InstantPickup then M.setupInstant() end
	task.wait(0.5) M.detectWallZ()
	if M._isGod then
		if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) M._godHealthConn = nil end
		if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) M._godDiedConn = nil end
		task.wait(0.5) godSetupHealth(character) godDisableKillParts()
		pcall(function() for _, d in pairs(M._godOriginalFloors) do if d.part and d.part.Parent then d.part.CanCollide = false d.part.Transparency = 1 end end end)
		task.wait(0.3) godTeleportUnder()
		if M.S.DoomTowerEnabled and M._towerDetectedFloorY then task.wait(0.5) moveTowerToFloor(M._towerDetectedFloorY, M.S.DoomTowerOffset) end
	end
end)

-- ========== TWEEN ==========
function M.tweenTo(cf)
	local ch = Player.Character if not ch then return false end local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local targetCF = cf if M._isGod then targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z) end
	local d = (hrp.Position - targetCF.Position).Magnitude local t = math.max(d / M.S.TweenSpeed, 0.01)
	local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF}) tw:Play() tw.Completed:Wait() return true
end

function M.fastTween(cf)
	local ch = Player.Character if not ch then return false end local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local targetCF = cf if M._isGod then targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z) end
	local d = (hrp.Position - targetCF.Position).Magnitude local t = math.max(d / 99999, 0.005)
	local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF}) tw:Play() tw.Completed:Wait() return true
end

function M.corridorTween(cf)
	local ch = Player.Character if not ch then return false end local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local targetCF = cf if M._isGod then targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z) end
	local d = (hrp.Position - targetCF.Position).Magnitude local t = math.max(d / math.max(M.S.CorridorSpeed or 1500, 50), 0.01)
	local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF}) tw:Play() tw.Completed:Wait() return true
end

function M.valentineTween(cf)
	local ch = Player.Character if not ch then return false end local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local targetCF = cf if M._isGod then targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z) end
	local d = (hrp.Position - targetCF.Position).Magnitude local speed = math.max(M.S.ValentineSpeed or 300, 50)
	local t = math.max(d / speed, 0.01)
	local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF}) tw:Play() tw.Completed:Wait() return true
end

-- ========== SAFE PATH ==========
function M.safePathTo(targetCFrame)
	local ch = Player.Character if not ch then return false end local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local startPos = hrp.Position local endPos = targetCFrame.Position
	local SAFE_Z = M.getCorridorZ() local SAFE_Y = M._isGod and M.S.GodWalkY or (M.getHomePosition().Position.Y + 8)
	M.fastTween(CFrame.new(startPos.X, SAFE_Y, startPos.Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(startPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(endPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(endPos.X, SAFE_Y, endPos.Z)) task.wait(0.05)
	local finalCF = M._isGod and CFrame.new(endPos.X, M.S.GodWalkY, endPos.Z) or targetCFrame
	M.tweenTo(finalCF) task.wait(0.05) return true
end

function M.safeReturnToBase()
	local ch = Player.Character if not ch then return end local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return end
	local curPos = hrp.Position local homePos = M.getHomePosition().Position M.detectWallZ()
	local SAFE_Z = M.getCorridorZ() local SAFE_Y = M._isGod and M.S.GodWalkY or (homePos.Y + 8)
	M.fastTween(CFrame.new(curPos.X, SAFE_Y, curPos.Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(curPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(homePos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(homePos.X, SAFE_Y, homePos.Z)) task.wait(0.05)
	M.tweenTo(CFrame.new(homePos.X, M._isGod and M.S.GodWalkY or homePos.Y, homePos.Z)) task.wait(0.05)
end

function M.returnToBase()
	if M._isGod then local hp = M.getHomePosition().Position M.tweenTo(CFrame.new(hp.X, M.S.GodWalkY, hp.Z))
	else M.tweenTo(M.getHomePosition()) end task.wait(0.1)
end

-- ========== HELPERS ==========
function M.isHighRarity(r) return HIGH_RARITIES[r] == true end
function M.isHighRarityTool(tool) if not tool then return false end return HIGH_RARITIES[tool:GetAttribute("Rarity") or ""] == true end
function M.isDead() local ch = Player.Character if not ch then return true end local hum = ch:FindFirstChild("Humanoid") if not hum then return true end return hum.Health <= 0 end
function M.waitForRespawn() if not M.isDead() then return true end local timeout = tick() + 15 while M.isDead() and tick() < timeout do task.wait(0.2) end task.wait(1) return not M.isDead() end

function M.forceGrabPrompt(target)
	if not target then return end
	local prompts = {}
	if target:IsA("ProximityPrompt") then table.insert(prompts, target)
	else for _, d in pairs(target:GetDescendants()) do if d:IsA("ProximityPrompt") then table.insert(prompts, d) end end end
	for _, p in pairs(prompts) do
		pcall(function() p.MaxActivationDistance = 99999 p.HoldDuration = 0 p.RequiresLineOfSight = false end)
		pcall(function() fireproximityprompt(p) end) task.wait(0.02) pcall(function() fireproximityprompt(p) end)
	end
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local parent = target if parent:IsA("ProximityPrompt") then parent = parent.Parent end
		if parent and parent:IsA("BasePart") then pcall(function() firetouchinterest(hrp, parent, 0) end) pcall(function() firetouchinterest(hrp, parent, 1) end) end
	end
	task.wait(0.02)
end

-- ========== RARITY ==========
function M.getTargetRarities() return type(M.S.TargetRarity) == "table" and M.S.TargetRarity or {M.S.TargetRarity} end
function M.rarityMatches(fn) for _, r in pairs(M.getTargetRarities()) do if r == "Any" or r == fn then return true end end return false end

function M.getBrainrotNames(rarity)
	local names, seen = {}, {}
	if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
	if not M.ActiveBrainrots then return names end
	for _, f in pairs(M.ActiveBrainrots:GetChildren()) do
		if f:IsA("Folder") and (rarity == "Any" or f.Name == rarity) then
			for _, b in pairs(f:GetChildren()) do
				local n = nil
				if b:FindFirstChild("RenderedBrainrot") then n = b.RenderedBrainrot:GetAttribute("BrainrotName")
				elseif b.Name == "RenderedBrainrot" then n = b:GetAttribute("BrainrotName")
				else n = b:GetAttribute("BrainrotName") or b.Name end
				if n and n ~= "" and not seen[n] then seen[n] = true table.insert(names, n) end
			end
		end
	end
	table.sort(names) return names
end

function M.getBrainrotNamesMulti(rarities)
	if type(rarities) ~= "table" then return M.getBrainrotNames(rarities) end
	local names, seen = {}, {}
	for _, r in pairs(rarities) do if r == "Any" then return M.getBrainrotNames("Any") end end
	for _, r in pairs(rarities) do for _, n in pairs(M.getBrainrotNames(r)) do if not seen[n] then seen[n] = true table.insert(names, n) end end end
	table.sort(names) return names
end

function M.matchesFilter(b, folderRarity)
	if not M.rarityMatches(folderRarity) then return false end
	if M.isHighRarity(folderRarity) then return true end
	local mut = b:GetAttribute("Mutation") or "None" local isNone = (mut:lower() == "none" or mut == "")
	if M.S.TargetMutation == "None" then if not isNone then return false end
	elseif M.S.TargetMutation ~= "Any" then if mut ~= M.S.TargetMutation then return false end end
	if #M.S.SelectedBrainrots > 0 then
		local bName = b:GetAttribute("BrainrotName") or "" local found = false
		for _, sel in pairs(M.S.SelectedBrainrots) do if sel == bName then found = true break end end
		if not found then return false end
	end
	return true
end

function M.toolMatchesRarity(tool, targetRarity, targetMutation)
	local tMut = tool:GetAttribute("Mutation") or "None" local lvl = tonumber(tool:GetAttribute("Level")) or 0
	local bName = tool:GetAttribute("BrainrotName") local toolRarity = tool:GetAttribute("Rarity")
	if not bName or bName == "" then return false end if lvl >= M.S.MaxLevel then return false end
	if toolRarity and M.isHighRarity(toolRarity) then local tR = type(targetRarity) == "table" and targetRarity or {targetRarity} for _, r in pairs(tR) do if r == "Any" or r == toolRarity then return true end end return false end
	if targetMutation == "None" then if not (tMut:lower() == "none" or tMut == "") then return false end
	elseif targetMutation ~= "Any" then if tMut ~= targetMutation then return false end end
	local tR = type(targetRarity) == "table" and targetRarity or {targetRarity}
	local isAny = false for _, r in pairs(tR) do if r == "Any" then isAny = true break end end
	if not isAny then
		if toolRarity and toolRarity ~= "" then local m2 = false for _, r in pairs(tR) do if toolRarity == r then m2 = true break end end if not m2 then return false end
		else local wl = {} for _, r in pairs(tR) do for _, n in pairs(M.getBrainrotNames(r)) do wl[n] = true end end if not wl[bName] then return false end end
	end
	return true
end

function M.getAvailableMutations()
	local muts = {"Any", "None"} local seen = {["Any"] = true, ["None"] = true}
	pcall(function() local mf = game:GetService("ReplicatedStorage"):FindFirstChild("Assets") if mf then mf = mf:FindFirstChild("Mutations") if mf then for _, m in pairs(mf:GetChildren()) do if not seen[m.Name] then seen[m.Name] = true table.insert(muts, m.Name) end end end end end)
	for _, m in pairs({"Emerald","Gold","Blood","Diamond","Rainbow","Shadow","Crystal","Void","Doom"}) do if not seen[m] then seen[m] = true table.insert(muts, m) end end
	return muts
end

function M.getAvailableRarities()
	local rars, seen = {}, {}
	for _, r in pairs({"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity"}) do if not seen[r] then seen[r] = true table.insert(rars, r) end end
	pcall(function() if M.ActiveBrainrots then for _, f in pairs(M.ActiveBrainrots:GetChildren()) do if f:IsA("Folder") and not seen[f.Name] then seen[f.Name] = true table.insert(rars, f.Name) end end end end)
	return rars
end

-- ========== FACTORY ==========
local function factoryToolMatchesRarity(tool)
	local tMut = tool:GetAttribute("Mutation") or "None" local lvl = tonumber(tool:GetAttribute("Level")) or 0
	local bName = tool:GetAttribute("BrainrotName") local toolRarity = tool:GetAttribute("Rarity")
	if not bName or bName == "" then return false end if lvl >= M.S.FactoryMaxLevel then return false end
	if M.S.FactoryMutation == "None" then if not (tMut:lower() == "none" or tMut == "") then return false end
	elseif M.S.FactoryMutation ~= "Any" then if tMut ~= M.S.FactoryMutation then return false end end
	if M.S.FactoryRarity ~= "Any" then if toolRarity and toolRarity ~= "" then if toolRarity ~= M.S.FactoryRarity then return false end
	else local wl = {} for _, n in pairs(M.getBrainrotNames(M.S.FactoryRarity)) do wl[n] = true end if not wl[bName] then return false end end end
	return true
end

function M.startFactoryLoop()
	if M.factoryThread then return end M.S.FactoryEnabled = true M.Status.factoryCount = 0
	M.factoryThread = task.spawn(function()
		local stopReason = "Idle"
		while M.S.FactoryEnabled do
			local ok = pcall(function()
				if not M.baseGUID then M.findBase() end if not M.baseGUID then task.wait(2) return end
				local ws = tonumber(M.S.FactorySlot) or 5
				M.tweenToSlot(ws) task.wait(0.2)
				if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(1) pcall(function() Player.Character.Humanoid:UnequipTools() end) task.wait(0.5) end
				local tool = nil local sa = 0
				while not tool and sa < 5 do sa += 1
					local bp = Player:FindFirstChild("Backpack") if bp then for _, t in pairs(bp:GetChildren()) do if t:IsA("Tool") and factoryToolMatchesRarity(t) then tool = t break end end end
					if not tool and Player.Character then local eq = Player.Character:FindFirstChildWhichIsA("Tool") if eq and factoryToolMatchesRarity(eq) then tool = eq end end
					if not tool and sa < 5 then task.wait(0.6) end
				end
				if not tool then stopReason = "Klaar! âœ“" M.S.FactoryEnabled = false return end
				local bName = tool:GetAttribute("BrainrotName") or "Item"
				local hum = Player.Character and Player.Character:FindFirstChild("Humanoid")
				if hum then hum:EquipTool(tool) task.wait(0.5) end
				M.placeBrainrot(ws) task.wait(0.8)
				if M.isSlotEmpty(ws) then pcall(function() if hum then hum:UnequipTools() end end) task.wait(1) return end
				local myBase = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
				local sm = myBase and myBase:FindFirstChild("slot " .. ws .. " brainrot")
				if sm then local cur = tonumber(sm:GetAttribute("Level")) or 0 local fails = 0
					while cur < M.S.FactoryMaxLevel and M.S.FactoryEnabled do
						M.upgradeBrainrot(ws) task.wait(0.1)
						local nw = tonumber(sm:GetAttribute("Level")) or cur
						if nw > cur then fails = 0 cur = nw M.Status.factory = bName .. " Lv." .. cur .. "/" .. M.S.FactoryMaxLevel
						else fails += 1 if fails > 60 then stopReason = "Geld op!" M.S.FactoryEnabled = false break end end
					end
				end
				task.wait(0.5) M.pickUpBrainrot(ws) task.wait(1.2) M.Status.factoryCount += 1
				pcall(function() if hum then hum:UnequipTools() end end) task.wait(0.5)
				M.Status.factory = "âœ“ " .. bName .. " (#" .. M.Status.factoryCount .. ")"
			end)
			if not ok then task.wait(1) end
		end
		M.Status.factory = stopReason M.factoryThread = nil
	end)
end

function M.stopFactoryLoop()
	M.S.FactoryEnabled = false
	if M.factoryThread then pcall(task.cancel, M.factoryThread) M.factoryThread = nil end
	if not (string.find(M.Status.factory or "", "âœ“") or string.find(M.Status.factory or "", "Klaar") or string.find(M.Status.factory or "", "Geld op")) then M.Status.factory = "Idle" end
end

-- ========== FIND TARGET TOOL ==========
function M.findTargetToolInBackpack()
	local bp = Player:FindFirstChild("Backpack") if bp then for _, t in pairs(bp:GetChildren()) do if t:IsA("Tool") and M.toolMatchesRarity(t, M.S.TargetRarity, M.S.TargetMutation) then return t end end end
	local ch = Player.Character if ch then local eq = ch:FindFirstChildWhichIsA("Tool") if eq and M.toolMatchesRarity(eq, M.S.TargetRarity, M.S.TargetMutation) then return eq end end
	return nil
end

function M.findBrainrotRoot(b)
	local root = b:FindFirstChild("Root") if root and root:IsA("BasePart") then return root end
	local rendered = b:FindFirstChild("RenderedBrainrot") if rendered then local rr = rendered:FindFirstChild("Root") if rr and rr:IsA("BasePart") then return rr end end
	for _, desc in pairs(b:GetDescendants()) do if desc:IsA("BasePart") then return desc end end
	if b:IsA("BasePart") then return b end return nil
end

-- ========== SLOTS ==========
function M.isSlotEmpty(s) if not M.baseGUID then M.findBase() end if not M.baseGUID then return true end local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return true end local sm = mb:FindFirstChild("slot " .. s .. " brainrot") if not sm then return true end local bn = sm:GetAttribute("BrainrotName") return not bn or bn == "" end
function M.findOccupiedSlots() if not M.baseGUID then M.findBase() end if not M.baseGUID then return {} end local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return {} end local o = {} for i = 1, 40 do local sm = mb:FindFirstChild("slot " .. i .. " brainrot") if sm then local bn = sm:GetAttribute("BrainrotName") local lv = sm:GetAttribute("Level") if bn and bn ~= "" then table.insert(o, {slot = i, name = bn, level = lv or 1}) end end end return o end

-- ========== REMOTES (THROTTLED) ==========
local _lastPlotCall = 0
local PLOT_COOLDOWN = 0.15

local function throttledPlotAction(...)
	local now = tick()
	if now - _lastPlotCall < PLOT_COOLDOWN then task.wait(PLOT_COOLDOWN - (now - _lastPlotCall)) end
	_lastPlotCall = tick()
	if not M.PlotAction then return false end
	return pcall(function() M.PlotAction:InvokeServer(...) end)
end

function M.placeBrainrot(s) if not M.baseGUID then return false end local ok = throttledPlotAction("Place Brainrot", M.baseGUID, tostring(s)) if ok then M.Status.placeCount += 1 end return ok end
function M.pickUpBrainrot(s) if not M.baseGUID then return false end return throttledPlotAction("Pick Up Brainrot", M.baseGUID, tostring(s)) end
function M.clearSlot(s) if not M.baseGUID then return end throttledPlotAction("Pick Up Brainrot", M.baseGUID, tostring(s)) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
function M.upgradeBrainrot(s) if not M.baseGUID then return false end return throttledPlotAction("Upgrade Brainrot", M.baseGUID, tostring(s)) end

function M.tweenToSlot(sn)
	if not M.baseGUID then M.findBase() end if not M.baseGUID then return false end
	local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return false end
	local sm = mb:FindFirstChild("slot " .. sn .. " brainrot") if not sm then return false end
	local root = sm:FindFirstChild("Root") if root and root:IsA("BasePart") then return M.tweenTo(root.CFrame * CFrame.new(0, 3, 0)) end
	local ok, pos = pcall(function() return sm:GetPivot() end) if ok and pos then return M.tweenTo(pos * CFrame.new(0, 3, 0)) end return false
end

function M.upgradeSlotToMax(slot)
	if not M.baseGUID then M.findBase() end if not M.baseGUID then return end
	local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return end
	local sm = mb:FindFirstChild("slot " .. slot .. " brainrot") if not sm then return end
	local cur = tonumber(sm:GetAttribute("Level")) or 1 local fails = 0
	while cur < M.S.MaxLevel and M.S.AutoUpgrade do
		M.upgradeBrainrot(slot) task.wait(0.15)
		local nw = tonumber(sm:GetAttribute("Level")) or cur
		if nw > cur then fails = 0 cur = nw M.Status.upgradeCount += 1 else fails += 1 if fails >= 60 then break end end
	end
end

-- ========== FARMING ==========
function M.startFarming()
	if M.farmThread then return end M.S.Farming = true M.Status.farmCount = 0
	M.setHomePosition() M.detectWallZ() M.returnToBase() M.enableGod()
	M.farmThread = task.spawn(function()
		while M.S.Farming do
			local ok = pcall(function()
				if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() task.wait(0.5) return end
				local ch = Player.Character local hum = ch and ch:FindFirstChild("Humanoid") if not ch or not hum then task.wait(1) return end
				if not M.baseGUID then M.findBase() end if not M.baseGUID then task.wait(2) return end
				local ws = tonumber(M.S.FarmSlot) or 5

				if M.S.FarmMode == "Collect" then
					if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
					if M.ActiveBrainrots then for _, folder in pairs(M.ActiveBrainrots:GetChildren()) do
						if not M.S.Farming then break end
						if folder:IsA("Folder") and M.rarityMatches(folder.Name) then for _, b in pairs(folder:GetChildren()) do
							if not M.S.Farming or M.isDead() then break end
							if M.matchesFilter(b, folder.Name) then
								local root = M.findBrainrotRoot(b) if not root then continue end
								M.safePathTo(root.CFrame * CFrame.new(0, 3, 0))
								for attempt = 1, 5 do if not M.S.Farming then break end
									if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() if root and root.Parent then M.safePathTo(root.CFrame * CFrame.new(0, 3, 0)) else break end end
									if root and root.Parent then M.forceGrabPrompt(root) M.forceGrabPrompt(b) task.wait(0.3) M.Status.farmCount += 1 break else break end
								end
								M.safeUnequip() task.wait(0.1) M.safeReturnToBase()
							end
						end end
					end end
					task.wait(1) return
				end

				if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
				local tool = M.findTargetToolInBackpack()
				if tool and M.isHighRarityTool(tool) then M.Status.farm = "âœ“ " .. (tool:GetAttribute("Rarity") or "High") M.Status.farmCount += 1 task.wait(0.5) tool = nil end

				if not tool then
					local found = false
					if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
					if M.ActiveBrainrots then for _, folder in pairs(M.ActiveBrainrots:GetChildren()) do
						if not M.S.Farming then break end
						if folder:IsA("Folder") and M.rarityMatches(folder.Name) then for _, b in pairs(folder:GetChildren()) do
							if not M.S.Farming or M.isDead() then break end
							if M.matchesFilter(b, folder.Name) then
								local root = M.findBrainrotRoot(b) if not root then continue end found = true
								M.Status.farm = "Ophalen " .. folder.Name
								M.safePathTo(root.CFrame * CFrame.new(0, 3, 0))
								for attempt = 1, 5 do if not M.S.Farming then break end
									if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() if not M.S.Farming then break end if root and root.Parent then M.safePathTo(root.CFrame * CFrame.new(0, 3, 0)) else found = false break end end
									if root and root.Parent then M.forceGrabPrompt(root) M.forceGrabPrompt(b) task.wait(0.3) M.Status.farmCount += 1 break else found = false break end
								end
								M.safeUnequip() task.wait(0.1) M.safeReturnToBase() break
							end
						end end
						if found then break end
					end end
					if not found then M.Status.farm = "Wachten..." task.wait(2) return end
					task.wait(0.3) tool = M.findTargetToolInBackpack() if not tool then task.wait(1) return end
				end

				if M.isHighRarityTool(tool) then M.Status.farm = "âœ“ High" M.Status.farmCount += 1 task.wait(0.5) return end

				local bName = tool:GetAttribute("BrainrotName") or "Brainrot"
				M.tweenToSlot(ws) task.wait(0.3) M.safeEquip(tool) task.wait(0.5) M.placeBrainrot(ws) task.wait(0.8)
				if M.isSlotEmpty(ws) then M.safeUnequip() task.wait(1) return end
				local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
				local sm = mb and mb:FindFirstChild("slot " .. ws .. " brainrot")
				if sm then local cur = tonumber(sm:GetAttribute("Level")) or 0 local fails = 0
					while cur < M.S.MaxLevel and M.S.Farming do
						M.upgradeBrainrot(ws) task.wait(0.15)
						local nw = tonumber(sm:GetAttribute("Level")) or cur
						if nw > cur then fails = 0 cur = nw M.Status.upgradeCount += 1 M.Status.farm = bName .. " Lv." .. cur .. "/" .. M.S.MaxLevel
						else fails += 1 if fails > 60 then break end end
					end
				end
				task.wait(0.3) M.pickUpBrainrot(ws) task.wait(0.8) M.safeUnequip() task.wait(0.3)
				if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
			end)
			if not ok then task.wait(1) end task.wait(0.3)
		end
		M.disableGod() M.Status.farm = "Idle" M.farmThread = nil
	end)
end

function M.stopFarming() M.S.Farming = false if M.farmThread then pcall(task.cancel, M.farmThread) M.farmThread = nil end M.disableGod() M.Status.farm = "Idle" end

-- ========== LUCKY BLOCKS ==========
function M.getLuckyBlockRarities() return type(M.S.LuckyBlockRarity) == "table" and M.S.LuckyBlockRarity or {M.S.LuckyBlockRarity} end
function M.luckyBlockRarityMatches(bn) for _, r in pairs(M.getLuckyBlockRarities()) do if r == "Any" or bn:find(r) or bn == r then return true end end return false end
function M.luckyBlockMutationMatches(block) local mut = block:GetAttribute("Mutation") or "None" local isNone = (mut:lower() == "none" or mut == "") if M.S.LuckyBlockMutation == "Any" then return true end if M.S.LuckyBlockMutation == "None" then return isNone end return mut == M.S.LuckyBlockMutation end
function M.findLuckyBlockRoot(block) local r = block:FindFirstChild("Root") if r and r:IsA("BasePart") then return r end if block:IsA("BasePart") then return block end local p = nil pcall(function() p = block.PrimaryPart end) if p then return p end for _, d in pairs(block:GetDescendants()) do if d:IsA("BasePart") then return d end end return nil end

function M.grabLuckyBlock(block, rootPart)
	if not block or not rootPart then return end
	for _, d in pairs(block:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.MaxActivationDistance = 99999 d.HoldDuration = 0 d.RequiresLineOfSight = false end) pcall(function() fireproximityprompt(d) end) end end
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		if rootPart:IsA("BasePart") then pcall(function() firetouchinterest(hrp, rootPart, 0) firetouchinterest(hrp, rootPart, 1) end) end
		for _, d in pairs(block:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end) end end
	end
end

function M.startLuckyBlockFarm()
	if M.luckyBlockThread then return end M.S.LuckyBlockEnabled = true M.Status.luckyBlockCount = 0 M.setHomePosition() M.enableGod()
	M.luckyBlockThread = task.spawn(function()
		while M.S.LuckyBlockEnabled do
			local ok = pcall(function()
				if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() return end
				if not M.ActiveLuckyBlocks then M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks") end
				if not M.ActiveLuckyBlocks then task.wait(3) return end
				local foundBlock = false
				for _, block in pairs(M.ActiveLuckyBlocks:GetChildren()) do
					if not M.S.LuckyBlockEnabled or M.isDead() then break end
					if M.luckyBlockRarityMatches(block.Name) and M.luckyBlockMutationMatches(block) then
						local rootPart = M.findLuckyBlockRoot(block) if not rootPart then continue end foundBlock = true
						M.safePathTo(rootPart.CFrame * CFrame.new(0, 3, 0))
						M.grabLuckyBlock(block, rootPart)
						local t = tick() while tick() - t < 0.2 do if not block.Parent or not rootPart.Parent then break end task.wait(0.02) end
						if not block.Parent or not rootPart.Parent then M.Status.luckyBlockCount += 1 end
						M.safeUnequip() M.safeReturnToBase() break
					end
				end
				if not foundBlock then task.wait(2) end
			end)
			task.wait(0.1)
		end
		M.disableGod() M.Status.luckyBlock = "Idle" M.luckyBlockThread = nil
	end)
end

function M.stopLuckyBlockFarm() M.S.LuckyBlockEnabled = false if M.luckyBlockThread then pcall(task.cancel, M.luckyBlockThread) M.luckyBlockThread = nil end M.disableGod() M.Status.luckyBlock = "Idle" end

-- ========== MONEY ==========
function M.startMoney()
	if M.moneyThread then return end M.S.AutoCollectMoney = true M.Status.money = "Actief" if not M.baseGUID then M.findBase() end
	M.moneyThread = task.spawn(function()
		while M.S.AutoCollectMoney do
			pcall(function()
				if not M.baseGUID then M.findBase() end if not M.baseGUID then return end
				local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
				local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
				if not mb or not hrp then return end
				for i = 1, 40 do local sm = mb:FindFirstChild("slot " .. i .. " brainrot")
					if sm and sm:GetAttribute("BrainrotName") and sm:GetAttribute("BrainrotName") ~= "" then
						for _, d in pairs(sm:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end) end end
					end
				end
			end)
			task.wait(0.5)
		end
		M.Status.money = "Idle"
	end)
	M.moneyRemoteThread = task.spawn(function()
		while M.S.AutoCollectMoney do
			pcall(function() if M.baseGUID and M.PlotAction then for i = 1, 40 do if not M.S.AutoCollectMoney then break end throttledPlotAction("Collect Money", M.baseGUID, tostring(i)) end end end)
			task.wait(5)
		end
	end)
end
function M.stopMoney() M.S.AutoCollectMoney = false if M.moneyThread then pcall(task.cancel, M.moneyThread) M.moneyThread = nil end if M.moneyRemoteThread then pcall(task.cancel, M.moneyRemoteThread) M.moneyRemoteThread = nil end M.Status.money = "Idle" end

-- ========== AUTO UPGRADE ==========
function M.startAutoUpgrade() if M.upgradeThread then return end M.S.AutoUpgrade = true M.Status.upgradeCount = 0 M.upgradeThread = task.spawn(function() while M.S.AutoUpgrade do pcall(function() for _, info in pairs(M.findOccupiedSlots()) do if not M.S.AutoUpgrade then break end if info.level < M.S.MaxLevel then M.upgradeSlotToMax(info.slot) end end M.Status.upgrade = "Klaar (#" .. M.Status.upgradeCount .. ")" end) task.wait(5) end M.Status.upgrade = "Idle" end) end
function M.stopAutoUpgrade() M.S.AutoUpgrade = false if M.upgradeThread then pcall(task.cancel, M.upgradeThread) M.upgradeThread = nil end M.Status.upgrade = "Idle" end

-- ========== ANTI AFK ==========
function M.startAFK() if M.afkThread then return end M.S.AntiAFK = true M.Status.afk = "Actief" pcall(function() for _, c in pairs(getconnections(Player.Idled)) do c:Disable() end end) pcall(function() local vu = game:GetService("VirtualUser") M._afkSteppedConn = RunService.Stepped:Connect(function() if M.S.AntiAFK then pcall(function() vu:CaptureController() vu:ClickButton2(Vector2.new()) end) end end) end) M.afkThread = task.spawn(function() while M.S.AntiAFK do pcall(function() for _, c in pairs(getconnections(Player.Idled)) do c:Disable() end end) task.wait(300) end M.Status.afk = "Uit" end) end
function M.stopAFK() M.S.AntiAFK = false if M.afkThread then pcall(task.cancel, M.afkThread) M.afkThread = nil end if M._afkSteppedConn then pcall(function() M._afkSteppedConn:Disconnect() end) M._afkSteppedConn = nil end M.Status.afk = "Uit" end

-- ========== INSTANT PICKUP ==========
function M.setupInstant() for _, o in pairs(workspace:GetDescendants()) do if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration = 0 end) end end if not M._instantConn then M._instantConn = workspace.DescendantAdded:Connect(function(o) if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration = 0 end) end end) end end
M.setupInstant()

-- ============================================
-- VALENTINE v2 - RENT NAAR BRAINROTS
-- ============================================
function M.getHeartCount()
	local count = 0
	pcall(function() local ls = Player:FindFirstChild("leaderstats") if ls then for _, v in pairs(ls:GetChildren()) do local n = v.Name:lower() if n:find("heart") or n:find("candy") or n:find("valentine") or n:find("gram") then count = tonumber(v.Value) or 0 return end end end end)
	if count == 0 then pcall(function() for _, a in pairs({"Hearts","Candy","CandyGrams","Valentines","Love","CandyHearts"}) do local v = Player:GetAttribute(a) if v and tonumber(v) and tonumber(v) > 0 then count = tonumber(v) return end end end) end
	return count
end

function M.refreshValentineCache()
	M._valentineCachedParts = {} M._valentineLastCacheScan = tick()
	local kw = {"heart","candy","valentine","love","gram","pickup","collect","token"}
	for _, obj in pairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then local n = obj.Name:lower() local m = false
			for _, k in pairs(kw) do if n:find(k) then m = true break end end
			if not m and obj:FindFirstChild("TouchInterest") then m = true end
			if m then table.insert(M._valentineCachedParts, obj) end
		end
	end
end

function M.findValentineStation()
	local kw = {"candygram","station","submit","deposit","exchange","mailbox","postbox","valentine"}
	local best, bestDist = nil, math.huge
	for _, obj in pairs(workspace:GetDescendants()) do
		local n = obj.Name:lower() local match = false
		for _, k in pairs(kw) do if n:find(k) then match = true break end end
		if match then
			local hasPrompt = false
			if obj:IsA("BasePart") or obj:IsA("Model") then
				for _, d in pairs(obj:GetDescendants()) do if d:IsA("ProximityPrompt") then hasPrompt = true break end end
				if not hasPrompt and obj:FindFirstChildWhichIsA("ProximityPrompt") then hasPrompt = true end
			end
			if obj:IsA("ProximityPrompt") then hasPrompt = true end
			if hasPrompt then
				local pos = nil
				if obj:IsA("BasePart") then pos = obj.Position
				elseif obj:IsA("Model") then pcall(function() pos = obj:GetPivot().Position end) if not pos then for _, d in pairs(obj:GetDescendants()) do if d:IsA("BasePart") then pos = d.Position break end end end
				elseif obj:IsA("ProximityPrompt") and obj.Parent and obj.Parent:IsA("BasePart") then pos = obj.Parent.Position end
				if pos then
					local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
					local dist = hrp and (hrp.Position - pos).Magnitude or 0
					if not best or dist < bestDist then best = obj bestDist = dist M._valentineStationCF = CFrame.new(pos) M._valentineStationObj = obj end
				end
			end
		end
	end
	return best
end

function M.submitAtStation()
	local station = M._valentineStationObj or M.findValentineStation()
	if not station then return false end
	local targetCF = M._valentineStationCF
	if targetCF then
		if M._isGod then M.valentineTween(CFrame.new(targetCF.Position.X, M.S.GodWalkY, targetCF.Position.Z))
		else M.valentineTween(targetCF * CFrame.new(0, 3, 0)) end
		task.wait(0.5)
	end
	local fired = false
	local function firePrompts(obj)
		if obj:IsA("ProximityPrompt") then pcall(function() obj.HoldDuration = 0 obj.MaxActivationDistance = 99999 obj.RequiresLineOfSight = false end) pcall(function() fireproximityprompt(obj) end) fired = true end
		for _, d in pairs(obj:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration = 0 d.MaxActivationDistance = 99999 d.RequiresLineOfSight = false end) pcall(function() fireproximityprompt(d) end) fired = true end end
	end
	firePrompts(station) if station.Parent then firePrompts(station.Parent) end
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local function touchAll(obj) if obj:IsA("BasePart") then pcall(function() firetouchinterest(hrp, obj, 0) firetouchinterest(hrp, obj, 1) end) end for _, d in pairs(obj:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end) end end end
		touchAll(station) if station.Parent and not station.Parent:IsA("Workspace") then touchAll(station.Parent) end
	end
	task.wait(0.5)
	if not fired and hrp then for _, obj in pairs(workspace:GetDescendants()) do if obj:IsA("ProximityPrompt") and obj.Parent and obj.Parent:IsA("BasePart") then local dist = (obj.Parent.Position - hrp.Position).Magnitude if dist < 20 then pcall(function() obj.HoldDuration = 0 obj.MaxActivationDistance = 99999 obj.RequiresLineOfSight = false end) pcall(function() fireproximityprompt(obj) end) fired = true end end end end
	return fired
end

function M.findValentineBrainrots()
	local targets = {}
	if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
	if not M.ActiveBrainrots then return targets end
	for _, folder in pairs(M.ActiveBrainrots:GetChildren()) do
		if folder:IsA("Folder") then
			local isTarget = false
			for _, r in pairs(VALENTINE_FARM_RARITIES) do if folder.Name == r then isTarget = true break end end
			if isTarget then
				for _, b in pairs(folder:GetChildren()) do
					local root = M.findBrainrotRoot(b)
					if root and root:IsA("BasePart") and root.Parent then
						table.insert(targets, {brainrot = b, root = root, rarity = folder.Name, position = root.Position})
					end
				end
			end
		end
	end
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then table.sort(targets, function(a, b) return (a.position - hrp.Position).Magnitude < (b.position - hrp.Position).Magnitude end) end
	return targets
end

function M.touchBrainrotForHearts(brainrot, root)
	if not root or not root.Parent then return end
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not hrp then return end
	pcall(function() firetouchinterest(hrp, root, 0) firetouchinterest(hrp, root, 1) end)
	for _, d in pairs(brainrot:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end) end end
	for _, d in pairs(brainrot:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration = 0 d.MaxActivationDistance = 99999 d.RequiresLineOfSight = false end) pcall(function() fireproximityprompt(d) end) end end
	M.safeUnequip()
end

function M.startValentine()
	if M.valentineThread then return end
	M.S.ValentineEnabled = true M.Status.valentineCount = 0 M.Status.valentineHearts = 0
	M.refreshValentineCache()
	M.findValentineStation()
	if M._valentineDescAddedConn then pcall(function() M._valentineDescAddedConn:Disconnect() end) end
	M._valentineDescAddedConn = workspace.DescendantAdded:Connect(function(d)
		if not M.S.ValentineEnabled then return end
		if d:IsA("BasePart") then local n = d.Name:lower() for _, k in pairs({"heart","candy","valentine","gram","love","token","pickup"}) do if n:find(k) then table.insert(M._valentineCachedParts, d) pcall(function() local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if hrp then firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end end) break end end end
		if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration = 0 d.MaxActivationDistance = 99999 end) end
	end)
	M.valentineCollectorConn = RunService.Heartbeat:Connect(function()
		if not M.S.ValentineEnabled then return end
		pcall(function()
			local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not hrp then return end
			if tick() - M._valentineLastCacheScan > 10 then local a = {} for _, p in pairs(M._valentineCachedParts) do if p and p.Parent then table.insert(a, p) end end M._valentineCachedParts = a M._valentineLastCacheScan = tick() end
			for _, p in pairs(M._valentineCachedParts) do if p and p.Parent then firetouchinterest(hrp, p, 0) firetouchinterest(hrp, p, 1) end end
		end)
	end)
	M.valentineThread = task.spawn(function()
		while M.S.ValentineEnabled do
			local ok = pcall(function()
				if M.isDead() then M.waitForRespawn() task.wait(1) return end
				local hearts = M.getHeartCount() M.Status.valentineHearts = hearts
				if hearts >= 100 then
					M.Status.valentine = "Submitting... (" .. hearts .. ")"
					M.findValentineStation()
					local prevH = hearts
					for attempt = 1, 5 do
						if not M.S.ValentineEnabled then break end
						M.submitAtStation() task.wait(1.5)
						local newH = M.getHeartCount()
						if newH < prevH or newH == 0 then M.Status.valentineCount += 1 M.Status.valentine = "Submitted! âœ“ #" .. M.Status.valentineCount break end
						task.wait(1)
					end
					M.refreshValentineCache() task.wait(0.5) return
				end
				local brainrots = M.findValentineBrainrots()
				if #brainrots == 0 then M.Status.valentine = "Wachten... H:" .. hearts task.wait(2) return end
				for _, target in pairs(brainrots) do
					if not M.S.ValentineEnabled or M.isDead() then break end
					local curHearts = M.getHeartCount() M.Status.valentineHearts = curHearts
					if curHearts >= 100 then break end
					M.Status.valentine = "â†’ " .. target.rarity .. " H:" .. curHearts .. "/100"
					M.valentineTween(target.root.CFrame * CFrame.new(0, 3, 0))
					if target.root and target.root.Parent then M.touchBrainrotForHearts(target.brainrot, target.root) end
					task.wait(0.15)
				end
			end)
			if not ok then task.wait(1) end task.wait(0.2)
		end
		M.Status.valentine = "Idle" M.valentineThread = nil
	end)
end

function M.stopValentine()
	M.S.ValentineEnabled = false
	if M.valentineThread then pcall(task.cancel, M.valentineThread) M.valentineThread = nil end
	if M.valentineCollectorConn then pcall(function() M.valentineCollectorConn:Disconnect() end) M.valentineCollectorConn = nil end
	if M._valentineDescAddedConn then pcall(function() M._valentineDescAddedConn:Disconnect() end) M._valentineDescAddedConn = nil end
	M._valentineCachedParts = {} M._valentineStationObj = nil M.Status.valentine = "Idle"
end

-- ========== ARCADE ==========
function M.startArcade() if M.arcadeThread then return end M.S.ArcadeEnabled = true M.Status.arcadeCount = 0 M.arcadeThread = task.spawn(function() while M.S.ArcadeEnabled do pcall(function() local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not hrp then return end for _, fn in pairs({"ArcadeEventConsoles","ArcadeEventTickets"}) do local f = workspace:FindFirstChild(fn) if f then for _, item in pairs(f:GetChildren()) do for _, d in pairs(item:GetDescendants()) do if d:IsA("BasePart") and d:FindFirstChild("TouchInterest") then pcall(function() firetouchinterest(hrp, d, 0) task.wait(0.01) firetouchinterest(hrp, d, 1) end) M.Status.arcadeCount += 1 end end end end end end) task.wait(0.05) end M.Status.arcade = "Idle" M.arcadeThread = nil end) end
function M.stopArcade() M.S.ArcadeEnabled = false if M.arcadeThread then pcall(task.cancel, M.arcadeThread) M.arcadeThread = nil end M.Status.arcade = "Idle" end

-- ========== MAP FIXER (WITH ADAPTIVE COLORS) ==========
local MF = {W=420,WH=80,WT=6,INT=8}
MF.SZ=MF.W/2
MF.WY = MF.WH/2 - 10

local function safeDestroyFolder(parent, fn) if not parent then return end local f = parent:FindFirstChild(fn) if not f or f.Name == "MzDHubWalls" then return end pcall(function() for _, d in pairs(f:GetDescendants()) do if d:IsA("BasePart") then d:Destroy() end end f:Destroy() end) end
local MAP_FOLDERS_REMOVE = {"RightWalls","LeftWalls","Gaps","VIPWalls","SideWalls","Barriers","Fences","Walls","Decorations"}
local EVENT_MAPS = {"ValentinesMap","ArcadeMap","CandyMap","HalloweenMap","ChristmasMap","EasterMap","SummerMap","SpringMap","WinterMap","DoomMap"}

local function isWallPart(p) if not p:IsA("BasePart") then return false end if isMzDPart(p) then return false end local n = p.Name:lower() for _, k in pairs({"vipwall","sidewall","barrier","fence","blocker","border"}) do if n == k or n:find("^"..k) then return true end end if p.Size.Y > 15 and p.Size.Y > p.Size.X*3 and p.Size.Y > p.Size.Z*3 then if math.abs(p.Position.Z) > 60 then return true end end return false end

function M.mapDetectXRange(map, si)
	local minX, maxX = math.huge, -math.huge local found = false
	local function chk(p) if not p:IsA("BasePart") or isMzDPart(p) then return end if p.Size.Y > p.Size.X and p.Size.Y > p.Size.Z then return end if p.Position.Y > 50 or p.Position.Y < -30 or p.Size.X < 5 then return end local l = p.Position.X - p.Size.X/2 local r = p.Position.X + p.Size.X/2 if l < minX then minX = l end if r > maxX then maxX = r end found = true end
	for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") then chk(c) end end local sp = map:FindFirstChild("Spawners") if sp then for _, s in pairs(sp:GetChildren()) do chk(s) end end
	if si then for _, c in pairs(si:GetChildren()) do if c:IsA("BasePart") then chk(c) end end local sf = si:FindFirstChild("Floors") if sf then for _, f in pairs(sf:GetChildren()) do chk(f) end end end
	if found and maxX > minX then return minX-5, maxX+5 end return -15, 4385
end
function M.mapFindShared(mn) return workspace:FindFirstChild(mn.."_SharedInstances") end

local function getFloorParts(map, si)
	local fl = {} local function af(p) if not p:IsA("BasePart") or isMzDPart(p) then return end if p.Size.Y > p.Size.X and p.Size.Y > p.Size.Z then return end if p.Position.Y > 30 or p.Position.Y < -20 or p.Size.X < 5 then return end for _, f in pairs(fl) do if f == p then return end end table.insert(fl, p) end
	local ff = map:FindFirstChild("FirstFloor") if ff and ff:IsA("BasePart") then af(ff) end local gr = map:FindFirstChild("Ground") if gr and gr:IsA("BasePart") then af(gr) end
	local sp = map:FindFirstChild("Spawners") if sp then for _, s in pairs(sp:GetChildren()) do if s:IsA("BasePart") then af(s) end end end
	for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") then local n = c.Name:lower() if n=="firstfloor" or n=="ground" or n=="bridgefloor" or n=="floor" or n=="grass" or n=="path" or n=="road" or n=="platform" then af(c) elseif c.Size.X > 50 and c.Size.Z > 10 and c.Size.Y < 10 then af(c) end end end
	if si then local sf = si:FindFirstChild("Floors") if sf then for _, f in pairs(sf:GetChildren()) do if f:IsA("BasePart") then af(f) end end end for _, c in pairs(si:GetChildren()) do if c:IsA("BasePart") and c.Size.X > 50 and c.Size.Z > 10 and c.Size.Y < 10 then af(c) end end end
	return fl
end

function M.mapCleanup(map) for _, n in pairs(MAP_FOLDERS_REMOVE) do safeDestroyFolder(map, n) end for _, d in pairs(map:GetDescendants()) do if d.Parent and not isMzDPart(d) and d:IsA("BasePart") and isWallPart(d) then pcall(function() d:Destroy() end) end end end
function M.mapCleanupShared(si) if not si then return end for _, n in pairs(MAP_FOLDERS_REMOVE) do safeDestroyFolder(si, n) end for _, d in pairs(si:GetDescendants()) do if d:IsA("BasePart") and not isMzDPart(d) and isWallPart(d) then pcall(function() d:Destroy() end) end end end
function M.mapCleanupMisc() local misc = workspace:FindFirstChild("Misc") if misc then for _, c in pairs(misc:GetChildren()) do if c.Name == "BrickAddition" or c.Name == "Roof" then pcall(function() c:Destroy() end) end end end end
function M.cleanupEventMaps() for _, mn in pairs(EVENT_MAPS) do local em = workspace:FindFirstChild(mn) if em then for _, fn in pairs(MAP_FOLDERS_REMOVE) do safeDestroyFolder(em, fn) end for _, d in pairs(em:GetDescendants()) do if d:IsA("BasePart") and not isMzDPart(d) and isWallPart(d) then pcall(function() d:Destroy() end) end end end end end

function M.mapWidenFloors(map, si) for _, p in pairs(getFloorParts(map, si)) do pcall(function() if math.abs(p.Size.Z - MF.W) > 1 then p.Size = Vector3.new(p.Size.X, p.Size.Y, MF.W) p.Position = Vector3.new(p.Position.X, p.Position.Y, 0) end end) end end

function M.mapFillGaps(map, sx, ex)
	local ref = nil local ff = map:FindFirstChild("FirstFloor") if ff and ff:IsA("BasePart") then ref = ff end
	if not ref then local g = map:FindFirstChild("Ground") if g and g:IsA("BasePart") then ref = g end end
	if not ref then local sp = map:FindFirstChild("Spawners") if sp then for _, s in pairs(sp:GetChildren()) do if s:IsA("BasePart") then ref = s break end end end end
	if not ref then for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") and not isMzDPart(c) and c.Size.X > 50 and c.Size.Y < 10 and c.Position.Y < 20 then ref = c break end end end
	if not ref then return end
	local fY, fH, fC, fM = ref.Position.Y, ref.Size.Y, ref.Color, ref.Material
	for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") and c.Name == "BridgeFloor" then pcall(function() c:Destroy() end) end end
	local maxSeg = 2000 local curX = sx
	while curX < ex do local segLen = math.min(maxSeg, ex - curX)
		local b = Instance.new("Part") b.Name = "BridgeFloor" b.Size = Vector3.new(segLen, fH, MF.W) b.Position = Vector3.new(curX + segLen/2, fY, 0)
		b.Anchored = true b.CanCollide = true b.Color = fC b.Material = fM b.TopSurface = Enum.SurfaceType.Smooth b.BottomSurface = Enum.SurfaceType.Smooth b.Parent = map
		curX = curX + segLen end
end

function M.mapBuildWalls(map, sx, ex)
	local scheme = getActiveColorScheme()
	local mf = map:FindFirstChild("MzDHubWalls")
	if mf then pcall(function() mf:Destroy() end) end
	mf = Instance.new("Folder") mf.Name = "MzDHubWalls" mf.Parent = map
	local function mw(nm, sz, ps)
		local w = Instance.new("Part") w.Name = nm w.Size = sz w.Position = ps
		w.Anchored = true w.CanCollide = true
		w.Color = scheme.wall w.Material = Enum.Material.SmoothPlastic
		w.TopSurface = Enum.SurfaceType.Smooth w.BottomSurface = Enum.SurfaceType.Smooth
		w.Parent = mf return w
	end
	local function ms(nm, sz, ps)
		local s = Instance.new("Part") s.Name = nm s.Size = sz s.Position = ps
		s.Anchored = true s.CanCollide = false
		s.Color = scheme.wallStripe s.Material = Enum.Material.Neon
		s.Parent = mf
	end
	local function at(w, f)
		local sg = Instance.new("SurfaceGui") sg.Face = f sg.CanvasSize = Vector2.new(800,400) sg.Parent = w
		local t = Instance.new("TextLabel") t.Size = UDim2.new(1,0,0.5,0) t.Position = UDim2.new(0,0,0.1,0)
		t.BackgroundTransparency = 1 t.Text = "MzD Hub" t.TextColor3 = scheme.wallText t.TextScaled = true t.Font = Enum.Font.GothamBold t.Parent = sg
		local s2 = Instance.new("TextLabel") s2.Size = UDim2.new(0.6,0,0.2,0) s2.Position = UDim2.new(0.2,0,0.6,0)
		s2.BackgroundTransparency = 1 s2.Text = "v12.3" s2.TextColor3 = Color3.fromRGB(200,200,200) s2.TextScaled = true s2.Font = Enum.Font.Gotham s2.Parent = sg
	end
	local segs = {} local sl = 2000 local p = sx while p < ex do local l = math.min(sl, ex-p) table.insert(segs, {s=p,l=l}) p = p + l end
	for i, s in pairs(segs) do
		local cx = s.s + s.l/2
		local fw = mw("FrontWall_"..i, Vector3.new(s.l, MF.WH, MF.WT), Vector3.new(cx, MF.WY, MF.SZ+MF.WT/2))
		at(fw, Enum.NormalId.Front) at(fw, Enum.NormalId.Back)
		ms("FS_t"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, 20, MF.SZ+MF.WT+0.2))
		ms("FS_b"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, 2, MF.SZ+MF.WT+0.2))
		ms("FS_m"..i, Vector3.new(s.l,0.5,0.3), Vector3.new(cx, 10, MF.SZ+MF.WT+0.2))
		local bw = mw("BackWall_"..i, Vector3.new(s.l, MF.WH, MF.WT), Vector3.new(cx, MF.WY, -MF.SZ-MF.WT/2))
		at(bw, Enum.NormalId.Front) at(bw, Enum.NormalId.Back)
		ms("BS_t"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, 20, -MF.SZ-MF.WT-0.2))
		ms("BS_b"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, 2, -MF.SZ-MF.WT-0.2))
		ms("BS_m"..i, Vector3.new(s.l,0.5,0.3), Vector3.new(cx, 10, -MF.SZ-MF.WT-0.2))
	end
	mw("LeftWall", Vector3.new(MF.WT, MF.WH, MF.SZ*2+MF.WT*2+2), Vector3.new(sx-MF.WT/2, MF.WY, 0))
	mw("RightWall", Vector3.new(MF.WT, MF.WH, MF.SZ*2+MF.WT*2+2), Vector3.new(ex+MF.WT/2, MF.WY, 0))
	M._wallZ_front = MF.SZ - 3 M._wallZ_back = -MF.SZ + 3
end

function M.mapFixCollision(map, si)
	for _, p in pairs(getFloorParts(map, si)) do
		if M._isGod then pcall(function() p.CanCollide = false p.Transparency = 1 end) else pcall(function() p.CanCollide = true p.Transparency = 0 end) end
	end
	for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") and c.Name == "BridgeFloor" then if M._isGod then pcall(function() c.CanCollide = false c.Transparency = 1 end) else pcall(function() c.CanCollide = true end) end end end
	local mf = map:FindFirstChild("MzDHubWalls") if mf then for _, w in pairs(mf:GetChildren()) do if w:IsA("BasePart") then if w.Name:find("FS_") or w.Name:find("BS_") then w.CanCollide = false else w.CanCollide = true w.Anchored = true end end end end
end

M._lastFixedMapName = ""

function M.mapRunFix()
	local map = M.mapFindCurrentMap() if not map then return end
	local si = M.mapFindShared(map.Name) local mapChanged = map.Name ~= M._lastFixedMapName
	if mapChanged then M._lastFixedMapName = map.Name M.lastMapName = map.Name end
	local sx, ex = M.mapDetectXRange(map, si)
	if mapChanged then
		pcall(function() M.mapCleanup(map) end) pcall(function() M.mapCleanupShared(si) end)
		pcall(function() M.mapCleanupMisc() end) pcall(function() M.cleanupEventMaps() end)
		task.wait(0.1)
		pcall(function() M.mapWidenFloors(map, si) end)
		pcall(function() M.mapFillGaps(map, sx, ex) end)
		pcall(function() M.mapBuildWalls(map, sx, ex) end)
		M.Status.mapFixer = "Gefixed: " .. map.Name
		if M.S.DoomTowerEnabled then task.wait(0.5) M.enableTowerDrop() end
		-- Recolor god parts voor nieuwe map
		if M._isGod then recolorGodParts() end
	end
	pcall(function() M.mapFixCollision(map, si) end)
end

function M.startMapFixer()
	if M.mapFixerThread then return end M.S.MapFixerEnabled = true M._lastFixedMapName = ""
	pcall(function() M.mapRunFix() end)
	M.mapFixerThread = task.spawn(function()
		while M.S.MapFixerEnabled do pcall(function() M.mapRunFix() end) M.Status.mapFixer = "Actief" task.wait(MF.INT) end
		M.Status.mapFixer = "Uit" M.mapFixerThread = nil
	end)
end
function M.stopMapFixer() M.S.MapFixerEnabled = false if M.mapFixerThread then pcall(task.cancel, M.mapFixerThread) M.mapFixerThread = nil end M.Status.mapFixer = "Uit" end

print("[MzD Hub] Core v12.3 Geladen")

-- ============================================
-- GUI
-- ============================================
task.wait(0.5)
pcall(function() for _, gui in pairs(Player.PlayerGui:GetChildren()) do if gui:IsA("ScreenGui") then for _, d in pairs(gui:GetDescendants()) do if d:IsA("TextLabel") and d.Text == "MzD Hub" then gui:Destroy() break end end end end end) task.wait(0.3)

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local RAR = M.getAvailableRarities()
local MUT = M.getAvailableMutations()
local FM={"Collect","Collect, Place & Max"}
local FR = RAR
local LBR={"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity","Admin","UFO","Candy","Money"}
local SL={} for i=1,40 do table.insert(SL,tostring(i)) end
local SPD={"200","400","600","800","1000","1500","2000","3000","4000","INSTANT"}
local SPM={["200"]=200,["400"]=400,["600"]=600,["800"]=800,["1000"]=1000,["1500"]=1500,["2000"]=2000,["3000"]=3000,["4000"]=4000,["INSTANT"]=9999}
local CSPD={"100","200","300","400","500","600","800","1000","1500","2000"}
local GODWALKY={"0","-1","-2","-3","-5","-8","-10","-15"}
local GODFLOORY={"-3","-5","-8","-10","-15","-20"}
local TOWEROFFSET = {"-5","-3","-2","-1","0","1","2","3","5"}
local VALSPEED = {"100","200","300","400","500","800","1000","INSTANT"}
local VALSPM = {["100"]=100,["200"]=200,["300"]=300,["400"]=400,["500"]=500,["800"]=800,["1000"]=1000,["INSTANT"]=9999}
local COLORSCHEMES = {"Auto","Default","Doom","Valentine","Ocean","Emerald","Void","Blood","White"}

local W = Fluent:CreateWindow({Title="MzD Hub",SubTitle="v12.3",TabWidth=160,Size=UDim2.fromOffset(620,520),Acrylic=true,Theme="Dark",MinimizeKey=Enum.KeyCode.RightControl})

-- ========== FARM TAB ==========
local FT=W:AddTab({Title="Farm",Icon="swords"})
FT:AddParagraph({Title="ðŸŒ¾ Filters",Content=""})
local BDD=nil
local RDD=FT:AddDropdown("FarmRarity",{Title="Rarity",Values=RAR,Default={"Common"},Multi=true})
RDD:OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end if #s==0 then s={"Common"} end local any=false for _,r in pairs(s) do if r=="Any" then any=true break end end M.S.TargetRarity=any and "Any" or s M.S.SelectedBrainrots={} pcall(function() BDD:SetValues(M.getBrainrotNamesMulti(M.S.TargetRarity)) BDD:SetValue({}) end) end)
BDD=FT:AddDropdown("FarmBrainrots",{Title="Brainrots",Description="Leeg=alle",Values=M.getBrainrotNamesMulti(M.S.TargetRarity),Default={},Multi=true})
BDD:OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end M.S.SelectedBrainrots=s end)
FT:AddDropdown("FarmMutation",{Title="Mutatie",Values=MUT,Default="None",Multi=false}):OnChanged(function(v) M.S.TargetMutation=v end)
FT:AddDropdown("FarmMode",{Title="Mode",Values=FM,Default=M.S.FarmMode,Multi=false}):OnChanged(function(v) M.S.FarmMode=v end)
FT:AddDropdown("FarmSlot",{Title="Slot",Values=SL,Default=M.S.FarmSlot,Multi=false}):OnChanged(function(v) M.S.FarmSlot=v end)
FT:AddSlider("FarmMaxLevel",{Title="Max Level",Default=M.S.MaxLevel,Min=1,Max=500,Rounding=0}):OnChanged(function(v) M.S.MaxLevel=math.floor(v) end)
local FSP=FT:AddParagraph({Title="Status",Content="Idle"})
local FPP=FT:AddParagraph({Title="Stats",Content="P:0|U:0"})
local FTG=FT:AddToggle("FarmToggle",{Title="ðŸš€ Auto Farm",Default=false}) FTG:OnChanged(function(v) if v then M.findBase() M.startFarming() else M.stopFarming() end end)

FT:AddParagraph({Title="ðŸŽ² Lucky Blocks",Content=""})
FT:AddDropdown("LBRarity",{Title="Rarity",Values=LBR,Default={"Common"},Multi=true}):OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end if #s==0 then s={"Common"} end M.S.LuckyBlockRarity=s end)
FT:AddDropdown("LBMutation",{Title="Mutatie",Values=MUT,Default="Any",Multi=false}):OnChanged(function(v) M.S.LuckyBlockMutation=v end)
local LBSP=FT:AddParagraph({Title="LB Status",Content="Idle"})
local LBTG=FT:AddToggle("LBToggle",{Title="ðŸŽ² Auto LB",Default=false}) LBTG:OnChanged(function(v) if v then M.findBase() M.startLuckyBlockFarm() else M.stopLuckyBlockFarm() end end)

-- ========== FACTORY TAB ==========
local FCT=W:AddTab({Title="Factory",Icon="hammer"})
FCT:AddDropdown("FactoryRarity",{Title="Rarity",Values=FR,Default=M.S.FactoryRarity,Multi=false}):OnChanged(function(v) M.S.FactoryRarity=v end)
FCT:AddDropdown("FactoryMutation",{Title="Mutatie",Values=MUT,Default=M.S.FactoryMutation,Multi=false}):OnChanged(function(v) M.S.FactoryMutation=v end)
FCT:AddDropdown("FactorySlot",{Title="Slot",Values=SL,Default=M.S.FactorySlot,Multi=false}):OnChanged(function(v) M.S.FactorySlot=v end)
FCT:AddSlider("FactoryMaxLevel",{Title="Max Level",Default=M.S.FactoryMaxLevel,Min=1,Max=500,Rounding=0}):OnChanged(function(v) M.S.FactoryMaxLevel=math.floor(v) end)
local FCSP=FCT:AddParagraph({Title="Status",Content="Idle"})
local FCTG=FCT:AddToggle("FactoryToggle",{Title="ðŸ” Factory",Default=false}) FCTG:OnChanged(function(v) if v then M.findBase() M.startFactoryLoop() else M.stopFactoryLoop() end end)

-- ========== EVENTS TAB ==========
local ET=W:AddTab({Title="Events",Icon="party-popper"})

ET:AddParagraph({Title="ðŸ”¥ Doom Event",Content=""})
local DMSP=ET:AddParagraph({Title="ðŸª™ Doom Coins",Content="Uit"})
local DMTG=ET:AddToggle("DoomToggle",{Title="ðŸª™ Doom Coins",Default=false})
DMTG:OnChanged(function(v) if v then M.startDoomCollector() else M.stopDoomCollector() end end)

ET:AddDropdown("TowerOffset",{Title="Tower Offset",Values=TOWEROFFSET,Default="0",Multi=false}):OnChanged(function(v)
	M.S.DoomTowerOffset = tonumber(v) or 0
	if M.S.DoomTowerEnabled and M._towerDetectedFloorY then moveTowerToFloor(M._towerDetectedFloorY, M.S.DoomTowerOffset) end
end)
local DTSP=ET:AddParagraph({Title="ðŸ—¼ Tower",Content="Uit"})
local DTTG=ET:AddToggle("DoomTowerToggle",{Title="ðŸ—¼ Tower â†’ Vloer",Default=false})
DTTG:OnChanged(function(v) if v then M.enableTowerDrop() else M.disableTowerDrop() end end)

ET:AddButton({Title="âš¡ Doom Alles Aan",Callback=function()
	if not M.S.DoomTowerEnabled then M.enableTowerDrop() pcall(function() DTTG:SetValue(true) end) end
	if not M.S.DoomEnabled then M.startDoomCollector() pcall(function() DMTG:SetValue(true) end) end
end})
ET:AddButton({Title="â¹ Doom Alles Uit",Callback=function()
	if M.S.DoomEnabled then M.stopDoomCollector() pcall(function() DMTG:SetValue(false) end) end
	if M.S.DoomTowerEnabled then M.disableTowerDrop() pcall(function() DTTG:SetValue(false) end) end
end})

-- Valentine v2
ET:AddParagraph({Title="ðŸ’ Valentine v2",Content="Rent naar brainrots, submit bij 100"})
ET:AddDropdown("ValSpeed",{Title="Valentine Speed",Values=VALSPEED,Default="300",Multi=false}):OnChanged(function(v) M.S.ValentineSpeed = VALSPM[v] or 300 end)
local VSP=ET:AddParagraph({Title="ðŸ’ Status",Content="Idle"})
local VTG=ET:AddToggle("ValentineToggle",{Title="ðŸ’ Valentine Farm",Default=false}) VTG:OnChanged(function(v) if v then M.startValentine() else M.stopValentine() end end)
ET:AddButton({Title="ðŸ’ Find Station",Callback=function() local s = M.findValentineStation() Fluent:Notify({Title="Station",Content=s and (s.Name .. "\n" .. tostring(M._valentineStationCF and M._valentineStationCF.Position)) or "Niet gevonden!",Duration=5}) end})
ET:AddButton({Title="ðŸ’ Submit Nu",Callback=function() Fluent:Notify({Title="Submit",Content=M.submitAtStation() and "âœ“" or "âœ—",Duration=3}) end})
ET:AddButton({Title="ðŸ’ Brainrot Info",Callback=function()
	local b = M.findValentineBrainrots() local info = "Op map: " .. #b
	local byR = {} for _, t in pairs(b) do byR[t.rarity] = (byR[t.rarity] or 0) + 1 end
	for r, c in pairs(byR) do info = info .. "\n  " .. r .. ": " .. c end
	info = info .. "\nHearts: " .. M.getHeartCount()
	Fluent:Notify({Title="Valentine",Content=info,Duration=6})
end})

local ASP=ET:AddParagraph({Title="ðŸ•¹ï¸ Arcade",Content="Idle"})
local ATG=ET:AddToggle("ArcadeToggle",{Title="ðŸ•¹ï¸ Arcade",Default=false}) ATG:OnChanged(function(v) if v then M.startArcade() else M.stopArcade() end end)

-- ========== AUTO TAB ==========
local AT2=W:AddTab({Title="Auto",Icon="rocket"})
local MSP=AT2:AddParagraph({Title="ðŸ’° Money",Content="Idle"})
local MTG=AT2:AddToggle("MoneyToggle",{Title="ðŸ’° Money",Default=false}) MTG:OnChanged(function(v) if v then M.findBase() M.startMoney() else M.stopMoney() end end)
local USP=AT2:AddParagraph({Title="â¬†ï¸ Upgrade",Content="Idle"})
local UTG=AT2:AddToggle("UpgradeToggle",{Title="â¬†ï¸ Upgrade All",Default=false}) UTG:OnChanged(function(v) if v then M.findBase() M.startAutoUpgrade() else M.stopAutoUpgrade() end end)
local MFSP=AT2:AddParagraph({Title="ðŸ—ºï¸ Map Fixer",Content="Uit"})
local MFTG=AT2:AddToggle("MapToggle",{Title="ðŸ—ºï¸ Map Fixer",Default=false}) MFTG:OnChanged(function(v) if v then M.startMapFixer() else M.stopMapFixer() end end)
AT2:AddButton({Title="ðŸ—ºï¸ Fix 1x",Callback=function() M._lastFixedMapName="" pcall(function() M.mapRunFix() end) end})

AT2:AddParagraph({Title="ðŸ›¡ï¸ God Mode",Content=""})
AT2:AddDropdown("GodWalkY",{Title="Loop Y",Values=GODWALKY,Default="-2",Multi=false}):OnChanged(function(v) M.S.GodWalkY=tonumber(v) or -2 if M._isGod then godTeleportUnder() end end)
AT2:AddDropdown("GodFloorY",{Title="Vloer Y",Values=GODFLOORY,Default="-5",Multi=false}):OnChanged(function(v) M.S.GodFloorY=tonumber(v) or -5 end)
local GDSP=AT2:AddParagraph({Title="God Status",Content="Uit"})
local GDTG=AT2:AddToggle("GodToggle",{Title="ðŸ›¡ï¸ God Mode",Default=false})
GDTG:OnChanged(function(v) if v then M.enableGod() else M.disableGod() end end)
AT2:AddButton({Title="ðŸ“ Teleport Onder",Callback=function() if M._isGod then godTeleportUnder() end end})

-- Color Scheme
AT2:AddParagraph({Title="ðŸŽ¨ Kleurschema",Content="Auto detecteert map type\nDoom=paars/rood, Valentine=donkerrood/roze"})
local CSSP=AT2:AddParagraph({Title="Huidig Schema",Content="Auto"})
AT2:AddDropdown("ColorScheme",{Title="Schema",Values=COLORSCHEMES,Default="Auto",Multi=false}):OnChanged(function(v)
	M.S.ColorScheme = v
	if M._isGod then
		recolorGodParts()
		-- Rebuild walls met nieuw schema
		M._lastFixedMapName = ""
		pcall(function() M.mapRunFix() end)
	end
	local scheme, detected = getActiveColorScheme()
	CSSP:SetDesc(scheme.name .. (v == "Auto" and " (auto: " .. detected .. ")" or ""))
end)
AT2:AddButton({Title="ðŸŽ¨ Preview Kleuren",Callback=function()
	local scheme, detected = getActiveColorScheme()
	local info = "Schema: " .. scheme.name
	if M.S.ColorScheme == "Auto" then info = info .. " (detected: " .. detected .. ")" end
	info = info .. "\nVloer: " .. tostring(scheme.floor)
	info = info .. "\nStripe: " .. tostring(scheme.stripe)
	info = info .. "\nMuur: " .. tostring(scheme.wall)
	info = info .. "\nTekst: " .. tostring(scheme.wallText)
	Fluent:Notify({Title="ðŸŽ¨ Kleurschema",Content=info,Duration=6})
end})
AT2:AddButton({Title="ðŸŽ¨ Forceer Recolor",Callback=function()
	if M._isGod then recolorGodParts() end
	M._lastFixedMapName = "" pcall(function() M.mapRunFix() end)
	Fluent:Notify({Title="Recolor",Content="Kleuren bijgewerkt!",Duration=3})
end})

AT2:AddToggle("InstantToggle",{Title="âš¡ Instant Pickup",Default=true}):OnChanged(function(v) M.S.InstantPickup=v if v then M.setupInstant() end end)
local AFKSP=AT2:AddParagraph({Title="AFK",Content="Uit"})
local AFKTG=AT2:AddToggle("AFKToggle",{Title="ðŸ›¡ï¸ Anti-AFK",Default=false}) AFKTG:OnChanged(function(v) if v then M.startAFK() else M.stopAFK() end end)

-- ========== CONFIG TAB ==========
local CT=W:AddTab({Title="Config",Icon="settings"})
CT:AddDropdown("TweenSpeed",{Title="Speed",Values=SPD,Default="INSTANT",Multi=false}):OnChanged(function(v) M.S.TweenSpeed=SPM[v] or 9999 end)
CT:AddDropdown("CorridorSpeed",{Title="Corridor",Values=CSPD,Default="1500",Multi=false}):OnChanged(function(v) M.S.CorridorSpeed=tonumber(v) or 1500 end)
CT:AddButton({Title="ðŸ”„ Herlaad Brainrots",Callback=function() M.S.SelectedBrainrots={} pcall(function() BDD:SetValues(M.getBrainrotNamesMulti(M.S.TargetRarity)) BDD:SetValue({}) end) end})
CT:AddButton({Title="ðŸ  Zoek Base",Callback=function() M.findBase() Fluent:Notify({Title="Base",Content=M.baseGUID or "?",Duration=3}) end})
CT:AddButton({Title="ðŸ“ Home Op",Callback=function() M.setHomePosition() end})
CT:AddButton({Title="ðŸ“‹ Slots",Callback=function() M.findBase() local o=M.findOccupiedSlots() local i="" for _,s in pairs(o) do i=i.."S"..s.slot..":"..s.name.." L"..s.level.."\n" end Fluent:Notify({Title="Slots("..#o..")",Content=#o>0 and i or "Leeg!",Duration=8}) end})
CT:AddButton({Title="ðŸ—‘ï¸ Leeg Slot",Callback=function() M.findBase() M.clearSlot(tonumber(M.S.FarmSlot) or 5) end})
CT:AddButton({Title="ðŸ  Ga Base",Callback=function() M.findBase() M.returnToBase() end})
CT:AddButton({Title="ðŸ›¡ï¸ Debug",Callback=function()
	local scheme, det = getActiveColorScheme()
	local i="God:".. (M._isGod and "AAN" or "UIT").."\nSchema:"..scheme.name.." ("..det..")"
	i=i.."\nWalk:"..M.S.GodWalkY.." Floor:"..M.S.GodFloorY
	i=i.."\nGod parts:"..#M._godCreatedParts.." Kill:"..#M._godKillParts
	i=i.."\nDoom:"..(M.S.DoomEnabled and "AAN" or "UIT").." Parts:"..#M._doomCachedParts
	i=i.."\nTower:"..(M._towerMoved and "Moved" or "Off")
	local hrp=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if hrp then i=i.."\nY:"..string.format("%.1f",hrp.Position.Y) end
	i=i.."\nHearts:"..M.getHeartCount()
	Fluent:Notify({Title="Debug v12.3",Content=i,Duration=12}) end})
local IP=CT:AddParagraph({Title="Info",Content="..."})

-- ========== SETTINGS TAB ==========
local ST2=W:AddTab({Title="Settings",Icon="shield"})
SaveManager:SetLibrary(Fluent) InterfaceManager:SetLibrary(Fluent) SaveManager:SetFolder("MzDHub") InterfaceManager:SetFolder("MzDHub")
InterfaceManager:BuildInterfaceSection(ST2) SaveManager:BuildConfigSection(ST2)

-- ========== STATUS UPDATER ==========
task.spawn(function() while task.wait(1) do pcall(function()
	FSP:SetDesc((M.S.Farming and M.Status.farm or "Idle").." | #"..M.Status.farmCount) FPP:SetDesc("P:"..M.Status.placeCount.." U:"..M.Status.upgradeCount)
	if not M.S.Farming then pcall(function() if FTG.Value then FTG:SetValue(false) end end) end
	LBSP:SetDesc((M.S.LuckyBlockEnabled and M.Status.luckyBlock or "Idle").." #"..M.Status.luckyBlockCount)
	if not M.S.LuckyBlockEnabled then pcall(function() if LBTG.Value then LBTG:SetValue(false) end end) end
	FCSP:SetDesc((M.Status.factory or "Idle").." #"..M.Status.factoryCount) if not M.S.FactoryEnabled then pcall(function() if FCTG.Value then FCTG:SetValue(false) end end) end
	if M.S.DoomEnabled then local f = workspace:FindFirstChild("DoomEventParts") DMSP:SetDesc("AAN âœ“ | P:" .. #M._doomCachedParts .. " | F:" .. (f and #f:GetChildren() or 0))
	else DMSP:SetDesc("Uit") end
	if not M.S.DoomEnabled then pcall(function() if DMTG.Value then DMTG:SetValue(false) end end) end
	if M.S.DoomTowerEnabled then local tY = getTowerY() local bY = getTowerBottomY() DTSP:SetDesc("AAN | Y:" .. (tY and string.format("%.0f", tY) or "?") .. " Bot:" .. (bY and string.format("%.0f", bY) or "?") .. " Off:" .. M.S.DoomTowerOffset)
	else DTSP:SetDesc("Uit") end
	if not M.S.DoomTowerEnabled then pcall(function() if DTTG.Value then DTTG:SetValue(false) end end) end
	if M.S.ValentineEnabled then local h = M.getHeartCount() local bc = 0 pcall(function() bc = #M.findValentineBrainrots() end)
		VSP:SetDesc(M.Status.valentine .. " | H:" .. h .. "/100 | BR:" .. bc .. " | #" .. M.Status.valentineCount)
	else VSP:SetDesc("Idle") end
	if not M.S.ValentineEnabled then pcall(function() if VTG.Value then VTG:SetValue(false) end end) end
	ASP:SetDesc(M.S.ArcadeEnabled and ("Actief #"..M.Status.arcadeCount) or "Idle")
	if not M.S.ArcadeEnabled then pcall(function() if ATG.Value then ATG:SetValue(false) end end) end
	MSP:SetDesc(M.S.AutoCollectMoney and "Actief" or "Idle")
	if not M.S.AutoCollectMoney then pcall(function() if MTG.Value then MTG:SetValue(false) end end) end
	USP:SetDesc((M.S.AutoUpgrade and M.upgradeThread and M.Status.upgrade or "Idle").." #"..M.Status.upgradeCount)
	if not(M.S.AutoUpgrade and M.upgradeThread) then pcall(function() if UTG.Value then UTG:SetValue(false) end end) end
	MFSP:SetDesc(M.S.MapFixerEnabled and M.Status.mapFixer or "Uit")
	if not M.S.MapFixerEnabled then pcall(function() if MFTG.Value then MFTG:SetValue(false) end end) end
	AFKSP:SetDesc("AFK:"..M.Status.afk)
	if not M.S.AntiAFK then pcall(function() if AFKTG.Value then AFKTG:SetValue(false) end end) end
	local scheme, det = getActiveColorScheme()
	GDSP:SetDesc(M.Status.god .. (M._isGod and " ðŸŽ¨" .. scheme.name or "")) if not M._isGod then pcall(function() if GDTG.Value then GDTG:SetValue(false) end end) end
	CSSP:SetDesc(scheme.name .. (M.S.ColorScheme == "Auto" and " (auto: " .. det .. ")" or ""))
	local hrp=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") local curY=hrp and string.format("%.1f",hrp.Position.Y) or "?"
	IP:SetDesc("Player:"..Player.Name.."\nBase:"..(M.baseGUID or "?").."\nðŸŽ¨ "..scheme.name.." | God:"..(M._isGod and "AAN" or "UIT").."\nY:"..curY.." H:"..M.getHeartCount())
end) end end)

task.spawn(function() task.wait(1) M.findBase() task.wait(0.5) M.detectWallZ()
	local scheme, det = getActiveColorScheme()
	Fluent:Notify({Title="MzD Hub v12.3",Content="ðŸŽ¨ Adaptive Colors: " .. scheme.name .. " (" .. det .. ")\nðŸ’ Valentine v2: rent naar brainrots\nðŸ”¥ Doom Event support\n8 kleurschema's beschikbaar",Duration=8})
end)

W:SelectTab(1)
print("[MzD Hub] v12.3 GELADEN âœ“")
print("[MzD Hub] Schema: " .. (getActiveColorScheme()).name)
print("[MzD Hub] Schemas: " .. table.concat(COLORSCHEMES, ", "))
