-- ============================================
-- loadstring(game:HttpGet("https://raw.githubusercontent.com/mzdtools/EBFT/main/Escape"))()
-- ============================================
-- MzD Hub v11.2 - VOLLEDIG GEOPTIMALISEERD
-- God Mode v22: Size.H bug fix + muren tot onder vloer
-- FPS fix: caching + minder frequente loops
-- ============================================
getgenv().MzD = {}
local M = getgenv().MzD

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Player = Players.LocalPlayer

-- ========== INIT ==========
M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots")
if not M.ActiveBrainrots then
	task.spawn(function() M.ActiveBrainrots = workspace:WaitForChild("ActiveBrainrots", 15) end)
end

M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks")
if not M.ActiveLuckyBlocks then
	task.spawn(function() M.ActiveLuckyBlocks = workspace:WaitForChild("ActiveLuckyBlocks", 15) end)
end

M.PlotAction = nil
pcall(function()
	M.PlotAction = game:GetService("ReplicatedStorage")
		:WaitForChild("Packages", 10)
		:WaitForChild("Net", 10)
		:WaitForChild("RF/Plot.PlotAction", 10)
end)

-- ========== SETTINGS ==========
M.S = {
	Farming = false,
	SelectedBrainrots = {},
	TargetMutation = "None",
	TargetRarity = {"Common"},
	TweenSpeed = 9999,
	CorridorSpeed = 1500,
	AutoCollectMoney = false,
	InstantPickup = true,
	AntiAFK = false,
	AutoUpgrade = false,
	MaxLevel = 250,
	FactoryEnabled = false,
	FactorySlot = "5",
	FactoryRarity = "Common",
	FactoryMutation = "None",
	FactoryMaxLevel = 250,
	FarmMode = "Collect, Place & Max",
	FarmSlot = "5",
	ValentineEnabled = false,
	ArcadeEnabled = false,
	MapFixerEnabled = false,
	LuckyBlockEnabled = false,
	LuckyBlockRarity = {"Common"},
	LuckyBlockMutation = "Any",
	GodEnabled = false,
	GodWalkY = -2,
	GodFloorY = -5,
}

M.Status = {
	farm = "Idle", farmCount = 0,
	money = "Idle",
	afk = "Uit",
	placeCount = 0, upgradeCount = 0,
	upgrade = "Idle",
	factory = "Idle", factoryCount = 0,
	valentine = "Idle", valentineCount = 0,
	arcade = "Idle", arcadeCount = 0,
	mapFixer = "Uit",
	luckyBlock = "Idle", luckyBlockCount = 0,
	god = "Uit",
}

-- ========== STATE ==========
M.baseGUID = nil
M.baseCFrame = nil
M.homePosition = nil
M.farmThread = nil
M.factoryThread = nil
M.moneyThread = nil
M.moneyRemoteThread = nil
M.afkThread = nil
M._afkSteppedConn = nil
M._instantConn = nil
M.upgradeThread = nil
M.valentineThread = nil
M.valentineCollectorConn = nil
M.valentineTurboThread = nil
M.valentineNoclipConn = nil
M._valentineDescAddedConn = nil
M.arcadeThread = nil
M.mapFixerThread = nil
M.lastMapName = ""
M._valentineCachedParts = {}
M._valentineLastCacheScan = 0
M._valentineFoundRemotes = {}
M._valentineDebugLog = {}
M.luckyBlockThread = nil

-- God Mode v22 state
M._isGod = false
M._godLoopThread = nil
M._godHealthConn = nil
M._godDiedConn = nil
M._godOriginalFloors = {}
M._godCreatedParts = {}
M._godKillParts = {}
M._godKillWatchThread = nil
M._godFloorCacheTime = 0

M._wallZ_front = 173
M._wallZ_back = -173

local HIGH_RARITIES = {["Celestial"] = true, ["Divine"] = true, ["Infinity"] = true}

-- ============================================
-- HELPER: Is dit een MzD eigen part?
-- ============================================
local function isMzDPart(obj)
	if not obj or not obj:IsA("BasePart") then return false end
	local n = obj.Name
	if n == "MzDGodFloor" or n == "MzDGodCatchFloor" or n == "MzDGodFloorStripe" then return true end
	local p = obj.Parent
	while p do
		if p.Name == "MzDHubWalls" or p.Name == "MzDGodPreview" then return true end
		p = p.Parent
	end
	return false
end

-- ============================================
-- GOD MODE v22 - SIZE.H BUG FIX
-- ============================================

local function godFindFloorParts()
	local floors = {}
	local map = nil

	for _, c in pairs(workspace:GetChildren()) do
		if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
			if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or
				c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then
				map = c break
			end
		end
	end

	if not map then
		for _, c in pairs(workspace:GetChildren()) do
			if c:IsA("Model") and c.Name:find("Map") then
				local cnt = 0
				for _, d in pairs(c:GetDescendants()) do
					if d:IsA("BasePart") then cnt += 1 end
					if cnt > 10 then map = c break end
				end
				if map then break end
			end
		end
	end

	local function checkPart(p)
		if not p:IsA("BasePart") then return end
		if isMzDPart(p) then return end
		if p.Size.X > 15 and p.Size.Z > 5 and p.Size.Y < 20 then
			if p.Position.Y > -10 and p.Position.Y < 30 then
				table.insert(floors, p)
			end
		end
	end

	if map then
		for _, c in pairs(map:GetChildren()) do
			if c:IsA("BasePart") and not isMzDPart(c) then
				local n = c.Name:lower()
				if n == "firstfloor" or n == "ground" or n == "floor" or
					n == "grass" or n == "path" or n == "road" or n == "platform" or
					n == "bridgefloor" then
					table.insert(floors, c)
				else
					checkPart(c)
				end
			end
		end
		local sp = map:FindFirstChild("Spawners")
		if sp then for _, s in pairs(sp:GetChildren()) do checkPart(s) end end
	end

	for _, c in pairs(workspace:GetChildren()) do
		if c.Name:find("SharedInstances") then
			local fl = c:FindFirstChild("Floors")
			if fl then for _, f in pairs(fl:GetChildren()) do checkPart(f) end end
			for _, f in pairs(c:GetChildren()) do checkPart(f) end
		end
	end

	return floors, map
end

local function godDetectMapXRange(map)
	local minX, maxX = math.huge, -math.huge
	local found = false
	local function chk(p)
		if not p:IsA("BasePart") then return end
		if isMzDPart(p) then return end
		if p.Size.Y > p.Size.X and p.Size.Y > p.Size.Z then return end
		if p.Position.Y > 50 or p.Position.Y < -30 then return end
		if p.Size.X < 5 then return end
		local l = p.Position.X - p.Size.X / 2
		local r = p.Position.X + p.Size.X / 2
		if l < minX then minX = l end
		if r > maxX then maxX = r end
		found = true
	end
	if map then
		for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") then chk(c) end end
		local sp = map:FindFirstChild("Spawners")
		if sp then for _, s in pairs(sp:GetChildren()) do chk(s) end end
	end
	for _, c in pairs(workspace:GetChildren()) do
		if c.Name:find("SharedInstances") then
			for _, f in pairs(c:GetChildren()) do if f:IsA("BasePart") then chk(f) end end
			local fl = c:FindFirstChild("Floors") if fl then for _, f in pairs(fl:GetChildren()) do chk(f) end end
		end
	end
	if found and maxX > minX then return minX - 20, maxX + 20 end
	return -50, 4500
end

-- v22 FIX: c.Size.H â†’ c.Size.Y (H bestaat niet!)
local function godFindAllKillParts()
	local kills, seen = {}, {}
	for _, c in pairs(workspace:GetDescendants()) do
		if c:IsA("BasePart") and not seen[c] and not isMzDPart(c) then
			-- Detecteer dunne kill strips (Y < 1, Z > 50, X < 5)
			local ok, isKillStrip = pcall(function()
				return c.Size.Y < 1 and c.Size.Z > 50 and c.Position.Y < 5 and c.Position.Y > -5 and c.Size.X < 5
			end)
			if ok and isKillStrip and not seen[c] then
				seen[c] = true
				table.insert(kills, c)
			end
			-- Detecteer op naam
			if not seen[c] then
				local n = c.Name:lower()
				if n:find("kill") or n:find("tsunamikill") or n:find("deathzone") or
					n:find("damagezone") or n:find("killbrick") or n:find("killpart") then
					seen[c] = true
					table.insert(kills, c)
				end
			end
		end
	end
	return kills
end

local function godDisableKillParts()
	M._godKillParts = {}
	local kills = godFindAllKillParts()
	for _, p in pairs(kills) do
		table.insert(M._godKillParts, {
			part = p, canCollide = p.CanCollide, canTouch = p.CanTouch,
			size = p.Size, position = p.Position, transparency = p.Transparency,
		})
		pcall(function()
			p.CanCollide = false p.CanTouch = false p.Transparency = 1
			p.Size = Vector3.new(0, 0, 0) p.Position = Vector3.new(0, -9999, 0)
		end)
	end
	return #kills
end

local function godRestoreKillParts()
	for _, data in pairs(M._godKillParts) do
		pcall(function()
			if data.part and data.part.Parent then
				data.part.Size = data.size data.part.Position = data.position
				data.part.CanCollide = data.canCollide data.part.CanTouch = data.canTouch
				data.part.Transparency = data.transparency
			end
		end)
	end
	M._godKillParts = {}
end

local function godStartKillWatcher()
	if M._godKillWatchThread then pcall(task.cancel, M._godKillWatchThread) end
	M._godKillWatchThread = task.spawn(function()
		while M._isGod do
			pcall(function()
				-- Bestaande kill parts blijven uitgeschakeld
				for _, data in pairs(M._godKillParts) do
					if data.part and data.part.Parent then
						data.part.CanCollide = false data.part.CanTouch = false
						data.part.Size = Vector3.new(0, 0, 0) data.part.Position = Vector3.new(0, -9999, 0)
					end
				end
			end)
			-- Scan voor nieuwe kill parts
			pcall(function()
				for _, c in pairs(workspace:GetDescendants()) do
					if c:IsA("BasePart") and not isMzDPart(c) then
						local isKill = false
						pcall(function()
							if c.Size.Y < 1 and c.Size.Z > 50 and c.Position.Y < 5 and c.Position.Y > -5 and c.Size.X < 5 then
								isKill = true
							end
						end)
						if not isKill then
							local n = c.Name:lower()
							if n:find("kill") or n:find("deathzone") or n:find("damagezone") then isKill = true end
						end
						if isKill then
							local already = false
							for _, data in pairs(M._godKillParts) do if data.part == c then already = true break end end
							if not already then
								table.insert(M._godKillParts, {
									part = c, canCollide = c.CanCollide, canTouch = c.CanTouch,
									size = c.Size, position = c.Position, transparency = c.Transparency,
								})
								pcall(function()
									c.CanCollide = false c.CanTouch = false c.Transparency = 1
									c.Size = Vector3.new(0, 0, 0) c.Position = Vector3.new(0, -9999, 0)
								end)
							end
						end
					end
				end
			end)
			task.wait(3)
		end
	end)
end

local function godBuildEgaleVloer(map)
	-- Cleanup oude god parts
	for _, p in pairs(M._godCreatedParts) do
		pcall(function() if p and p.Parent then p:Destroy() end end)
	end
	M._godCreatedParts = {}

	local startX, endX = godDetectMapXRange(map)
	local floorY = M.S.GodFloorY
	local floorWidth = 400
	local floorThickness = 4
	local BLK = Color3.fromRGB(0, 0, 0)
	local GLD = Color3.fromRGB(255, 200, 50)

	print("[MzD God] Bouw vloer: X=" .. startX .. " tot " .. endX .. " Y=" .. floorY)

	local maxSeg = 2000
	local curX = startX
	local partCount = 0
	while curX < endX do
		local segLen = math.min(maxSeg, endX - curX)
		local centerX = curX + segLen / 2

		local floor = Instance.new("Part")
		floor.Name = "MzDGodFloor"
		floor.Size = Vector3.new(segLen, floorThickness, floorWidth)
		floor.Position = Vector3.new(centerX, floorY, 0)
		floor.Anchored = true floor.CanCollide = true
		floor.Color = BLK floor.Material = Enum.Material.SmoothPlastic
		floor.Transparency = 0
		floor.TopSurface = Enum.SurfaceType.Smooth floor.BottomSurface = Enum.SurfaceType.Smooth
		floor.Parent = workspace
		table.insert(M._godCreatedParts, floor)
		partCount += 1

		local topY = floorY + floorThickness / 2 + 0.1
		for _, zPos in pairs({floorWidth / 2 - 5, -floorWidth / 2 + 5}) do
			local s = Instance.new("Part")
			s.Name = "MzDGodFloorStripe" s.Size = Vector3.new(segLen, 0.2, 2)
			s.Position = Vector3.new(centerX, topY, zPos)
			s.Anchored = true s.CanCollide = false
			s.Color = GLD s.Material = Enum.Material.Neon
			s.Parent = workspace
			table.insert(M._godCreatedParts, s)
		end
		local sm = Instance.new("Part")
		sm.Name = "MzDGodFloorStripe" sm.Size = Vector3.new(segLen, 0.2, 1)
		sm.Position = Vector3.new(centerX, topY, 0)
		sm.Anchored = true sm.CanCollide = false
		sm.Color = GLD sm.Material = Enum.Material.Neon
		sm.Parent = workspace
		table.insert(M._godCreatedParts, sm)

		curX = curX + segLen
	end

	-- Catch floor
	local catch = Instance.new("Part")
	catch.Name = "MzDGodCatchFloor"
	catch.Size = Vector3.new(math.abs(endX - startX) + 200, 2, floorWidth + 100)
	catch.Position = Vector3.new((startX + endX) / 2, floorY - 15, 0)
	catch.Anchored = true catch.CanCollide = true catch.Transparency = 1
	catch.Parent = workspace
	table.insert(M._godCreatedParts, catch)

	print("[MzD God] Vloer gebouwd: " .. partCount .. " segments, " .. #M._godCreatedParts .. " parts totaal")
	return true
end

local function godHideOriginalFloors()
	local floors, map = godFindFloorParts()
	M._godOriginalFloors = {}

	print("[MzD God] Gevonden vloeren: " .. #floors .. " | Map: " .. (map and map.Name or "GEEN"))

	for _, p in pairs(floors) do
		table.insert(M._godOriginalFloors, {
			part = p, size = p.Size, position = p.Position,
			canCollide = p.CanCollide, transparency = p.Transparency,
			color = p.Color, material = p.Material, anchored = p.Anchored,
		})
		pcall(function() p.CanCollide = false p.Transparency = 1 end)
	end

	if map then
		for _, c in pairs(map:GetChildren()) do
			if c:IsA("BasePart") and c.Name == "BridgeFloor" and not isMzDPart(c) then
				table.insert(M._godOriginalFloors, {
					part = c, size = c.Size, position = c.Position,
					canCollide = c.CanCollide, transparency = c.Transparency,
					color = c.Color, material = c.Material, anchored = c.Anchored,
				})
				pcall(function() c.CanCollide = false c.Transparency = 1 end)
			end
		end
	end

	return map
end

local function godRestoreFloors()
	for _, data in pairs(M._godOriginalFloors) do
		pcall(function()
			if data.part and data.part.Parent then
				data.part.Size = data.size data.part.Position = data.position
				data.part.CanCollide = data.canCollide data.part.Transparency = data.transparency
				data.part.Color = data.color data.part.Material = data.material
				data.part.Anchored = data.anchored
			end
		end)
	end
	M._godOriginalFloors = {}
	for _, f in pairs(M._godCreatedParts) do
		pcall(function() if f and f.Parent then f:Destroy() end end)
	end
	M._godCreatedParts = {}
end

local function godTeleportUnder()
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	hrp.Velocity = Vector3.new(0, 0, 0)
	hrp.CFrame = CFrame.new(hrp.Position.X, M.S.GodWalkY, hrp.Position.Z)
end

local function godStartLoop()
	if M._godLoopThread then pcall(task.cancel, M._godLoopThread) end
	M._godLoopThread = task.spawn(function()
		while M._isGod do
			pcall(function()
				local ch = Player.Character
				if not ch then return end
				local hrp = ch:FindFirstChild("HumanoidRootPart")

				-- Vloeren cache: elke 5 seconden
				if tick() - M._godFloorCacheTime > 5 then
					for _, data in pairs(M._godOriginalFloors) do
						if data.part and data.part.Parent then
							data.part.CanCollide = false
							data.part.Transparency = 1
						end
					end
					M._godFloorCacheTime = tick()
				end

				-- Y-positie bewaken
				if hrp then
					local curY = hrp.Position.Y
					local targetY = M.S.GodWalkY
					if curY < targetY - 30 then
						hrp.Velocity = Vector3.new(0, 0, 0)
						hrp.CFrame = CFrame.new(hrp.Position.X, targetY, hrp.Position.Z)
					end
				end
			end)
			task.wait(0.5)
		end
	end)
end

local function godSetupHealth(char)
	if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) end
	if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) end

	local hum = char:WaitForChild("Humanoid", 5)
	if not hum then return end

	pcall(function()
		hum.MaxHealth = math.huge hum.Health = math.huge
		hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	end)

	for _, ff in pairs(char:GetChildren()) do if ff:IsA("ForceField") then ff:Destroy() end end
	local ff = Instance.new("ForceField") ff.Visible = false ff.Parent = char

	M._godHealthConn = hum:GetPropertyChangedSignal("Health"):Connect(function()
		if not M._isGod then return end
		pcall(function() if hum.Health ~= math.huge then hum.Health = math.huge end end)
	end)

	M._godDiedConn = hum.Died:Connect(function()
		if not M._isGod then return end
		task.defer(function()
			pcall(function()
				hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
				hum:ChangeState(Enum.HumanoidStateType.GettingUp)
				hum.MaxHealth = math.huge hum.Health = math.huge
			end)
		end)
	end)
end

function M.enableGod()
	if M._isGod then return end
	M._isGod = true
	M.S.GodEnabled = true
	M.Status.god = "Starten..."
	M._godFloorCacheTime = 0

	print("[MzD God] Starten...")

	-- Stap 1: Kill parts
	local killCount = godDisableKillParts()
	godStartKillWatcher()
	print("[MzD God] Kill parts: " .. killCount)
	task.wait(0.1)

	-- Stap 2: Verberg originele vloeren
	local map = godHideOriginalFloors()
	print("[MzD God] Vloeren verborgen: " .. #M._godOriginalFloors)
	task.wait(0.1)

	-- Stap 3: Bouw god vloer
	local buildOk = godBuildEgaleVloer(map)
	print("[MzD God] Vloer gebouwd: " .. tostring(buildOk) .. " | Parts: " .. #M._godCreatedParts)
	task.wait(0.2)

	-- Stap 4: Start loop
	godStartLoop()
	task.wait(0.1)

	-- Stap 5: Teleport
	godTeleportUnder()
	task.wait(0.1)

	-- Stap 6: Health
	if Player.Character then godSetupHealth(Player.Character) end

	M.Status.god = "Aan ðŸ›¡ï¸ (Y=" .. M.S.GodWalkY .. " | Kill:" .. killCount .. " | Vloer:" .. #M._godCreatedParts .. ")"
	print("[MzD God] ACTIEF âœ“")
end

function M.disableGod()
	M._isGod = false
	M.S.GodEnabled = false

	if M._godLoopThread then pcall(task.cancel, M._godLoopThread) M._godLoopThread = nil end
	if M._godKillWatchThread then pcall(task.cancel, M._godKillWatchThread) M._godKillWatchThread = nil end
	if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) M._godHealthConn = nil end
	if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) M._godDiedConn = nil end

	godRestoreFloors()
	godRestoreKillParts()

	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		hrp.Velocity = Vector3.new(0, 0, 0)
		hrp.CFrame = CFrame.new(hrp.Position.X, 10, hrp.Position.Z)
	end

	local ch = Player.Character
	if ch then
		for _, ff2 in pairs(ch:GetChildren()) do if ff2:IsA("ForceField") then ff2:Destroy() end end
		local hum = ch:FindFirstChild("Humanoid")
		if hum then
			pcall(function()
				hum.MaxHealth = 100 hum.Health = 100
				hum:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
			end)
		end
	end

	M.Status.god = "Uit"
	print("[MzD God] Uitgeschakeld")
end

-- ========== EQUIP ==========
function M.safeEquip(tool)
	if not tool then return end
	local ch = Player.Character if not ch then return end
	local hum = ch:FindFirstChild("Humanoid") if not hum then return end
	pcall(function() hum:EquipTool(tool) end) task.wait(0.4)
end

function M.safeUnequip()
	local ch = Player.Character if not ch then return end
	local hum = ch:FindFirstChild("Humanoid") if not hum then return end
	pcall(function() hum:UnequipTools() end) task.wait(0.2)
end

-- ========== MAP HELPERS ==========
function M.mapFindCurrentMap()
	local best, bc = nil, 0
	for _, c in pairs(workspace:GetChildren()) do
		if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
			if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or c:FindFirstChild("RightWalls") or
				c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then return c end
			local cnt = 0
			for _, d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then cnt += 1 end if cnt > 10 then return c end end
			if cnt > bc then bc = cnt best = c end
		end
	end
	return best
end

function M.detectWallZ()
	local map = M.mapFindCurrentMap() if not map then return end
	local mzwalls = map:FindFirstChild("MzDHubWalls") if not mzwalls then return end
	local fw = mzwalls:FindFirstChild("FrontWall_1")
	local bw = mzwalls:FindFirstChild("BackWall_1")
	if fw then M._wallZ_front = fw.Position.Z - fw.Size.Z / 2 - 3 end
	if bw then M._wallZ_back = bw.Position.Z + bw.Size.Z / 2 + 3 end
end

function M.getCorridorZ()
	M.detectWallZ()
	local homePos = M.getHomePosition().Position
	if homePos.Z >= 0 then return M._wallZ_front else return M._wallZ_back end
end

-- ========== BASE ==========
function M.findBase()
	local bases = workspace:FindFirstChild("Bases") if not bases then return end
	for _, base in pairs(bases:GetChildren()) do
		pcall(function()
			local pn = base.Title.TitleGui.Frame.PlayerName
			if pn.Text == Player.Name or pn.Text == Player.DisplayName then
				M.baseGUID = base.Name
				local s1 = base:FindFirstChild("slot 1 brainrot")
				if s1 and s1:FindFirstChild("Root") then M.baseCFrame = s1.Root.CFrame end
			end
		end)
	end
	if not M.homePosition then M.setHomePosition() end
end

function M.setHomePosition()
	local ch = Player.Character if not ch then return end
	local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return end
	M.homePosition = hrp.CFrame
end

function M.getHomePosition()
	if M.homePosition then return M.homePosition end
	if M.baseCFrame then return M.baseCFrame end
	return CFrame.new(124, 3.8, 22)
end

task.spawn(function() task.wait(3) M.findBase() end)

-- ========== RESPAWN ==========
Player.CharacterAdded:Connect(function(character)
	task.wait(1.5)
	if M.S.InstantPickup then M.setupInstant() end
	task.wait(0.5) M.detectWallZ()
	if M._isGod then
		if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) M._godHealthConn = nil end
		if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) M._godDiedConn = nil end
		task.wait(0.5) godSetupHealth(character)
		godDisableKillParts()
		pcall(function()
			for _, data in pairs(M._godOriginalFloors) do
				if data.part and data.part.Parent then data.part.CanCollide = false data.part.Transparency = 1 end
			end
		end)
		task.wait(0.3) godTeleportUnder()
		M.Status.god = "Respawn âœ“ (Y=" .. M.S.GodWalkY .. ")"
	end
end)

-- ========== TWEEN ==========
function M.tweenTo(cf)
	local ch = Player.Character if not ch then return false end
	local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local targetCF = cf
	if M._isGod then targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z) end
	local d = (hrp.Position - targetCF.Position).Magnitude
	local t = math.max(d / M.S.TweenSpeed, 0.01)
	local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF})
	tw:Play() tw.Completed:Wait() return true
end

function M.fastTween(cf)
	local ch = Player.Character if not ch then return false end
	local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local targetCF = cf
	if M._isGod then targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z) end
	local d = (hrp.Position - targetCF.Position).Magnitude
	local t = math.max(d / 99999, 0.005)
	local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF})
	tw:Play() tw.Completed:Wait() return true
end

function M.corridorTween(cf)
	local ch = Player.Character if not ch then return false end
	local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local targetCF = cf
	if M._isGod then targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z) end
	local d = (hrp.Position - targetCF.Position).Magnitude
	local t = math.max(d / math.max(M.S.CorridorSpeed or 1500, 50), 0.01)
	local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF})
	tw:Play() tw.Completed:Wait() return true
end

-- ========== SAFE PATH ==========
function M.safePathTo(targetCFrame)
	local ch = Player.Character if not ch then return false end
	local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
	local startPos = hrp.Position
	local endPos = targetCFrame.Position
	local SAFE_Z = M.getCorridorZ()
	local SAFE_Y = M._isGod and M.S.GodWalkY or (M.getHomePosition().Position.Y + 8)
	M.fastTween(CFrame.new(startPos.X, SAFE_Y, startPos.Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(startPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(endPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(endPos.X, SAFE_Y, endPos.Z)) task.wait(0.05)
	local finalCF = M._isGod and CFrame.new(endPos.X, M.S.GodWalkY, endPos.Z) or targetCFrame
	M.tweenTo(finalCF) task.wait(0.05) return true
end

function M.safeReturnToBase()
	local ch = Player.Character if not ch then return end
	local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return end
	local curPos = hrp.Position
	local homePos = M.getHomePosition().Position
	M.detectWallZ()
	local SAFE_Z = M.getCorridorZ()
	local SAFE_Y = M._isGod and M.S.GodWalkY or (homePos.Y + 8)
	M.fastTween(CFrame.new(curPos.X, SAFE_Y, curPos.Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(curPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(homePos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
	M.corridorTween(CFrame.new(homePos.X, SAFE_Y, homePos.Z)) task.wait(0.05)
	M.tweenTo(CFrame.new(homePos.X, M._isGod and M.S.GodWalkY or homePos.Y, homePos.Z)) task.wait(0.05)
end

function M.returnToBase()
	if M._isGod then
		local hp = M.getHomePosition().Position
		M.tweenTo(CFrame.new(hp.X, M.S.GodWalkY, hp.Z))
	else M.tweenTo(M.getHomePosition()) end
	task.wait(0.1)
end

-- ========== HELPERS ==========
function M.isHighRarity(r) return HIGH_RARITIES[r] == true end
function M.isHighRarityTool(tool) if not tool then return false end return HIGH_RARITIES[tool:GetAttribute("Rarity") or ""] == true end
function M.isDead() local ch = Player.Character if not ch then return true end local hum = ch:FindFirstChild("Humanoid") if not hum then return true end return hum.Health <= 0 end
function M.waitForRespawn() if not M.isDead() then return true end local timeout = tick() + 15 while M.isDead() and tick() < timeout do task.wait(0.2) end task.wait(1) return not M.isDead() end

-- ========== FORCE GRAB ==========
function M.forceGrabPrompt(target)
	if not target then return end
	local prompts = {}
	if target:IsA("ProximityPrompt") then table.insert(prompts, target)
	else for _, d in pairs(target:GetDescendants()) do if d:IsA("ProximityPrompt") then table.insert(prompts, d) end end end
	for _, p in pairs(prompts) do
		pcall(function() p.MaxActivationDistance = 99999 p.HoldDuration = 0 p.RequiresLineOfSight = false end)
		pcall(function() fireproximityprompt(p) end) task.wait(0.02) pcall(function() fireproximityprompt(p) end)
	end
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local parent = target if parent:IsA("ProximityPrompt") then parent = parent.Parent end
		if parent and parent:IsA("BasePart") then pcall(function() firetouchinterest(hrp, parent, 0) end) pcall(function() firetouchinterest(hrp, parent, 1) end) end
		local sr = parent if sr and sr.Parent and not sr.Parent:IsA("Workspace") then sr = sr.Parent end
		if sr then for _, d in pairs(sr:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(hrp, d, 0) end) pcall(function() firetouchinterest(hrp, d, 1) end) end end end
	end
	task.wait(0.02)
end

-- ========== RARITY ==========
function M.getTargetRarities() return type(M.S.TargetRarity) == "table" and M.S.TargetRarity or {M.S.TargetRarity} end
function M.rarityMatches(fn) for _, r in pairs(M.getTargetRarities()) do if r == "Any" or r == fn then return true end end return false end

function M.getBrainrotNames(rarity)
	local names, seen = {}, {}
	if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
	if not M.ActiveBrainrots then return names end
	for _, f in pairs(M.ActiveBrainrots:GetChildren()) do
		if f:IsA("Folder") and (rarity == "Any" or f.Name == rarity) then
			for _, b in pairs(f:GetChildren()) do
				local n = nil
				if b:FindFirstChild("RenderedBrainrot") then n = b.RenderedBrainrot:GetAttribute("BrainrotName")
				elseif b.Name == "RenderedBrainrot" then n = b:GetAttribute("BrainrotName")
				else n = b:GetAttribute("BrainrotName") or b.Name end
				if n and n ~= "" and not seen[n] then seen[n] = true table.insert(names, n) end
			end
		end
	end
	table.sort(names) return names
end

function M.getBrainrotNamesMulti(rarities)
	if type(rarities) ~= "table" then return M.getBrainrotNames(rarities) end
	local names, seen = {}, {}
	for _, r in pairs(rarities) do if r == "Any" then return M.getBrainrotNames("Any") end end
	for _, r in pairs(rarities) do for _, n in pairs(M.getBrainrotNames(r)) do if not seen[n] then seen[n] = true table.insert(names, n) end end end
	table.sort(names) return names
end

function M.matchesFilter(b, folderRarity)
	if not M.rarityMatches(folderRarity) then return false end
	if M.isHighRarity(folderRarity) then return true end
	local mut = b:GetAttribute("Mutation") or "None"
	local isNone = (mut:lower() == "none" or mut == "")
	if M.S.TargetMutation == "None" then if not isNone then return false end
	elseif M.S.TargetMutation ~= "Any" then if mut ~= M.S.TargetMutation then return false end end
	if #M.S.SelectedBrainrots > 0 then
		local bName = b:GetAttribute("BrainrotName") or "" local found = false
		for _, sel in pairs(M.S.SelectedBrainrots) do if sel == bName then found = true break end end
		if not found then return false end
	end
	return true
end

function M.toolMatchesRarity(tool, targetRarity, targetMutation)
	local tMut = tool:GetAttribute("Mutation") or "None"
	local lvl = tonumber(tool:GetAttribute("Level")) or 0
	local bName = tool:GetAttribute("BrainrotName")
	local toolRarity = tool:GetAttribute("Rarity")
	if not bName or bName == "" then return false end
	if lvl >= M.S.MaxLevel then return false end
	if toolRarity and M.isHighRarity(toolRarity) then
		local tR = type(targetRarity) == "table" and targetRarity or {targetRarity}
		for _, r in pairs(tR) do if r == "Any" or r == toolRarity then return true end end return false
	end
	if targetMutation == "None" then if not (tMut:lower() == "none" or tMut == "") then return false end
	elseif targetMutation ~= "Any" then if tMut ~= targetMutation then return false end end
	local tR = type(targetRarity) == "table" and targetRarity or {targetRarity}
	local isAny = false for _, r in pairs(tR) do if r == "Any" then isAny = true break end end
	if not isAny then
		if toolRarity and toolRarity ~= "" then local m2 = false for _, r in pairs(tR) do if toolRarity == r then m2 = true break end end if not m2 then return false end
		else local wl = {} for _, r in pairs(tR) do for _, n in pairs(M.getBrainrotNames(r)) do wl[n] = true end end if not wl[bName] then return false end end
	end
	return true
end

-- ========== FACTORY ==========
local function factoryToolMatchesRarity(tool)
	local tMut = tool:GetAttribute("Mutation") or "None"
	local lvl = tonumber(tool:GetAttribute("Level")) or 0
	local bName = tool:GetAttribute("BrainrotName") local toolRarity = tool:GetAttribute("Rarity")
	if not bName or bName == "" then return false end if lvl >= M.S.FactoryMaxLevel then return false end
	if M.S.FactoryMutation == "None" then if not (tMut:lower() == "none" or tMut == "") then return false end
	elseif M.S.FactoryMutation ~= "Any" then if tMut ~= M.S.FactoryMutation then return false end end
	if M.S.FactoryRarity ~= "Any" then if toolRarity and toolRarity ~= "" then if toolRarity ~= M.S.FactoryRarity then return false end
	else local wl = {} for _, n in pairs(M.getBrainrotNames(M.S.FactoryRarity)) do wl[n] = true end if not wl[bName] then return false end end end
	if tool:GetAttribute("Locked") then return false end return true
end

function M.startFactoryLoop()
	if M.factoryThread then return end M.S.FactoryEnabled = true M.Status.factoryCount = 0
	M.factoryThread = task.spawn(function()
		local stopReason = "Idle"
		while M.S.FactoryEnabled do
			local ok, err = pcall(function()
				if not M.baseGUID then M.findBase() end if not M.baseGUID then task.wait(2) return end
				local ws = tonumber(M.S.FactorySlot) or 5
				M.tweenToSlot(ws) task.wait(0.2)
				if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(1) pcall(function() Player.Character.Humanoid:UnequipTools() end) task.wait(0.5) end
				local tool = nil local sa = 0
				while not tool and sa < 5 do sa += 1
					local bp = Player:FindFirstChild("Backpack")
					if bp then for _, t in pairs(bp:GetChildren()) do if t:IsA("Tool") and factoryToolMatchesRarity(t) then tool = t break end end end
					if not tool and Player.Character then local eq = Player.Character:FindFirstChildWhichIsA("Tool") if eq and factoryToolMatchesRarity(eq) then tool = eq end end
					if not tool and sa < 5 then task.wait(0.6) end
				end
				if not tool then stopReason = "Klaar! âœ“" M.S.FactoryEnabled = false return end
				local bName = tool:GetAttribute("BrainrotName") or "Item"
				local hum = Player.Character and Player.Character:FindFirstChild("Humanoid")
				if hum then hum:EquipTool(tool) task.wait(0.5) end
				M.placeBrainrot(ws) task.wait(0.8)
				if M.isSlotEmpty(ws) then pcall(function() if hum then hum:UnequipTools() end end) task.wait(1) return end
				local myBase = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
				local sm = myBase and myBase:FindFirstChild("slot " .. ws .. " brainrot")
				if sm then local cur = tonumber(sm:GetAttribute("Level")) or 0 local fails = 0
					while cur < M.S.FactoryMaxLevel and M.S.FactoryEnabled do
						for i = 1, 3 do task.spawn(function() M.upgradeBrainrot(ws) end) end task.wait()
						local nw = tonumber(sm:GetAttribute("Level")) or cur
						if nw > cur then fails = 0 cur = nw M.Status.factory = bName .. " Lv." .. cur .. "/" .. M.S.FactoryMaxLevel
						else fails += 1 if fails > 60 then stopReason = "Geld op!" M.S.FactoryEnabled = false break end end
					end
				end
				task.wait(0.5) M.pickUpBrainrot(ws) task.wait(1.2) M.Status.factoryCount += 1
				pcall(function() if hum then hum:UnequipTools() end end) task.wait(0.5)
				M.Status.factory = "âœ“ " .. bName .. " (#" .. M.Status.factoryCount .. ")"
			end)
			if not ok then task.wait(1) end
		end
		M.Status.factory = stopReason M.factoryThread = nil
	end)
end

function M.stopFactoryLoop()
	M.S.FactoryEnabled = false
	if M.factoryThread then pcall(task.cancel, M.factoryThread) M.factoryThread = nil end
	if not (string.find(M.Status.factory or "", "âœ“") or string.find(M.Status.factory or "", "Klaar") or string.find(M.Status.factory or "", "Geld op")) then M.Status.factory = "Idle" end
end

-- ========== FIND TARGET TOOL ==========
function M.findTargetToolInBackpack()
	local bp = Player:FindFirstChild("Backpack")
	if bp then for _, t in pairs(bp:GetChildren()) do if t:IsA("Tool") and M.toolMatchesRarity(t, M.S.TargetRarity, M.S.TargetMutation) then return t end end end
	local ch = Player.Character if ch then local eq = ch:FindFirstChildWhichIsA("Tool") if eq and M.toolMatchesRarity(eq, M.S.TargetRarity, M.S.TargetMutation) then return eq end end
	return nil
end

function M.findBrainrotRoot(b)
	local root = b:FindFirstChild("Root") if root and root:IsA("BasePart") then return root end
	local rendered = b:FindFirstChild("RenderedBrainrot") if rendered then local rr = rendered:FindFirstChild("Root") if rr and rr:IsA("BasePart") then return rr end end
	for _, desc in pairs(b:GetDescendants()) do if desc:IsA("BasePart") then return desc end end
	if b:IsA("BasePart") then return b end return nil
end

-- ========== SLOTS ==========
function M.isSlotEmpty(s) if not M.baseGUID then M.findBase() end if not M.baseGUID then return true end local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return true end local sm = mb:FindFirstChild("slot " .. s .. " brainrot") if not sm then return true end local bn = sm:GetAttribute("BrainrotName") return not bn or bn == "" end

function M.findOccupiedSlots()
	if not M.baseGUID then M.findBase() end if not M.baseGUID then return {} end
	local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return {} end
	local o = {} for i = 1, 40 do local sm = mb:FindFirstChild("slot " .. i .. " brainrot") if sm then local bn = sm:GetAttribute("BrainrotName") local lv = sm:GetAttribute("Level") if bn and bn ~= "" then table.insert(o, {slot = i, name = bn, level = lv or 1}) end end end return o
end

-- ========== REMOTES ==========
function M.placeBrainrot(s) if not M.baseGUID or not M.PlotAction then return false end local ok = pcall(function() M.PlotAction:InvokeServer("Place Brainrot", M.baseGUID, tostring(s)) end) if ok then M.Status.placeCount += 1 end return ok end
function M.pickUpBrainrot(s) if not M.baseGUID or not M.PlotAction then return false end return pcall(function() M.PlotAction:InvokeServer("Pick Up Brainrot", M.baseGUID, tostring(s)) end) end
function M.clearSlot(s) if not M.baseGUID or not M.PlotAction then return end pcall(function() M.PlotAction:InvokeServer("Pick Up Brainrot", M.baseGUID, tostring(s)) end) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
function M.upgradeBrainrot(s) if not M.baseGUID or not M.PlotAction then return false end return pcall(function() M.PlotAction:InvokeServer("Upgrade Brainrot", M.baseGUID, tostring(s)) end) end

function M.tweenToSlot(sn)
	if not M.baseGUID then M.findBase() end if not M.baseGUID then return false end
	local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return false end
	local sm = mb:FindFirstChild("slot " .. sn .. " brainrot") if not sm then return false end
	local root = sm:FindFirstChild("Root") if root and root:IsA("BasePart") then return M.tweenTo(root.CFrame * CFrame.new(0, 3, 0)) end
	local ok, pos = pcall(function() return sm:GetPivot() end) if ok and pos then return M.tweenTo(pos * CFrame.new(0, 3, 0)) end return false
end

function M.upgradeSlotToMax(slot)
	if not M.baseGUID then M.findBase() end if not M.baseGUID then return end
	local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return end
	local sm = mb:FindFirstChild("slot " .. slot .. " brainrot") if not sm then return end
	local cur = tonumber(sm:GetAttribute("Level")) or 1 local fails = 0
	while cur < M.S.MaxLevel and M.S.AutoUpgrade do
		for i = 1, 3 do task.spawn(function() M.upgradeBrainrot(slot) end) end task.wait()
		local nw = tonumber(sm:GetAttribute("Level")) or cur
		if nw > cur then fails = 0 cur = nw M.Status.upgradeCount += 1 else fails += 1 if fails >= 60 then break end end
	end
end

-- ========== FARMING ==========
function M.startFarming()
	if M.farmThread then return end M.S.Farming = true M.Status.farmCount = 0
	M.setHomePosition() M.detectWallZ() M.returnToBase() M.enableGod()
	M.farmThread = task.spawn(function()
		while M.S.Farming do
			local ok, err = pcall(function()
				if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() task.wait(0.5) return end
				local ch = Player.Character local hum = ch and ch:FindFirstChild("Humanoid") if not ch or not hum then task.wait(1) return end
				if not M.baseGUID then M.findBase() end if not M.baseGUID then task.wait(2) return end
				local ws = tonumber(M.S.FarmSlot) or 5

				if M.S.FarmMode == "Collect" then
					if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
					if M.ActiveBrainrots then for _, folder in pairs(M.ActiveBrainrots:GetChildren()) do
						if not M.S.Farming then break end
						if folder:IsA("Folder") and M.rarityMatches(folder.Name) then for _, b in pairs(folder:GetChildren()) do
							if not M.S.Farming or M.isDead() then break end
							if M.matchesFilter(b, folder.Name) then
								local root = M.findBrainrotRoot(b) if not root then continue end
								M.safePathTo(root.CFrame * CFrame.new(0, 3, 0))
								for attempt = 1, 5 do if not M.S.Farming then break end
									if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() if root and root.Parent then M.safePathTo(root.CFrame * CFrame.new(0, 3, 0)) else break end end
									if root and root.Parent then M.forceGrabPrompt(root) M.forceGrabPrompt(b) task.wait(0.3) M.Status.farmCount += 1 break else break end
								end
								M.safeUnequip() task.wait(0.1) M.safeReturnToBase()
							end
						end end
					end end
					task.wait(1) return
				end

				if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
				local tool = M.findTargetToolInBackpack()
				if tool and M.isHighRarityTool(tool) then M.Status.farm = "âœ“ " .. (tool:GetAttribute("Rarity") or "High") M.Status.farmCount += 1 task.wait(0.5) tool = nil end

				if not tool then
					local found = false
					if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
					if M.ActiveBrainrots then for _, folder in pairs(M.ActiveBrainrots:GetChildren()) do
						if not M.S.Farming then break end
						if folder:IsA("Folder") and M.rarityMatches(folder.Name) then for _, b in pairs(folder:GetChildren()) do
							if not M.S.Farming or M.isDead() then break end
							if M.matchesFilter(b, folder.Name) then
								local root = M.findBrainrotRoot(b) if not root then continue end found = true
								M.Status.farm = "Ophalen " .. folder.Name
								M.safePathTo(root.CFrame * CFrame.new(0, 3, 0))
								for attempt = 1, 5 do if not M.S.Farming then break end
									if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() if not M.S.Farming then break end if root and root.Parent then M.safePathTo(root.CFrame * CFrame.new(0, 3, 0)) else found = false break end end
									if root and root.Parent then M.forceGrabPrompt(root) M.forceGrabPrompt(b) task.wait(0.3) M.Status.farmCount += 1 break else found = false break end
								end
								M.safeUnequip() task.wait(0.1) M.safeReturnToBase() break
							end
						end end
						if found then break end
					end end
					if not found then M.Status.farm = "Wachten..." task.wait(2) return end
					task.wait(0.3) tool = M.findTargetToolInBackpack()
					if not tool then task.wait(1) return end
				end

				if M.isHighRarityTool(tool) then M.Status.farm = "âœ“ High" M.Status.farmCount += 1 task.wait(0.5) return end

				local bName = tool:GetAttribute("BrainrotName") or "Brainrot"
				M.tweenToSlot(ws) task.wait(0.3) M.safeEquip(tool) task.wait(0.5) M.placeBrainrot(ws) task.wait(0.8)
				if M.isSlotEmpty(ws) then M.safeUnequip() task.wait(1) return end
				local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
				local sm = mb and mb:FindFirstChild("slot " .. ws .. " brainrot")
				if sm then local cur = tonumber(sm:GetAttribute("Level")) or 0 local fails = 0
					while cur < M.S.MaxLevel and M.S.Farming do
						for i = 1, 3 do task.spawn(function() M.upgradeBrainrot(ws) end) end task.wait()
						local nw = tonumber(sm:GetAttribute("Level")) or cur
						if nw > cur then fails = 0 cur = nw M.Status.upgradeCount += 1 M.Status.farm = bName .. " Lv." .. cur .. "/" .. M.S.MaxLevel
						else fails += 1 if fails > 60 then break end end
					end
				end
				task.wait(0.3) M.pickUpBrainrot(ws) task.wait(0.8) M.safeUnequip() task.wait(0.3)
				if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
			end)
			if not ok then task.wait(1) end task.wait(0.3)
		end
		M.disableGod() M.Status.farm = "Idle" M.farmThread = nil
	end)
end

function M.stopFarming() M.S.Farming = false if M.farmThread then pcall(task.cancel, M.farmThread) M.farmThread = nil end M.disableGod() M.Status.farm = "Idle" end

-- ========== LUCKY BLOCKS ==========
function M.getLuckyBlockRarities() return type(M.S.LuckyBlockRarity) == "table" and M.S.LuckyBlockRarity or {M.S.LuckyBlockRarity} end
function M.luckyBlockRarityMatches(bn) for _, r in pairs(M.getLuckyBlockRarities()) do if r == "Any" or bn:find(r) or bn == r then return true end end return false end
function M.luckyBlockMutationMatches(block) local mut = block:GetAttribute("Mutation") or "None" local isNone = (mut:lower() == "none" or mut == "") if M.S.LuckyBlockMutation == "Any" then return true end if M.S.LuckyBlockMutation == "None" then return isNone end return mut == M.S.LuckyBlockMutation end
function M.findLuckyBlockRoot(block) local r = block:FindFirstChild("Root") if r and r:IsA("BasePart") then return r end if block:IsA("BasePart") then return block end local p = nil pcall(function() p = block.PrimaryPart end) if p then return p end for _, d in pairs(block:GetDescendants()) do if d:IsA("BasePart") then return d end end return nil end

function M.grabLuckyBlock(block, rootPart)
	if not block or not rootPart then return end
	for _, d in pairs(block:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.MaxActivationDistance = 99999 d.HoldDuration = 0 d.RequiresLineOfSight = false end) pcall(function() fireproximityprompt(d) end) end end
	if not rootPart:IsA("ProximityPrompt") then for _, d in pairs(rootPart:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.MaxActivationDistance = 99999 d.HoldDuration = 0 d.RequiresLineOfSight = false end) pcall(function() fireproximityprompt(d) end) end end end
	local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local function ta(obj) if obj:IsA("BasePart") then pcall(function() firetouchinterest(hrp, obj, 0) end) pcall(function() firetouchinterest(hrp, obj, 1) end) end for _, d in pairs(obj:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(hrp, d, 0) end) pcall(function() firetouchinterest(hrp, d, 1) end) end end end
		ta(block) if rootPart ~= block then ta(rootPart) end
	end
end

function M.startLuckyBlockFarm()
	if M.luckyBlockThread then return end M.S.LuckyBlockEnabled = true M.Status.luckyBlockCount = 0 M.setHomePosition() M.enableGod()
	M.luckyBlockThread = task.spawn(function()
		while M.S.LuckyBlockEnabled do
			local ok = pcall(function()
				if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() return end
				if not M.ActiveLuckyBlocks then M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks") end
				if not M.ActiveLuckyBlocks then task.wait(3) return end
				local foundBlock = false
				for _, block in pairs(M.ActiveLuckyBlocks:GetChildren()) do
					if not M.S.LuckyBlockEnabled or M.isDead() then break end
					if M.luckyBlockRarityMatches(block.Name) and M.luckyBlockMutationMatches(block) then
						local rootPart = M.findLuckyBlockRoot(block) if not rootPart then continue end foundBlock = true
						M.safePathTo(rootPart.CFrame * CFrame.new(0, 3, 0))
						M.grabLuckyBlock(block, rootPart)
						local t = tick() while tick() - t < 0.2 do if not block.Parent or not rootPart.Parent then break end task.wait(0.02) end
						if not block.Parent or not rootPart.Parent then M.Status.luckyBlockCount += 1 end
						M.safeUnequip() M.safeReturnToBase() break
					end
				end
				if not foundBlock then task.wait(2) end
			end)
			task.wait(0.1)
		end
		M.disableGod() M.Status.luckyBlock = "Idle" M.luckyBlockThread = nil
	end)
end

function M.stopLuckyBlockFarm() M.S.LuckyBlockEnabled = false if M.luckyBlockThread then pcall(task.cancel, M.luckyBlockThread) M.luckyBlockThread = nil end M.disableGod() M.Status.luckyBlock = "Idle" end

-- ========== MONEY ==========
function M.startMoney()
	if M.moneyThread then return end M.S.AutoCollectMoney = true M.Status.money = "Actief" if not M.baseGUID then M.findBase() end
	M.moneyThread = task.spawn(function() while M.S.AutoCollectMoney do pcall(function() if not M.baseGUID then M.findBase() end if not M.baseGUID then return end local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not mb or not hrp then return end for i = 1, 40 do local sm = mb:FindFirstChild("slot " .. i .. " brainrot") if sm and sm:GetAttribute("BrainrotName") and sm:GetAttribute("BrainrotName") ~= "" then for _, d in pairs(sm:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end) end end end end end) task.wait(0.1) end M.Status.money = "Idle" end)
	M.moneyRemoteThread = task.spawn(function() while M.S.AutoCollectMoney do pcall(function() if M.baseGUID and M.PlotAction then for i = 1, 40 do task.spawn(function() pcall(function() M.PlotAction:InvokeServer("Collect Money", M.baseGUID, tostring(i)) end) end) end end end) task.wait(1) end end)
end
function M.stopMoney() M.S.AutoCollectMoney = false if M.moneyThread then pcall(task.cancel, M.moneyThread) M.moneyThread = nil end if M.moneyRemoteThread then pcall(task.cancel, M.moneyRemoteThread) M.moneyRemoteThread = nil end M.Status.money = "Idle" end

-- ========== AUTO UPGRADE ==========
function M.startAutoUpgrade() if M.upgradeThread then return end M.S.AutoUpgrade = true M.Status.upgradeCount = 0 M.upgradeThread = task.spawn(function() while M.S.AutoUpgrade do pcall(function() for _, info in pairs(M.findOccupiedSlots()) do if not M.S.AutoUpgrade then break end if info.level < M.S.MaxLevel then M.upgradeSlotToMax(info.slot) end end M.Status.upgrade = "Klaar (#" .. M.Status.upgradeCount .. ")" end) task.wait(3) end M.Status.upgrade = "Idle" end) end
function M.stopAutoUpgrade() M.S.AutoUpgrade = false if M.upgradeThread then pcall(task.cancel, M.upgradeThread) M.upgradeThread = nil end M.Status.upgrade = "Idle" end

-- ========== ANTI AFK ==========
function M.startAFK() if M.afkThread then return end M.S.AntiAFK = true M.Status.afk = "Actief" pcall(function() for _, c in pairs(getconnections(Player.Idled)) do c:Disable() end end) pcall(function() local vu = game:GetService("VirtualUser") M._afkSteppedConn = RunService.Stepped:Connect(function() if M.S.AntiAFK then pcall(function() vu:CaptureController() vu:ClickButton2(Vector2.new()) end) end end) end) M.afkThread = task.spawn(function() while M.S.AntiAFK do pcall(function() for _, c in pairs(getconnections(Player.Idled)) do c:Disable() end end) task.wait(300) end M.Status.afk = "Uit" end) end
function M.stopAFK() M.S.AntiAFK = false if M.afkThread then pcall(task.cancel, M.afkThread) M.afkThread = nil end if M._afkSteppedConn then pcall(function() M._afkSteppedConn:Disconnect() end) M._afkSteppedConn = nil end M.Status.afk = "Uit" end

-- ========== INSTANT PICKUP ==========
function M.setupInstant() for _, o in pairs(workspace:GetDescendants()) do if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration = 0 end) end end if not M._instantConn then M._instantConn = workspace.DescendantAdded:Connect(function(o) if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration = 0 end) end end) end end
M.setupInstant()

-- ========== VALENTINE ==========
function M.getHeartCount() local count = 0 pcall(function() local ls = Player:FindFirstChild("leaderstats") if ls then for _, v in pairs(ls:GetChildren()) do local n = v.Name:lower() if n:find("heart") or n:find("candy") or n:find("valentine") or n:find("gram") then count = tonumber(v.Value) or 0 return end end end end) if count == 0 then pcall(function() for _, a in pairs({"Hearts","Candy","CandyGrams","Valentines","Love","CandyHearts"}) do local v = Player:GetAttribute(a) if v and tonumber(v) and tonumber(v) > 0 then count = tonumber(v) return end end end) end return count end

function M.refreshValentineCache() M._valentineCachedParts = {} M._valentineLastCacheScan = tick() local kw = {"heart","candy","valentine","love","gram","pickup","collect","token"} for _, obj in pairs(workspace:GetDescendants()) do if obj:IsA("BasePart") then local n = obj.Name:lower() local m = false for _, k in pairs(kw) do if n:find(k) then m = true break end end if not m and obj:FindFirstChild("TouchInterest") then m = true end if m then table.insert(M._valentineCachedParts, obj) end end end end

function M.scanValentineRemotes() M._valentineFoundRemotes = {} local kw = {"valentine","candy","heart","gram","submit","collect","exchange","redeem","deliver","deposit","love"} local function sf(parent, path, depth) if depth > 10 then return end for _, v in pairs(parent:GetChildren()) do local n = v.Name:lower() local m = false for _, k in pairs(kw) do if n:find(k) then m = true break end end if m then table.insert(M._valentineFoundRemotes, {name = v.Name, path = path.."/"..v.Name, type = v:IsA("RemoteEvent") and "RE" or v:IsA("RemoteFunction") and "RF" or v.ClassName, object = v}) end sf(v, path.."/"..v.Name, depth+1) end end pcall(function() sf(game:GetService("ReplicatedStorage"), "RS", 0) end) return M._valentineFoundRemotes end

function M.submitHearts() local ok = false for _, r in pairs(M._valentineFoundRemotes) do local o = r.object if o and o.Parent then if r.type == "RE" then pcall(function() o:FireServer() ok = true end) pcall(function() o:FireServer(true) end) elseif r.type == "RF" then pcall(function() o:InvokeServer() ok = true end) end end end pcall(function() if M.PlotAction then M.PlotAction:InvokeServer("Submit Hearts") M.PlotAction:InvokeServer("Submit Candy") end end) return ok end

function M.startValentine()
	if M.valentineThread then return end M.S.ValentineEnabled = true M.Status.valentineCount = 0 M._valentineCollecting = true
	M.scanValentineRemotes() M.refreshValentineCache()
	if M._valentineDescAddedConn then pcall(function() M._valentineDescAddedConn:Disconnect() end) end
	M._valentineDescAddedConn = workspace.DescendantAdded:Connect(function(d) if not M.S.ValentineEnabled then return end if d:IsA("BasePart") then local n = d.Name:lower() local kw = {"heart","candy","valentine","gram"} for _, k in pairs(kw) do if n:find(k) then table.insert(M._valentineCachedParts, d) pcall(function() local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if hrp then firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end end) break end end end if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration = 0 d.MaxActivationDistance = 99999 end) end end)
	M.valentineCollectorConn = RunService.Heartbeat:Connect(function() if not M.S.ValentineEnabled or not M._valentineCollecting then return end pcall(function() local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not hrp then return end if tick() - M._valentineLastCacheScan > 10 then local a = {} for _, p in pairs(M._valentineCachedParts) do if p and p.Parent then table.insert(a, p) end end M._valentineCachedParts = a M._valentineLastCacheScan = tick() end for _, p in pairs(M._valentineCachedParts) do if p and p.Parent then firetouchinterest(hrp, p, 0) firetouchinterest(hrp, p, 1) end end end) end)
	M.valentineThread = task.spawn(function()
		local submitCD, scanCD = 0, 0
		while M.S.ValentineEnabled do pcall(function()
			if tick() - scanCD > 60 then M.scanValentineRemotes() scanCD = tick() end
			local h = M.getHeartCount() M.Status.valentine = "H:" .. h .. " C:" .. #M._valentineCachedParts .. " #" .. M.Status.valentineCount
			if h >= 100 then if tick() - submitCD < 1 then return end M._valentineCollecting = false task.wait(0.3) local prevH = h
				for attempt = 1, 10 do if not M.S.ValentineEnabled then break end M.submitHearts() task.wait(0.8) local newH = M.getHeartCount() if newH < prevH or newH == 0 then M.Status.valentineCount += 1 submitCD = tick() break end task.wait(0.5) end
				task.wait(0.5) M.refreshValentineCache() M._valentineCollecting = true end
		end) task.wait(0.5) end M.Status.valentine = "Idle" M.valentineThread = nil
	end)
end

function M.stopValentine() M.S.ValentineEnabled = false M._valentineCollecting = false if M.valentineThread then pcall(task.cancel, M.valentineThread) M.valentineThread = nil end if M.valentineCollectorConn then pcall(function() M.valentineCollectorConn:Disconnect() end) M.valentineCollectorConn = nil end if M._valentineDescAddedConn then pcall(function() M._valentineDescAddedConn:Disconnect() end) M._valentineDescAddedConn = nil end M._valentineCachedParts = {} M.Status.valentine = "Idle" end

-- ========== ARCADE ==========
function M.startArcade() if M.arcadeThread then return end M.S.ArcadeEnabled = true M.Status.arcadeCount = 0 M.arcadeThread = task.spawn(function() while M.S.ArcadeEnabled do pcall(function() local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not hrp then return end for _, fn in pairs({"ArcadeEventConsoles","ArcadeEventTickets"}) do local f = workspace:FindFirstChild(fn) if f then for _, item in pairs(f:GetChildren()) do for _, d in pairs(item:GetDescendants()) do if d:IsA("BasePart") and d:FindFirstChild("TouchInterest") then pcall(function() firetouchinterest(hrp, d, 0) task.wait(0.01) firetouchinterest(hrp, d, 1) end) M.Status.arcadeCount += 1 end end end end end end) task.wait(0.05) end M.Status.arcade = "Idle" M.arcadeThread = nil end) end
function M.stopArcade() M.S.ArcadeEnabled = false if M.arcadeThread then pcall(task.cancel, M.arcadeThread) M.arcadeThread = nil end M.Status.arcade = "Idle" end

-- ========== MAP FIXER ==========
local MF = {W=350,WH=80,WT=6,INT=8,BLK=Color3.fromRGB(0,0,0),GLD=Color3.fromRGB(255,200,50),GLW=Color3.fromRGB(255,215,0)}
MF.SZ=MF.W/2
MF.WY = MF.WH/2 - 10

local function safeDestroyFolder(parent, fn) if not parent then return end local f = parent:FindFirstChild(fn) if not f or f.Name == "MzDHubWalls" then return end pcall(function() for _, d in pairs(f:GetDescendants()) do if d:IsA("BasePart") then d:Destroy() end end f:Destroy() end) end
local MAP_FOLDERS_REMOVE = {"RightWalls","LeftWalls","Gaps","VIPWalls","SideWalls","Barriers","Fences","Walls","Decorations"}
local EVENT_MAPS = {"ValentinesMap","ArcadeMap","CandyMap","HalloweenMap","ChristmasMap","EasterMap","SummerMap","SpringMap","WinterMap"}

local function isWallPart(p) if not p:IsA("BasePart") then return false end if isMzDPart(p) then return false end local n = p.Name:lower() for _, k in pairs({"vipwall","sidewall","barrier","fence","blocker","border"}) do if n == k or n:find("^"..k) then return true end end if p.Size.Y > 15 and p.Size.Y > p.Size.X*3 and p.Size.Y > p.Size.Z*3 then if math.abs(p.Position.Z) > 60 then return true end end return false end

function M.mapDetectXRange(map, si)
	local minX, maxX = math.huge, -math.huge local found = false
	local function chk(p) if not p:IsA("BasePart") or isMzDPart(p) then return end if p.Size.Y > p.Size.X and p.Size.Y > p.Size.Z then return end if p.Position.Y > 50 or p.Position.Y < -30 or p.Size.X < 5 then return end local l = p.Position.X - p.Size.X/2 local r = p.Position.X + p.Size.X/2 if l < minX then minX = l end if r > maxX then maxX = r end found = true end
	for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") then chk(c) end end local sp = map:FindFirstChild("Spawners") if sp then for _, s in pairs(sp:GetChildren()) do chk(s) end end
	if si then for _, c in pairs(si:GetChildren()) do if c:IsA("BasePart") then chk(c) end end local sf = si:FindFirstChild("Floors") if sf then for _, f in pairs(sf:GetChildren()) do chk(f) end end end
	if found and maxX > minX then return minX-5, maxX+5 end return -15, 4385
end
function M.mapFindShared(mn) return workspace:FindFirstChild(mn.."_SharedInstances") end

local function getFloorParts(map, si)
	local fl = {} local function af(p) if not p:IsA("BasePart") or isMzDPart(p) then return end if p.Size.Y > p.Size.X and p.Size.Y > p.Size.Z then return end if p.Position.Y > 30 or p.Position.Y < -20 or p.Size.X < 5 then return end for _, f in pairs(fl) do if f == p then return end end table.insert(fl, p) end
	local ff = map:FindFirstChild("FirstFloor") if ff and ff:IsA("BasePart") then af(ff) end local gr = map:FindFirstChild("Ground") if gr and gr:IsA("BasePart") then af(gr) end
	local sp = map:FindFirstChild("Spawners") if sp then for _, s in pairs(sp:GetChildren()) do if s:IsA("BasePart") then af(s) end end end
	for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") then local n = c.Name:lower() if n=="firstfloor" or n=="ground" or n=="bridgefloor" or n=="floor" or n=="grass" or n=="path" or n=="road" or n=="platform" then af(c) elseif c.Size.X > 50 and c.Size.Z > 10 and c.Size.Y < 10 then af(c) end end end
	if si then local sf = si:FindFirstChild("Floors") if sf then for _, f in pairs(sf:GetChildren()) do if f:IsA("BasePart") then af(f) end end end for _, c in pairs(si:GetChildren()) do if c:IsA("BasePart") and c.Size.X > 50 and c.Size.Z > 10 and c.Size.Y < 10 then af(c) end end end
	return fl
end

function M.mapCleanup(map) for _, n in pairs(MAP_FOLDERS_REMOVE) do safeDestroyFolder(map, n) end for _, d in pairs(map:GetDescendants()) do if d.Parent and not isMzDPart(d) and d:IsA("BasePart") and isWallPart(d) then pcall(function() d:Destroy() end) end end end
function M.mapCleanupShared(si) if not si then return end for _, n in pairs(MAP_FOLDERS_REMOVE) do safeDestroyFolder(si, n) end for _, d in pairs(si:GetDescendants()) do if d:IsA("BasePart") and not isMzDPart(d) and isWallPart(d) then pcall(function() d:Destroy() end) end end end
function M.mapCleanupMisc() local misc = workspace:FindFirstChild("Misc") if misc then for _, c in pairs(misc:GetChildren()) do if c.Name == "BrickAddition" or c.Name == "Roof" then pcall(function() c:Destroy() end) end end end end
function M.cleanupEventMaps() for _, mn in pairs(EVENT_MAPS) do local em = workspace:FindFirstChild(mn) if em then for _, fn in pairs(MAP_FOLDERS_REMOVE) do safeDestroyFolder(em, fn) end for _, d in pairs(em:GetDescendants()) do if d:IsA("BasePart") and not isMzDPart(d) and isWallPart(d) then pcall(function() d:Destroy() end) end end end end end

function M.mapWidenFloors(map, si) for _, p in pairs(getFloorParts(map, si)) do pcall(function() if math.abs(p.Size.Z - MF.W) > 1 then p.Size = Vector3.new(p.Size.X, p.Size.Y, MF.W) p.Position = Vector3.new(p.Position.X, p.Position.Y, 0) end end) end end

function M.mapFillGaps(map, sx, ex)
	local ref = nil local ff = map:FindFirstChild("FirstFloor") if ff and ff:IsA("BasePart") then ref = ff end
	if not ref then local g = map:FindFirstChild("Ground") if g and g:IsA("BasePart") then ref = g end end
	if not ref then local sp = map:FindFirstChild("Spawners") if sp then for _, s in pairs(sp:GetChildren()) do if s:IsA("BasePart") then ref = s break end end end end
	if not ref then for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") and not isMzDPart(c) and c.Size.X > 50 and c.Size.Y < 10 and c.Position.Y < 20 then ref = c break end end end
	if not ref then return end
	local fY, fH, fC, fM = ref.Position.Y, ref.Size.Y, ref.Color, ref.Material
	for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") and c.Name == "BridgeFloor" then pcall(function() c:Destroy() end) end end
	local maxSeg = 2000 local curX = sx
	while curX < ex do local segLen = math.min(maxSeg, ex - curX)
		local b = Instance.new("Part") b.Name = "BridgeFloor" b.Size = Vector3.new(segLen, fH, MF.W) b.Position = Vector3.new(curX + segLen/2, fY, 0)
		b.Anchored = true b.CanCollide = true b.Color = fC b.Material = fM b.TopSurface = Enum.SurfaceType.Smooth b.BottomSurface = Enum.SurfaceType.Smooth b.Parent = map
		curX = curX + segLen end
end

function M.mapBuildWalls(map, sx, ex)
	local mf = map:FindFirstChild("MzDHubWalls")
	if mf then
		local fw = mf:FindFirstChild("FrontWall_1")
		if fw and math.abs(fw.Size.Y - MF.WH) < 1 and math.abs(fw.Position.Y - MF.WY) < 1 then
			M._wallZ_front = MF.SZ - 3 M._wallZ_back = -MF.SZ + 3
			return
		end
		pcall(function() mf:Destroy() end)
	end
	mf = Instance.new("Folder") mf.Name = "MzDHubWalls" mf.Parent = map

	local function mw(nm, sz, ps)
		local w = Instance.new("Part") w.Name = nm w.Size = sz w.Position = ps
		w.Anchored = true w.CanCollide = true
		w.Color = MF.BLK w.Material = Enum.Material.SmoothPlastic
		w.TopSurface = Enum.SurfaceType.Smooth w.BottomSurface = Enum.SurfaceType.Smooth
		w.Parent = mf return w
	end
	local function ms(nm, sz, ps)
		local s = Instance.new("Part") s.Name = nm s.Size = sz s.Position = ps
		s.Anchored = true s.CanCollide = false
		s.Color = MF.GLD s.Material = Enum.Material.Neon
		s.Parent = mf
	end
	local function at(w, f)
		local sg = Instance.new("SurfaceGui") sg.Face = f sg.CanvasSize = Vector2.new(800,400) sg.Parent = w
		local t = Instance.new("TextLabel") t.Size = UDim2.new(1,0,0.5,0) t.Position = UDim2.new(0,0,0.1,0)
		t.BackgroundTransparency = 1 t.Text = "MzD Hub" t.TextColor3 = MF.GLW t.TextScaled = true t.Font = Enum.Font.GothamBold t.Parent = sg
		local s2 = Instance.new("TextLabel") s2.Size = UDim2.new(0.6,0,0.2,0) s2.Position = UDim2.new(0.2,0,0.6,0)
		s2.BackgroundTransparency = 1 s2.Text = "v11.2" s2.TextColor3 = Color3.fromRGB(200,200,200) s2.TextScaled = true s2.Font = Enum.Font.Gotham s2.Parent = sg
	end

	local segs = {} local sl = 2000 local p = sx
	while p < ex do local l = math.min(sl, ex-p) table.insert(segs, {s=p,l=l}) p = p + l end

	for i, s in pairs(segs) do
		local cx = s.s + s.l/2
		local fw = mw("FrontWall_"..i, Vector3.new(s.l, MF.WH, MF.WT), Vector3.new(cx, MF.WY, MF.SZ+MF.WT/2))
		at(fw, Enum.NormalId.Front) at(fw, Enum.NormalId.Back)
		ms("FS_t"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, 20, MF.SZ+MF.WT+0.2))
		ms("FS_b"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, 2, MF.SZ+MF.WT+0.2))
		ms("FS_m"..i, Vector3.new(s.l,0.5,0.3), Vector3.new(cx, 10, MF.SZ+MF.WT+0.2))
		local bw = mw("BackWall_"..i, Vector3.new(s.l, MF.WH, MF.WT), Vector3.new(cx, MF.WY, -MF.SZ-MF.WT/2))
		at(bw, Enum.NormalId.Front) at(bw, Enum.NormalId.Back)
		ms("BS_t"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, 20, -MF.SZ-MF.WT-0.2))
		ms("BS_b"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, 2, -MF.SZ-MF.WT-0.2))
		ms("BS_m"..i, Vector3.new(s.l,0.5,0.3), Vector3.new(cx, 10, -MF.SZ-MF.WT-0.2))
	end

	mw("LeftWall", Vector3.new(MF.WT, MF.WH, MF.SZ*2+MF.WT*2+2), Vector3.new(sx-MF.WT/2, MF.WY, 0))
	mw("RightWall", Vector3.new(MF.WT, MF.WH, MF.SZ*2+MF.WT*2+2), Vector3.new(ex+MF.WT/2, MF.WY, 0))

	M._wallZ_front = MF.SZ - 3 M._wallZ_back = -MF.SZ + 3
end

function M.mapFixCollision(map, si)
	for _, p in pairs(getFloorParts(map, si)) do
		if M._isGod then pcall(function() p.CanCollide = false p.Transparency = 1 end)
		else pcall(function() p.CanCollide = true p.Transparency = 0 end) end
	end
	for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") and c.Name == "BridgeFloor" then
		if M._isGod then pcall(function() c.CanCollide = false c.Transparency = 1 end)
		else pcall(function() c.CanCollide = true end) end
	end end
	local mf = map:FindFirstChild("MzDHubWalls") if mf then for _, w in pairs(mf:GetChildren()) do if w:IsA("BasePart") then
		if w.Name:find("FS_") or w.Name:find("BS_") then w.CanCollide = false
		else w.CanCollide = true w.Anchored = true end
	end end end
end

M._lastFixedMapName = ""

function M.mapRunFix()
	local map = M.mapFindCurrentMap() if not map then return end
	local si = M.mapFindShared(map.Name)
	local mapChanged = map.Name ~= M._lastFixedMapName

	if mapChanged then
		M._lastFixedMapName = map.Name
		M.lastMapName = map.Name
	end

	local sx, ex = M.mapDetectXRange(map, si)

	if mapChanged then
		pcall(function() M.mapCleanup(map) end)
		pcall(function() M.mapCleanupShared(si) end)
		pcall(function() M.mapCleanupMisc() end)
		pcall(function() M.cleanupEventMaps() end)
		task.wait(0.1)
		pcall(function() M.mapWidenFloors(map, si) end)
		pcall(function() M.mapFillGaps(map, sx, ex) end)
		pcall(function() M.mapBuildWalls(map, sx, ex) end)
		M.Status.mapFixer = "Gefixed: " .. map.Name
	end

	pcall(function() M.mapFixCollision(map, si) end)
end

function M.startMapFixer()
	if M.mapFixerThread then return end M.S.MapFixerEnabled = true M._lastFixedMapName = ""
	pcall(function() M.mapRunFix() end)
	M.mapFixerThread = task.spawn(function()
		while M.S.MapFixerEnabled do
			pcall(function() M.mapRunFix() end)
			M.Status.mapFixer = "Actief"
			task.wait(MF.INT)
		end
		M.Status.mapFixer = "Uit" M.mapFixerThread = nil
	end)
end
function M.stopMapFixer() M.S.MapFixerEnabled = false if M.mapFixerThread then pcall(task.cancel, M.mapFixerThread) M.mapFixerThread = nil end M.Status.mapFixer = "Uit" end

print("[MzD Hub] Core v11.2 Geladen")

-- ============================================
-- GUI
-- ============================================
task.wait(0.5)
pcall(function() for _, gui in pairs(Player.PlayerGui:GetChildren()) do if gui:IsA("ScreenGui") then for _, d in pairs(gui:GetDescendants()) do if d:IsA("TextLabel") and d.Text == "MzD Hub" then gui:Destroy() break end end end end end) task.wait(0.3)

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local RAR={"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity"}
local MUT={"Any","None","Emerald","Gold","Blood","Diamond","Rainbow","Shadow","Crystal","Void"}
local FM={"Collect","Collect, Place & Max"} local FR=RAR
local LBR={"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity","Admin","UFO","Candy","Money"}
local SL={} for i=1,40 do table.insert(SL,tostring(i)) end
local SPD={"200","400","600","800","1000","1500","2000","3000","4000","INSTANT"}
local SPM={["200"]=200,["400"]=400,["600"]=600,["800"]=800,["1000"]=1000,["1500"]=1500,["2000"]=2000,["3000"]=3000,["4000"]=4000,["INSTANT"]=9999}
local CSPD={"100","200","300","400","500","600","800","1000","1500","2000"}
local GODWALKY={"0","-1","-2","-3","-5","-8","-10","-15"} local GODFLOORY={"-3","-5","-8","-10","-15","-20"}

local W = Fluent:CreateWindow({Title="MzD Hub",SubTitle="v11.2",TabWidth=160,Size=UDim2.fromOffset(600,500),Acrylic=true,Theme="Dark",MinimizeKey=Enum.KeyCode.RightControl})

local FT=W:AddTab({Title="Farm",Icon="swords"})
FT:AddParagraph({Title="ðŸŒ¾ Filters",Content="Celestial/Divine/Infinity negeert filters"})
local BDD=nil
local RDD=FT:AddDropdown("FarmRarity",{Title="Rarity",Values=RAR,Default={"Common"},Multi=true})
RDD:OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end if #s==0 then s={"Common"} end local any=false for _,r in pairs(s) do if r=="Any" then any=true break end end M.S.TargetRarity=any and "Any" or s M.S.SelectedBrainrots={} pcall(function() BDD:SetValues(M.getBrainrotNamesMulti(M.S.TargetRarity)) BDD:SetValue({}) end) end)
BDD=FT:AddDropdown("FarmBrainrots",{Title="Brainrots",Description="Leeg=alle",Values=M.getBrainrotNamesMulti(M.S.TargetRarity),Default={},Multi=true})
BDD:OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end M.S.SelectedBrainrots=s end)
FT:AddDropdown("FarmMutation",{Title="Mutatie",Values=MUT,Default="None",Multi=false}):OnChanged(function(v) M.S.TargetMutation=v end)
FT:AddDropdown("FarmMode",{Title="Mode",Values=FM,Default=M.S.FarmMode,Multi=false}):OnChanged(function(v) M.S.FarmMode=v end)
FT:AddDropdown("FarmSlot",{Title="Slot",Values=SL,Default=M.S.FarmSlot,Multi=false}):OnChanged(function(v) M.S.FarmSlot=v end)
FT:AddSlider("FarmMaxLevel",{Title="Max Level",Default=M.S.MaxLevel,Min=1,Max=500,Rounding=0}):OnChanged(function(v) M.S.MaxLevel=math.floor(v) end)
local FSP=FT:AddParagraph({Title="Status",Content="Idle"})
local FPP=FT:AddParagraph({Title="Stats",Content="P:0|U:0"})
local FTG=FT:AddToggle("FarmToggle",{Title="ðŸš€ Auto Farm",Default=false}) FTG:OnChanged(function(v) if v then M.findBase() M.startFarming() else M.stopFarming() end end)

FT:AddParagraph({Title="ðŸŽ² Lucky Blocks",Content=""})
FT:AddDropdown("LBRarity",{Title="Rarity",Values=LBR,Default={"Common"},Multi=true}):OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end if #s==0 then s={"Common"} end M.S.LuckyBlockRarity=s end)
FT:AddDropdown("LBMutation",{Title="Mutatie",Values=MUT,Default="Any",Multi=false}):OnChanged(function(v) M.S.LuckyBlockMutation=v end)
local LBSP=FT:AddParagraph({Title="LB Status",Content="Idle"})
local LBTG=FT:AddToggle("LBToggle",{Title="ðŸŽ² Auto LB",Default=false}) LBTG:OnChanged(function(v) if v then M.findBase() M.startLuckyBlockFarm() else M.stopLuckyBlockFarm() end end)

local FCT=W:AddTab({Title="Factory",Icon="hammer"})
FCT:AddDropdown("FactoryRarity",{Title="Rarity",Values=FR,Default=M.S.FactoryRarity,Multi=false}):OnChanged(function(v) M.S.FactoryRarity=v end)
FCT:AddDropdown("FactoryMutation",{Title="Mutatie",Values=MUT,Default=M.S.FactoryMutation,Multi=false}):OnChanged(function(v) M.S.FactoryMutation=v end)
FCT:AddDropdown("FactorySlot",{Title="Slot",Values=SL,Default=M.S.FactorySlot,Multi=false}):OnChanged(function(v) M.S.FactorySlot=v end)
FCT:AddSlider("FactoryMaxLevel",{Title="Max Level",Default=M.S.FactoryMaxLevel,Min=1,Max=500,Rounding=0}):OnChanged(function(v) M.S.FactoryMaxLevel=math.floor(v) end)
local FCSP=FCT:AddParagraph({Title="Status",Content="Idle"})
local FCTG=FCT:AddToggle("FactoryToggle",{Title="ðŸ” Factory",Default=false}) FCTG:OnChanged(function(v) if v then M.findBase() M.startFactoryLoop() else M.stopFactoryLoop() end end)

local ET=W:AddTab({Title="Events",Icon="party-popper"})
local VSP=ET:AddParagraph({Title="ðŸ’ Valentine",Content="Idle"})
local VTG=ET:AddToggle("ValentineToggle",{Title="ðŸ’ Valentine",Default=false}) VTG:OnChanged(function(v) if v then M.startValentine() else M.stopValentine() end end)
local ASP=ET:AddParagraph({Title="ðŸ•¹ï¸ Arcade",Content="Idle"})
local ATG=ET:AddToggle("ArcadeToggle",{Title="ðŸ•¹ï¸ Arcade",Default=false}) ATG:OnChanged(function(v) if v then M.startArcade() else M.stopArcade() end end)

local AT2=W:AddTab({Title="Auto",Icon="rocket"})
local MSP=AT2:AddParagraph({Title="ðŸ’° Money",Content="Idle"})
local MTG=AT2:AddToggle("MoneyToggle",{Title="ðŸ’° Money",Default=false}) MTG:OnChanged(function(v) if v then M.findBase() M.startMoney() else M.stopMoney() end end)
local USP=AT2:AddParagraph({Title="â¬†ï¸ Upgrade",Content="Idle"})
local UTG=AT2:AddToggle("UpgradeToggle",{Title="â¬†ï¸ Upgrade All",Default=false}) UTG:OnChanged(function(v) if v then M.findBase() M.startAutoUpgrade() else M.stopAutoUpgrade() end end)
local MFSP=AT2:AddParagraph({Title="ðŸ—ºï¸ Map Fixer",Content="Uit"})
local MFTG=AT2:AddToggle("MapToggle",{Title="ðŸ—ºï¸ Map Fixer",Default=false}) MFTG:OnChanged(function(v) if v then M.startMapFixer() else M.stopMapFixer() end end)
AT2:AddButton({Title="ðŸ—ºï¸ Fix 1x",Callback=function() M._lastFixedMapName="" pcall(function() M.mapRunFix() end) end})

AT2:AddParagraph({Title="ðŸ›¡ï¸ God Mode v22",Content="Size.H bug gefixed\nMuren 80 hoog (Y=-10 tot Y=70)\nDikte 6 studs | Kill zone uit"})
AT2:AddDropdown("GodWalkY",{Title="Loop Y",Description="-2=aanbevolen",Values=GODWALKY,Default="-2",Multi=false}):OnChanged(function(v) M.S.GodWalkY=tonumber(v) or -2 if M._isGod then godTeleportUnder() end end)
AT2:AddDropdown("GodFloorY",{Title="Vloer Y",Values=GODFLOORY,Default="-5",Multi=false}):OnChanged(function(v) M.S.GodFloorY=tonumber(v) or -5 end)
local GDSP=AT2:AddParagraph({Title="God Status",Content="Uit"})
local GDTG=AT2:AddToggle("GodToggle",{Title="ðŸ›¡ï¸ God Mode",Default=false})
GDTG:OnChanged(function(v) if v then M.enableGod() Fluent:Notify({Title="God v22",Content="Aan! Size.H bug gefixed\nVloer + muren actief",Duration=5}) else M.disableGod() end end)
AT2:AddButton({Title="ðŸ“ Teleport Onder",Callback=function() if M._isGod then godTeleportUnder() end end})

AT2:AddToggle("InstantToggle",{Title="âš¡ Instant Pickup",Default=true}):OnChanged(function(v) M.S.InstantPickup=v if v then M.setupInstant() end end)
local AFKSP=AT2:AddParagraph({Title="AFK",Content="Uit"})
local AFKTG=AT2:AddToggle("AFKToggle",{Title="ðŸ›¡ï¸ Anti-AFK",Default=false}) AFKTG:OnChanged(function(v) if v then M.startAFK() else M.stopAFK() end end)

local CT=W:AddTab({Title="Config",Icon="settings"})
CT:AddDropdown("TweenSpeed",{Title="Speed",Values=SPD,Default="INSTANT",Multi=false}):OnChanged(function(v) M.S.TweenSpeed=SPM[v] or 9999 end)
CT:AddDropdown("CorridorSpeed",{Title="Corridor",Values=CSPD,Default="1500",Multi=false}):OnChanged(function(v) M.S.CorridorSpeed=tonumber(v) or 1500 end)
CT:AddButton({Title="ðŸ”„ Herlaad",Callback=function() M.S.SelectedBrainrots={} pcall(function() BDD:SetValues(M.getBrainrotNamesMulti(M.S.TargetRarity)) BDD:SetValue({}) end) end})
CT:AddButton({Title="ðŸ  Zoek Base",Callback=function() M.findBase() Fluent:Notify({Title="Base",Content=M.baseGUID or "?",Duration=3}) end})
CT:AddButton({Title="ðŸ“ Home Op",Callback=function() M.setHomePosition() end})
CT:AddButton({Title="ðŸ“‹ Slots",Callback=function() M.findBase() local o=M.findOccupiedSlots() local i="" for _,s in pairs(o) do i=i.."S"..s.slot..":"..s.name.." L"..s.level.."\n" end Fluent:Notify({Title="Slots("..#o..")",Content=#o>0 and i or "Leeg!",Duration=8}) end})
CT:AddButton({Title="ðŸ—‘ï¸ Leeg Slot",Callback=function() M.findBase() M.clearSlot(tonumber(M.S.FarmSlot) or 5) end})
CT:AddButton({Title="ðŸ  Ga Base",Callback=function() M.findBase() M.returnToBase() end})
CT:AddButton({Title="ðŸ›¡ï¸ God Debug",Callback=function()
	local i="God:".. (M._isGod and "AAN" or "UIT").."\nWalk:"..M.S.GodWalkY.." Floor:"..M.S.GodFloorY
	i=i.."\nOrig:"..#M._godOriginalFloors.." God:"..#M._godCreatedParts.." Kill:"..#M._godKillParts
	i=i.."\nMuur H:"..MF.WH.." Y:"..MF.WY.." (".. (MF.WY-MF.WH/2) .." tot ".. (MF.WY+MF.WH/2) ..")"
	i=i.."\nMuur dikte:"..MF.WT
	local hrp=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if hrp then i=i.."\nPlayer Y:"..string.format("%.1f",hrp.Position.Y) end
	Fluent:Notify({Title="God Debug",Content=i,Duration=10}) end})
local IP=CT:AddParagraph({Title="Info",Content="..."})

local ST2=W:AddTab({Title="Settings",Icon="shield"})
SaveManager:SetLibrary(Fluent) InterfaceManager:SetLibrary(Fluent) SaveManager:SetFolder("MzDHub") InterfaceManager:SetFolder("MzDHub")
InterfaceManager:BuildInterfaceSection(ST2) SaveManager:BuildConfigSection(ST2)

task.spawn(function() while task.wait(1) do pcall(function()
	FSP:SetDesc((M.S.Farming and M.Status.farm or "Idle").." | #"..M.Status.farmCount) FPP:SetDesc("P:"..M.Status.placeCount.." U:"..M.Status.upgradeCount)
	if not M.S.Farming then pcall(function() if FTG.Value then FTG:SetValue(false) end end) end
	LBSP:SetDesc((M.S.LuckyBlockEnabled and M.Status.luckyBlock or "Idle").." #"..M.Status.luckyBlockCount)
	if not M.S.LuckyBlockEnabled then pcall(function() if LBTG.Value then LBTG:SetValue(false) end end) end
	FCSP:SetDesc((M.Status.factory or "Idle").." #"..M.Status.factoryCount) if not M.S.FactoryEnabled then pcall(function() if FCTG.Value then FCTG:SetValue(false) end end) end
	VSP:SetDesc((M.S.ValentineEnabled and M.Status.valentine or "Idle").." #"..M.Status.valentineCount) if not M.S.ValentineEnabled then pcall(function() if VTG.Value then VTG:SetValue(false) end end) end
	ASP:SetDesc(M.S.ArcadeEnabled and ("Actief #"..M.Status.arcadeCount) or "Idle") if not M.S.ArcadeEnabled then pcall(function() if ATG.Value then ATG:SetValue(false) end end) end
	MSP:SetDesc(M.S.AutoCollectMoney and "Actief" or "Idle") if not M.S.AutoCollectMoney then pcall(function() if MTG.Value then MTG:SetValue(false) end end) end
	USP:SetDesc((M.S.AutoUpgrade and M.upgradeThread and M.Status.upgrade or "Idle").." #"..M.Status.upgradeCount) if not(M.S.AutoUpgrade and M.upgradeThread) then pcall(function() if UTG.Value then UTG:SetValue(false) end end) end
	MFSP:SetDesc(M.S.MapFixerEnabled and M.Status.mapFixer or "Uit") if not M.S.MapFixerEnabled then pcall(function() if MFTG.Value then MFTG:SetValue(false) end end) end
	AFKSP:SetDesc("AFK:"..M.Status.afk) if not M.S.AntiAFK then pcall(function() if AFKTG.Value then AFKTG:SetValue(false) end end) end
	GDSP:SetDesc(M.Status.god) if not M._isGod then pcall(function() if GDTG.Value then GDTG:SetValue(false) end end) end
	local hrp=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") local curY=hrp and string.format("%.1f",hrp.Position.Y) or "?"
	IP:SetDesc("Player:"..Player.Name.."\nBase:"..(M.baseGUID or "?").."\nGod:"..(M._isGod and("AAN Y="..M.S.GodWalkY.." K:"..#M._godKillParts.." V:"..#M._godCreatedParts) or "UIT").."\nY:"..curY.."\nMuur: Y=".. (MF.WY-MF.WH/2) .." tot ".. (MF.WY+MF.WH/2) .." (H:"..MF.WH.." D:"..MF.WT..")")
end) end end)

task.spawn(function() task.wait(1) M.findBase() task.wait(0.5) M.detectWallZ()
	Fluent:Notify({Title="MzD Hub v11.2",Content="ðŸ›¡ï¸ God v22 - Size.H bug gefixed!\nVloer + muren werken nu âœ“\n1. Map Fixer â†’ 2. God Mode",Duration=6})
end)

W:SelectTab(1)
print("[MzD Hub] v11.2 GELADEN âœ¦ Size.H bug gefixed âœ“")
