getgenv().MzD = {}
local M = getgenv().MzD
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer

M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots")
if not M.ActiveBrainrots then task.spawn(function() M.ActiveBrainrots = workspace:WaitForChild("ActiveBrainrots", 15) end) end
M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks")
if not M.ActiveLuckyBlocks then task.spawn(function() M.ActiveLuckyBlocks = workspace:WaitForChild("ActiveLuckyBlocks", 15) end) end
M.PlotAction = nil
pcall(function() M.PlotAction = game:GetService("ReplicatedStorage"):WaitForChild("Packages",10):WaitForChild("Net",10):WaitForChild("RF/Plot.PlotAction",10) end)

local SCHEMES = {
	Default = {Color3.fromRGB(15,15,15),Color3.fromRGB(255,200,50),Color3.fromRGB(255,215,0),Color3.fromRGB(10,10,10),Color3.fromRGB(255,215,0),Color3.fromRGB(255,200,50)},
	Doom = {Color3.fromRGB(35,0,55),Color3.fromRGB(255,50,0),Color3.fromRGB(255,80,20),Color3.fromRGB(25,0,40),Color3.fromRGB(255,60,0),Color3.fromRGB(255,50,0)},
	Valentine = {Color3.fromRGB(50,0,20),Color3.fromRGB(255,50,150),Color3.fromRGB(255,80,180),Color3.fromRGB(40,0,15),Color3.fromRGB(255,100,180),Color3.fromRGB(255,50,150)},
	Ocean = {Color3.fromRGB(0,15,40),Color3.fromRGB(0,200,255),Color3.fromRGB(50,220,255),Color3.fromRGB(0,10,30),Color3.fromRGB(0,200,255),Color3.fromRGB(0,180,240)},
	Emerald = {Color3.fromRGB(0,30,15),Color3.fromRGB(0,255,100),Color3.fromRGB(50,255,130),Color3.fromRGB(0,20,10),Color3.fromRGB(0,255,100),Color3.fromRGB(0,230,90)},
	Void = {Color3.fromRGB(10,0,25),Color3.fromRGB(150,0,255),Color3.fromRGB(180,50,255),Color3.fromRGB(8,0,20),Color3.fromRGB(150,50,255),Color3.fromRGB(130,0,240)},
	Blood = {Color3.fromRGB(40,0,0),Color3.fromRGB(255,0,0),Color3.fromRGB(255,40,40),Color3.fromRGB(30,0,0),Color3.fromRGB(255,20,20),Color3.fromRGB(220,0,0)},
	White = {Color3.fromRGB(200,200,200),Color3.fromRGB(40,40,40),Color3.fromRGB(60,60,60),Color3.fromRGB(180,180,180),Color3.fromRGB(30,30,30),Color3.fromRGB(50,50,50)},
}
-- [1]=floor [2]=stripe [3]=stripeCenter [4]=wall [5]=wallText [6]=wallStripe

local function detectMapType()
	local mn = ""
	for _,c in pairs(workspace:GetChildren()) do
		if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("Shared") then
			if c:FindFirstChild("Spawners") or c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then mn = c.Name:lower() break end
			local cnt=0 for _,d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then cnt+=1 end if cnt>10 then mn=c.Name:lower() break end end
			if mn~="" then break end
		end
	end
	if mn:find("doom") or workspace:FindFirstChild("DoomEventParts") then return "Doom" end
	if mn:find("valentine") or mn:find("candy") or mn:find("love") then return "Valentine" end
	if mn:find("void") or mn:find("shadow") then return "Void" end
	if mn:find("ocean") or mn:find("beach") then return "Ocean" end
	return "Default"
end

local function getScheme()
	local sn = M.S and M.S.ColorScheme or "Auto"
	if sn == "Auto" then return SCHEMES[detectMapType()] or SCHEMES.Default, detectMapType() end
	return SCHEMES[sn] or SCHEMES.Default, sn
end

M.S = {
	Farming=false, SelectedBrainrots={}, TargetMutation="None", TargetRarity={"Common"},
	TweenSpeed=9999, CorridorSpeed=1500, AutoCollectMoney=false, InstantPickup=true,
	AntiAFK=false, AutoUpgrade=false, MaxLevel=250,
	FactoryEnabled=false, FactorySlot="5", FactoryRarity="Common", FactoryMutation="None", FactoryMaxLevel=250,
	FarmMode="Collect, Place & Max", FarmSlot="5",
	ValentineEnabled=false, ValentineSpeed=300, ArcadeEnabled=false,
	MapFixerEnabled=false, LuckyBlockEnabled=false, LuckyBlockRarity={"Common"}, LuckyBlockMutation="Any",
	GodEnabled=false, GodWalkY=-2, GodFloorY=-5,
	DoomEnabled=false, DoomTowerEnabled=false, DoomTowerOffset=0, ColorScheme="Auto",
}

M.Status = {
	farm="Idle",farmCount=0,money="Idle",afk="Uit",placeCount=0,upgradeCount=0,upgrade="Idle",
	factory="Idle",factoryCount=0,valentine="Idle",valentineCount=0,valentineHearts=0,
	arcade="Idle",arcadeCount=0,mapFixer="Uit",luckyBlock="Idle",luckyBlockCount=0,
	god="Uit",doom="Uit",doomCount=0,doomTower="Uit",colorScheme="Auto",
}

M.baseGUID=nil M.baseCFrame=nil M.homePosition=nil M.farmThread=nil M.factoryThread=nil
M.moneyThread=nil M.moneyRemoteThread=nil M.afkThread=nil M._afkSteppedConn=nil M._instantConn=nil
M.upgradeThread=nil M.valentineThread=nil M.valentineCollectorConn=nil M._valentineDescAddedConn=nil
M.arcadeThread=nil M.mapFixerThread=nil M.lastMapName="" M._valentineCachedParts={}
M._valentineLastCacheScan=0 M._valentineStationCF=nil M._valentineStationObj=nil M.luckyBlockThread=nil
M._isGod=false M._godLoopThread=nil M._godHealthConn=nil M._godDiedConn=nil
M._godOriginalFloors={} M._godCreatedParts={} M._godKillParts={} M._godKillWatchThread=nil M._godFloorCacheTime=0
M._towerMoved=false M._towerOriginalCF=nil M._towerOriginalY=nil M._towerWatchThread=nil
M._towerLastTargetY=nil M._towerDetectedFloorY=nil M._towerDetectedSource=nil
M._doomConn=nil M._doomDescConn=nil M._doomTowerDescConn=nil M._doomCachedParts={}
M._doomLastScan=0 M._doomCollected=0 M._wallZ_front=207 M._wallZ_back=-207 M._lastColorScheme=nil

local HIGH_RARITIES = {Celestial=true,Divine=true,Infinity=true}
local VAL_RARS = {"Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret"}

local function isMzD(o)
	if not o or not o:IsA("BasePart") then return false end
	local n=o.Name if n=="MzDGodFloor" or n=="MzDGodCatchFloor" or n=="MzDGodFloorStripe" then return true end
	local p=o.Parent while p do if p.Name=="MzDHubWalls" then return true end p=p.Parent end
	return false
end

-- TOWER
local function findTower()
	local ok,t=pcall(function() return workspace.GameObjects.PlaceSpecific.root.Tower end)
	if ok and t then return t end
	for _,c in pairs(workspace:GetDescendants()) do if c.Name=="Tower" and c:IsA("Model") then local n=0 for _,d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then n+=1 end if n>5 then return c end end end end
	return nil
end
local function getTowerY() local t=findTower() if not t then return nil end local ok,p=pcall(function() return t:GetPivot() end) return ok and p and p.Position.Y or nil end
local function getTowerBottomY() local t=findTower() if not t then return nil end local m=math.huge for _,p in pairs(t:GetDescendants()) do if p:IsA("BasePart") then local b=p.Position.Y-p.Size.Y/2 if b<m then m=b end end end return m~=math.huge and m or nil end

local function detectFloorY()
	local fl={} local map
	for _,c in pairs(workspace:GetChildren()) do if c:IsA("BasePart") and c.Name=="MzDGodFloor" then table.insert(fl,{y=c.Position.Y+c.Size.Y/2,s="God"}) end end
	for _,c in pairs(workspace:GetChildren()) do if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("Shared") then
		if c:FindFirstChild("Spawners") or c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then map=c break end
		local n=0 for _,d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then n+=1 end if n>10 then map=c break end end if map then break end
	end end
	if map then
		for _,nm in pairs({"FirstFloor","Ground","Floor","BridgeFloor"}) do local f=map:FindFirstChild(nm) if f and f:IsA("BasePart") then table.insert(fl,{y=f.Position.Y+f.Size.Y/2,s=nm}) end end
		local sp=map:FindFirstChild("Spawners") if sp then for _,s in pairs(sp:GetChildren()) do if s:IsA("BasePart") and s.Size.X>15 and s.Size.Z>5 and s.Size.Y<20 and s.Position.Y>-15 and s.Position.Y<30 then table.insert(fl,{y=s.Position.Y+s.Size.Y/2,s="Sp"}) end end end
	end
	local hrp=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then local p=RaycastParams.new() p.FilterType=Enum.RaycastFilterType.Exclude local e={} local t=findTower() if t then table.insert(e,t) end p.FilterDescendantsInstances=e local r=workspace:Raycast(hrp.Position,Vector3.new(0,-100,0),p) if r then table.insert(fl,{y=r.Position.Y,s="Ray"}) end end
	if #fl==0 then return hrp and hrp.Position.Y-3 or 0,"Fb" end
	table.sort(fl,function(a,b) return a.y>b.y end) return fl[1].y,fl[1].s
end

local function moveTower(fy,off)
	local t=findTower() if not t then return false end
	if not M._towerOriginalCF then pcall(function() M._towerOriginalCF=t:GetPivot() end) end
	local by=getTowerBottomY() if not by then return false end
	local dy=fy+off-by if math.abs(dy)<0.3 then return true end
	pcall(function() t:PivotTo(t:GetPivot()*CFrame.new(0,dy,0)) end)
	pcall(function() for _,p in pairs(t:GetDescendants()) do if p:IsA("BasePart") then p.Anchored=true end end end)
	M._towerMoved=true M._towerLastTargetY=fy+off M._towerDetectedFloorY=fy return true
end
local function restoreTower() if not M._towerOriginalCF then return end local t=findTower() if t then pcall(function() t:PivotTo(M._towerOriginalCF) end) end M._towerMoved=false M._towerOriginalCF=nil M._towerLastTargetY=nil end

local function startTowerWatch()
	if M._towerWatchThread then pcall(task.cancel,M._towerWatchThread) end
	M._towerWatchThread=task.spawn(function() while M.S.DoomTowerEnabled and M._towerMoved do pcall(function()
		local t=findTower() if t and M._towerLastTargetY then
			local by=getTowerBottomY() if by and math.abs(by-M._towerLastTargetY)>3 then moveTower(M._towerDetectedFloorY or detectFloorY(),M.S.DoomTowerOffset) end
			for _,p in pairs(t:GetDescendants()) do if p:IsA("BasePart") then p.Anchored=true end end
		end end) task.wait(3) end end)
end

function M.enableTowerDrop()
	M.S.DoomTowerEnabled=true local fy,src=detectFloorY() M._towerDetectedFloorY=fy M._towerDetectedSource=src
	local ok=moveTower(fy,M.S.DoomTowerOffset)
	if ok then startTowerWatch() M.Status.doomTower="Aan (f:"..string.format("%.0f",fy)..")" else M.Status.doomTower="Niet gevonden" end return ok
end
function M.disableTowerDrop() M.S.DoomTowerEnabled=false if M._towerWatchThread then pcall(task.cancel,M._towerWatchThread) M._towerWatchThread=nil end restoreTower() M._towerMoved=false M.Status.doomTower="Uit" end

-- DOOM COLLECTOR
local function fireDoomPrompts(p) if not p then return end for _,d in pairs(p:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration=0 d.MaxActivationDistance=99999 d.RequiresLineOfSight=false end) pcall(function() fireproximityprompt(d) end) end end end

function M.startDoomCollector()
	if M.S.DoomEnabled then return end M.S.DoomEnabled=true M._doomCollected=0
	M._doomCachedParts={} local f=workspace:FindFirstChild("DoomEventParts")
	if f then for _,o in pairs(f:GetDescendants()) do if o:IsA("BasePart") then table.insert(M._doomCachedParts,o) end if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration=0 o.MaxActivationDistance=99999 o.RequiresLineOfSight=false end) end end end
	local t=findTower() if t then for _,o in pairs(t:GetDescendants()) do if o:IsA("BasePart") and o:FindFirstChild("TouchInterest") then table.insert(M._doomCachedParts,o) end end end
	M._doomLastScan=tick()
	local function onNew(d) if not M.S.DoomEnabled then return end
		if d:IsA("BasePart") then table.insert(M._doomCachedParts,d) pcall(function() local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if h then firetouchinterest(h,d,0) firetouchinterest(h,d,1) end end) end
		if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration=0 d.MaxActivationDistance=99999 d.RequiresLineOfSight=false end) pcall(function() fireproximityprompt(d) end) end
	end
	if f then if M._doomDescConn then pcall(function() M._doomDescConn:Disconnect() end) end M._doomDescConn=f.DescendantAdded:Connect(onNew)
	else task.spawn(function() f=workspace:WaitForChild("DoomEventParts",30) if f and M.S.DoomEnabled then for _,o in pairs(f:GetDescendants()) do if o:IsA("BasePart") then table.insert(M._doomCachedParts,o) end end M._doomDescConn=f.DescendantAdded:Connect(onNew) end end) end
	if t then if M._doomTowerDescConn then pcall(function() M._doomTowerDescConn:Disconnect() end) end M._doomTowerDescConn=t.DescendantAdded:Connect(onNew) end
	M._doomConn=RunService.Heartbeat:Connect(function() if not M.S.DoomEnabled then return end pcall(function()
		local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not h then return end
		if tick()-M._doomLastScan>10 then local a={} for _,p in pairs(M._doomCachedParts) do if p and p.Parent then table.insert(a,p) end end M._doomCachedParts=a M._doomLastScan=tick() end
		for _,p in pairs(M._doomCachedParts) do if p and p.Parent then pcall(function() firetouchinterest(h,p,0) firetouchinterest(h,p,1) end) end end
		local f2=workspace:FindFirstChild("DoomEventParts") if f2 then fireDoomPrompts(f2) end local t2=findTower() if t2 then fireDoomPrompts(t2) end
	end) end)
	M.Status.doom="Aan ("..#M._doomCachedParts..")"
end
function M.stopDoomCollector()
	M.S.DoomEnabled=false
	if M._doomConn then pcall(function() M._doomConn:Disconnect() end) M._doomConn=nil end
	if M._doomDescConn then pcall(function() M._doomDescConn:Disconnect() end) M._doomDescConn=nil end
	if M._doomTowerDescConn then pcall(function() M._doomTowerDescConn:Disconnect() end) M._doomTowerDescConn=nil end
	M._doomCachedParts={} M.Status.doom="Uit"
end

-- GOD MODE
local function godFindFloors()
	local fl,map={},nil
	for _,c in pairs(workspace:GetChildren()) do if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("Shared") then
		if c:FindFirstChild("Spawners") or c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then map=c break end
		local n=0 for _,d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then n+=1 end if n>10 then map=c break end end if map then break end
	end end
	local function chk(p) if not p:IsA("BasePart") or isMzD(p) then return end if p.Size.X>15 and p.Size.Z>5 and p.Size.Y<20 and p.Position.Y>-10 and p.Position.Y<30 then table.insert(fl,p) end end
	if map then
		for _,c in pairs(map:GetChildren()) do if c:IsA("BasePart") and not isMzD(c) then local n=c.Name:lower() if n=="firstfloor" or n=="ground" or n=="floor" or n=="bridgefloor" or n=="grass" or n=="path" or n=="platform" then table.insert(fl,c) else chk(c) end end end
		local sp=map:FindFirstChild("Spawners") if sp then for _,s in pairs(sp:GetChildren()) do chk(s) end end
	end
	for _,c in pairs(workspace:GetChildren()) do if c.Name:find("SharedInstances") then local sf=c:FindFirstChild("Floors") if sf then for _,f in pairs(sf:GetChildren()) do chk(f) end end for _,f in pairs(c:GetChildren()) do chk(f) end end end
	return fl,map
end

local function godMapXRange(map)
	local mi,mx=math.huge,-math.huge local found=false
	local function chk(p) if not p:IsA("BasePart") or isMzD(p) or p.Size.Y>p.Size.X and p.Size.Y>p.Size.Z then return end if p.Position.Y>50 or p.Position.Y<-30 or p.Size.X<5 then return end local l=p.Position.X-p.Size.X/2 local r=p.Position.X+p.Size.X/2 if l<mi then mi=l end if r>mx then mx=r end found=true end
	if map then for _,c in pairs(map:GetChildren()) do if c:IsA("BasePart") then chk(c) end end local sp=map:FindFirstChild("Spawners") if sp then for _,s in pairs(sp:GetChildren()) do chk(s) end end end
	for _,c in pairs(workspace:GetChildren()) do if c.Name:find("SharedInstances") then for _,f in pairs(c:GetChildren()) do if f:IsA("BasePart") then chk(f) end end local sf=c:FindFirstChild("Floors") if sf then for _,f in pairs(sf:GetChildren()) do chk(f) end end end end
	return found and mi-20 or -50, found and mx+20 or 4500
end

local function godKillParts()
	M._godKillParts={} local seen={}
	for _,c in pairs(workspace:GetDescendants()) do if c:IsA("BasePart") and not seen[c] and not isMzD(c) then
		local isk=false pcall(function() if c.Size.Y<1 and c.Size.Z>50 and c.Position.Y<5 and c.Position.Y>-5 and c.Size.X<5 then isk=true end end)
		if not isk then local n=c.Name:lower() if n:find("kill") or n:find("deathzone") or n:find("damagezone") then isk=true end end
		if isk then seen[c]=true table.insert(M._godKillParts,{p=c,cc=c.CanCollide,ct=c.CanTouch,sz=c.Size,ps=c.Position,tr=c.Transparency})
			pcall(function() c.CanCollide=false c.CanTouch=false c.Transparency=1 c.Size=Vector3.new(0,0,0) c.Position=Vector3.new(0,-9999,0) end) end
	end end return #M._godKillParts
end
local function godRestoreKill() for _,d in pairs(M._godKillParts) do pcall(function() if d.p and d.p.Parent then d.p.Size=d.sz d.p.Position=d.ps d.p.CanCollide=d.cc d.p.CanTouch=d.ct d.p.Transparency=d.tr end end) end M._godKillParts={} end

local function godKillWatch()
	if M._godKillWatchThread then pcall(task.cancel,M._godKillWatchThread) end
	M._godKillWatchThread=task.spawn(function() while M._isGod do pcall(function()
		for _,d in pairs(M._godKillParts) do if d.p and d.p.Parent then d.p.CanCollide=false d.p.CanTouch=false d.p.Size=Vector3.new(0,0,0) d.p.Position=Vector3.new(0,-9999,0) end end
		for _,c in pairs(workspace:GetDescendants()) do if c:IsA("BasePart") and not isMzD(c) then
			local isk=false pcall(function() if c.Size.Y<1 and c.Size.Z>50 and c.Position.Y<5 and c.Position.Y>-5 and c.Size.X<5 then isk=true end end)
			if not isk then local n=c.Name:lower() if n:find("kill") or n:find("deathzone") then isk=true end end
			if isk then local al=false for _,d in pairs(M._godKillParts) do if d.p==c then al=true break end end
				if not al then table.insert(M._godKillParts,{p=c,cc=c.CanCollide,ct=c.CanTouch,sz=c.Size,ps=c.Position,tr=c.Transparency}) pcall(function() c.CanCollide=false c.CanTouch=false c.Transparency=1 c.Size=Vector3.new(0,0,0) c.Position=Vector3.new(0,-9999,0) end) end
			end
		end end
	end) task.wait(3) end end)
end

local function godBuildFloor(map)
	for _,p in pairs(M._godCreatedParts) do pcall(function() if p and p.Parent then p:Destroy() end end) end M._godCreatedParts={}
	local sc=getScheme() local sx,ex=godMapXRange(map) local fY=M.S.GodFloorY local fW=420 local fT=4 local seg=2000 local cx=sx
	while cx<ex do local sl=math.min(seg,ex-cx) local c=cx+sl/2
		local f=Instance.new("Part") f.Name="MzDGodFloor" f.Size=Vector3.new(sl,fT,fW) f.Position=Vector3.new(c,fY,0) f.Anchored=true f.CanCollide=true f.Color=sc[1] f.Material=Enum.Material.SmoothPlastic f.Transparency=0 f.TopSurface=Enum.SurfaceType.Smooth f.BottomSurface=Enum.SurfaceType.Smooth f.Parent=workspace table.insert(M._godCreatedParts,f)
		local ty=fY+fT/2+0.1
		for _,z in pairs({fW/2-5,-fW/2+5}) do local s=Instance.new("Part") s.Name="MzDGodFloorStripe" s.Size=Vector3.new(sl,0.2,2) s.Position=Vector3.new(c,ty,z) s.Anchored=true s.CanCollide=false s.Color=sc[2] s.Material=Enum.Material.Neon s.Parent=workspace table.insert(M._godCreatedParts,s) end
		local sm=Instance.new("Part") sm.Name="MzDGodFloorStripe" sm.Size=Vector3.new(sl,0.2,1) sm.Position=Vector3.new(c,ty,0) sm.Anchored=true sm.CanCollide=false sm.Color=sc[3] sm.Material=Enum.Material.Neon sm.Parent=workspace table.insert(M._godCreatedParts,sm)
		cx=cx+sl
	end
	local ct=Instance.new("Part") ct.Name="MzDGodCatchFloor" ct.Size=Vector3.new(math.abs(ex-sx)+200,2,fW+100) ct.Position=Vector3.new((sx+ex)/2,fY-15,0) ct.Anchored=true ct.CanCollide=true ct.Transparency=1 ct.Parent=workspace table.insert(M._godCreatedParts,ct)
	M._lastColorScheme=detectMapType()
end

local function recolorGod()
	local sc=getScheme()
	for _,p in pairs(M._godCreatedParts) do if p and p.Parent then pcall(function()
		if p.Name=="MzDGodFloor" then p.Color=sc[1]
		elseif p.Name=="MzDGodFloorStripe" then p.Color=p.Size.Z<1.5 and sc[3] or sc[2] end
	end) end end
	for _,c in pairs(workspace:GetChildren()) do if c:IsA("Model") and c.Name:find("Map") then local mf=c:FindFirstChild("MzDHubWalls") if mf then
		for _,w in pairs(mf:GetChildren()) do if w:IsA("BasePart") then pcall(function()
			if w.Name:find("FS_") or w.Name:find("BS_") then w.Color=sc[6] elseif w.Name:find("Wall") then w.Color=sc[4]
				for _,sg in pairs(w:GetChildren()) do if sg:IsA("SurfaceGui") then for _,tl in pairs(sg:GetChildren()) do if tl:IsA("TextLabel") and tl.Text=="MzD Hub" then tl.TextColor3=sc[5] end end end end
			end
		end) end end
	end end end
	M._lastColorScheme=detectMapType()
end

local function godHideFloors()
	local fl,map=godFindFloors() M._godOriginalFloors={}
	for _,p in pairs(fl) do table.insert(M._godOriginalFloors,{p=p,sz=p.Size,ps=p.Position,cc=p.CanCollide,tr=p.Transparency,cl=p.Color,mt=p.Material,an=p.Anchored}) pcall(function() p.CanCollide=false p.Transparency=1 end) end
	if map then for _,c in pairs(map:GetChildren()) do if c:IsA("BasePart") and c.Name=="BridgeFloor" and not isMzD(c) then table.insert(M._godOriginalFloors,{p=c,sz=c.Size,ps=c.Position,cc=c.CanCollide,tr=c.Transparency,cl=c.Color,mt=c.Material,an=c.Anchored}) pcall(function() c.CanCollide=false c.Transparency=1 end) end end end
	return map
end
local function godRestoreFloors()
	for _,d in pairs(M._godOriginalFloors) do pcall(function() if d.p and d.p.Parent then d.p.Size=d.sz d.p.Position=d.ps d.p.CanCollide=d.cc d.p.Transparency=d.tr d.p.Color=d.cl d.p.Material=d.mt d.p.Anchored=d.an end end) end M._godOriginalFloors={}
	for _,f in pairs(M._godCreatedParts) do pcall(function() if f and f.Parent then f:Destroy() end end) end M._godCreatedParts={}
end
local function godTP() local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if h then h.Velocity=Vector3.new(0,0,0) h.CFrame=CFrame.new(h.Position.X,M.S.GodWalkY,h.Position.Z) end end

local function godLoop()
	if M._godLoopThread then pcall(task.cancel,M._godLoopThread) end
	M._godLoopThread=task.spawn(function() while M._isGod do pcall(function()
		if tick()-M._godFloorCacheTime>5 then for _,d in pairs(M._godOriginalFloors) do if d.p and d.p.Parent then d.p.CanCollide=false d.p.Transparency=1 end end M._godFloorCacheTime=tick() end
		local dt=detectMapType() if dt~=M._lastColorScheme then recolorGod() end
		local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if h and h.Position.Y<M.S.GodWalkY-30 then h.Velocity=Vector3.new(0,0,0) h.CFrame=CFrame.new(h.Position.X,M.S.GodWalkY,h.Position.Z) end
	end) task.wait(0.5) end end)
end

local function godHealth(ch)
	if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) end
	if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) end
	local hum=ch:WaitForChild("Humanoid",5) if not hum then return end
	pcall(function() hum.MaxHealth=math.huge hum.Health=math.huge hum:SetStateEnabled(Enum.HumanoidStateType.Dead,false) end)
	for _,ff in pairs(ch:GetChildren()) do if ff:IsA("ForceField") then ff:Destroy() end end
	local ff=Instance.new("ForceField") ff.Visible=false ff.Parent=ch
	M._godHealthConn=hum:GetPropertyChangedSignal("Health"):Connect(function() if M._isGod then pcall(function() if hum.Health~=math.huge then hum.Health=math.huge end end) end end)
	M._godDiedConn=hum.Died:Connect(function() if M._isGod then task.defer(function() pcall(function() hum:SetStateEnabled(Enum.HumanoidStateType.Dead,false) hum:ChangeState(Enum.HumanoidStateType.GettingUp) hum.MaxHealth=math.huge hum.Health=math.huge end) end) end end)
end

function M.enableGod()
	if M._isGod then return end M._isGod=true M.S.GodEnabled=true M._godFloorCacheTime=0
	local kc=godKillParts() godKillWatch() task.wait(0.1)
	local map=godHideFloors() task.wait(0.1) godBuildFloor(map) task.wait(0.2) godLoop() task.wait(0.1) godTP()
	task.wait(0.1) if Player.Character then godHealth(Player.Character) end
	local ts="" if M.S.DoomTowerEnabled then ts=M.enableTowerDrop() and " Tâœ“" or " Tâœ—" end
	local sc,_=getScheme() M.Status.god="Aan ðŸ›¡ï¸ "..detectMapType().." K:"..kc..ts
end

function M.disableGod()
	M._isGod=false M.S.GodEnabled=false
	if M._godLoopThread then pcall(task.cancel,M._godLoopThread) M._godLoopThread=nil end
	if M._godKillWatchThread then pcall(task.cancel,M._godKillWatchThread) M._godKillWatchThread=nil end
	if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) M._godHealthConn=nil end
	if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) M._godDiedConn=nil end
	godRestoreFloors() godRestoreKill()
	local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if h then h.Velocity=Vector3.new(0,0,0) h.CFrame=CFrame.new(h.Position.X,10,h.Position.Z) end
	local ch=Player.Character if ch then for _,ff in pairs(ch:GetChildren()) do if ff:IsA("ForceField") then ff:Destroy() end end local hum=ch:FindFirstChild("Humanoid") if hum then pcall(function() hum.MaxHealth=100 hum.Health=100 hum:SetStateEnabled(Enum.HumanoidStateType.Dead,true) end) end end
	M.Status.god="Uit"
end

-- EQUIP/HELPERS
function M.safeEquip(t) if not t then return end local ch=Player.Character if not ch then return end local hum=ch:FindFirstChild("Humanoid") if hum then pcall(function() hum:EquipTool(t) end) task.wait(0.4) end end
function M.safeUnequip() local ch=Player.Character if not ch then return end local hum=ch:FindFirstChild("Humanoid") if hum then pcall(function() hum:UnequipTools() end) task.wait(0.2) end end

function M.mapFindCurrentMap()
	for _,c in pairs(workspace:GetChildren()) do if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("Shared") then
		if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or c:FindFirstChild("RightWalls") or c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then return c end
		local n=0 for _,d in pairs(c:GetDescendants()) do if d:IsA("BasePart") then n+=1 end if n>10 then return c end end
	end end return nil
end

function M.detectWallZ() local map=M.mapFindCurrentMap() if not map then return end local mz=map:FindFirstChild("MzDHubWalls") if not mz then return end local fw=mz:FindFirstChild("FrontWall_1") local bw=mz:FindFirstChild("BackWall_1") if fw then M._wallZ_front=fw.Position.Z-fw.Size.Z/2-3 end if bw then M._wallZ_back=bw.Position.Z+bw.Size.Z/2+3 end end
function M.getCorridorZ() M.detectWallZ() local hp=M.getHomePosition().Position return hp.Z>=0 and M._wallZ_front or M._wallZ_back end

function M.findBase()
	local bases=workspace:FindFirstChild("Bases") if not bases then return end
	for _,base in pairs(bases:GetChildren()) do pcall(function() local pn=base.Title.TitleGui.Frame.PlayerName if pn.Text==Player.Name or pn.Text==Player.DisplayName then M.baseGUID=base.Name local s1=base:FindFirstChild("slot 1 brainrot") if s1 and s1:FindFirstChild("Root") then M.baseCFrame=s1.Root.CFrame end end end) end
	if not M.homePosition then M.setHomePosition() end
end
function M.setHomePosition() local ch=Player.Character if not ch then return end local h=ch:FindFirstChild("HumanoidRootPart") if h then M.homePosition=h.CFrame end end
function M.getHomePosition() return M.homePosition or M.baseCFrame or CFrame.new(124,3.8,22) end
task.spawn(function() task.wait(3) M.findBase() end)

Player.CharacterAdded:Connect(function(ch)
	task.wait(1.5) if M.S.InstantPickup then M.setupInstant() end task.wait(0.5) M.detectWallZ()
	if M._isGod then
		if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) end
		if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) end
		task.wait(0.5) godHealth(ch) godKillParts()
		pcall(function() for _,d in pairs(M._godOriginalFloors) do if d.p and d.p.Parent then d.p.CanCollide=false d.p.Transparency=1 end end end)
		task.wait(0.3) godTP()
		if M.S.DoomTowerEnabled and M._towerDetectedFloorY then task.wait(0.5) moveTower(M._towerDetectedFloorY,M.S.DoomTowerOffset) end
	end
end)

-- TWEEN
function M.tweenTo(cf) local ch=Player.Character if not ch then return false end local h=ch:FindFirstChild("HumanoidRootPart") if not h then return false end local tc=cf if M._isGod then tc=CFrame.new(cf.Position.X,M.S.GodWalkY,cf.Position.Z) end local d=(h.Position-tc.Position).Magnitude local tw=TweenService:Create(h,TweenInfo.new(math.max(d/M.S.TweenSpeed,0.01),Enum.EasingStyle.Linear),{CFrame=tc}) tw:Play() tw.Completed:Wait() return true end
function M.fastTween(cf) local ch=Player.Character if not ch then return false end local h=ch:FindFirstChild("HumanoidRootPart") if not h then return false end local tc=cf if M._isGod then tc=CFrame.new(cf.Position.X,M.S.GodWalkY,cf.Position.Z) end local tw=TweenService:Create(h,TweenInfo.new(math.max((h.Position-tc.Position).Magnitude/99999,0.005),Enum.EasingStyle.Linear),{CFrame=tc}) tw:Play() tw.Completed:Wait() return true end
function M.corridorTween(cf) local ch=Player.Character if not ch then return false end local h=ch:FindFirstChild("HumanoidRootPart") if not h then return false end local tc=cf if M._isGod then tc=CFrame.new(cf.Position.X,M.S.GodWalkY,cf.Position.Z) end local tw=TweenService:Create(h,TweenInfo.new(math.max((h.Position-tc.Position).Magnitude/math.max(M.S.CorridorSpeed,50),0.01),Enum.EasingStyle.Linear),{CFrame=tc}) tw:Play() tw.Completed:Wait() return true end
function M.valentineTween(cf) local ch=Player.Character if not ch then return false end local h=ch:FindFirstChild("HumanoidRootPart") if not h then return false end local tc=cf if M._isGod then tc=CFrame.new(cf.Position.X,M.S.GodWalkY,cf.Position.Z) end local tw=TweenService:Create(h,TweenInfo.new(math.max((h.Position-tc.Position).Magnitude/math.max(M.S.ValentineSpeed or 300,50),0.01),Enum.EasingStyle.Linear),{CFrame=tc}) tw:Play() tw.Completed:Wait() return true end

function M.safePathTo(tc)
	local ch=Player.Character if not ch then return false end local h=ch:FindFirstChild("HumanoidRootPart") if not h then return false end
	local sp=h.Position local ep=tc.Position local SZ=M.getCorridorZ() local SY=M._isGod and M.S.GodWalkY or (M.getHomePosition().Position.Y+8)
	M.fastTween(CFrame.new(sp.X,SY,sp.Z)) task.wait(0.05) M.corridorTween(CFrame.new(sp.X,SY,SZ)) task.wait(0.05) M.corridorTween(CFrame.new(ep.X,SY,SZ)) task.wait(0.05) M.corridorTween(CFrame.new(ep.X,SY,ep.Z)) task.wait(0.05)
	M.tweenTo(M._isGod and CFrame.new(ep.X,M.S.GodWalkY,ep.Z) or tc) task.wait(0.05) return true
end
function M.safeReturnToBase()
	local ch=Player.Character if not ch then return end local h=ch:FindFirstChild("HumanoidRootPart") if not h then return end
	local cp=h.Position local hp=M.getHomePosition().Position M.detectWallZ() local SZ=M.getCorridorZ() local SY=M._isGod and M.S.GodWalkY or (hp.Y+8)
	M.fastTween(CFrame.new(cp.X,SY,cp.Z)) task.wait(0.05) M.corridorTween(CFrame.new(cp.X,SY,SZ)) task.wait(0.05) M.corridorTween(CFrame.new(hp.X,SY,SZ)) task.wait(0.05) M.corridorTween(CFrame.new(hp.X,SY,hp.Z)) task.wait(0.05)
	M.tweenTo(CFrame.new(hp.X,M._isGod and M.S.GodWalkY or hp.Y,hp.Z)) task.wait(0.05)
end
function M.returnToBase() if M._isGod then local hp=M.getHomePosition().Position M.tweenTo(CFrame.new(hp.X,M.S.GodWalkY,hp.Z)) else M.tweenTo(M.getHomePosition()) end task.wait(0.1) end

-- HELPERS
function M.isHighRarity(r) return HIGH_RARITIES[r]==true end
function M.isHighRarityTool(t) return t and HIGH_RARITIES[t:GetAttribute("Rarity") or ""]==true end
function M.isDead() local ch=Player.Character if not ch then return true end local hum=ch:FindFirstChild("Humanoid") return not hum or hum.Health<=0 end
function M.waitForRespawn() if not M.isDead() then return true end local to=tick()+15 while M.isDead() and tick()<to do task.wait(0.2) end task.wait(1) return not M.isDead() end

function M.forceGrabPrompt(target)
	if not target then return end local pr={}
	if target:IsA("ProximityPrompt") then table.insert(pr,target) else for _,d in pairs(target:GetDescendants()) do if d:IsA("ProximityPrompt") then table.insert(pr,d) end end end
	for _,p in pairs(pr) do pcall(function() p.MaxActivationDistance=99999 p.HoldDuration=0 p.RequiresLineOfSight=false end) pcall(function() fireproximityprompt(p) end) task.wait(0.02) pcall(function() fireproximityprompt(p) end) end
	local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if h then local pa=target if pa:IsA("ProximityPrompt") then pa=pa.Parent end if pa and pa:IsA("BasePart") then pcall(function() firetouchinterest(h,pa,0) end) pcall(function() firetouchinterest(h,pa,1) end) end end task.wait(0.02)
end

-- RARITY
function M.getTargetRarities() return type(M.S.TargetRarity)=="table" and M.S.TargetRarity or {M.S.TargetRarity} end
function M.rarityMatches(fn) for _,r in pairs(M.getTargetRarities()) do if r=="Any" or r==fn then return true end end return false end
function M.getBrainrotNames(rarity)
	local nm,seen={},{}
	if not M.ActiveBrainrots then M.ActiveBrainrots=workspace:FindFirstChild("ActiveBrainrots") end
	if not M.ActiveBrainrots then return nm end
	for _,f in pairs(M.ActiveBrainrots:GetChildren()) do if f:IsA("Folder") and (rarity=="Any" or f.Name==rarity) then for _,b in pairs(f:GetChildren()) do
		local n=nil if b:FindFirstChild("RenderedBrainrot") then n=b.RenderedBrainrot:GetAttribute("BrainrotName") elseif b.Name=="RenderedBrainrot" then n=b:GetAttribute("BrainrotName") else n=b:GetAttribute("BrainrotName") or b.Name end
		if n and n~="" and not seen[n] then seen[n]=true table.insert(nm,n) end
	end end end table.sort(nm) return nm
end
function M.getBrainrotNamesMulti(rars)
	if type(rars)~="table" then return M.getBrainrotNames(rars) end
	local nm,seen={},{} for _,r in pairs(rars) do if r=="Any" then return M.getBrainrotNames("Any") end end
	for _,r in pairs(rars) do for _,n in pairs(M.getBrainrotNames(r)) do if not seen[n] then seen[n]=true table.insert(nm,n) end end end table.sort(nm) return nm
end
function M.matchesFilter(b,fr)
	if not M.rarityMatches(fr) then return false end if M.isHighRarity(fr) then return true end
	local mut=b:GetAttribute("Mutation") or "None" local isN=(mut:lower()=="none" or mut=="")
	if M.S.TargetMutation=="None" then if not isN then return false end elseif M.S.TargetMutation~="Any" then if mut~=M.S.TargetMutation then return false end end
	if #M.S.SelectedBrainrots>0 then local bn=b:GetAttribute("BrainrotName") or "" local fd=false for _,s in pairs(M.S.SelectedBrainrots) do if s==bn then fd=true break end end if not fd then return false end end
	return true
end
function M.toolMatchesRarity(tool,tr,tm)
	local tM=tool:GetAttribute("Mutation") or "None" local lv=tonumber(tool:GetAttribute("Level")) or 0
	local bn=tool:GetAttribute("BrainrotName") local tR=tool:GetAttribute("Rarity")
	if not bn or bn=="" or lv>=M.S.MaxLevel then return false end
	if tR and M.isHighRarity(tR) then local rs=type(tr)=="table" and tr or {tr} for _,r in pairs(rs) do if r=="Any" or r==tR then return true end end return false end
	if tm=="None" then if not (tM:lower()=="none" or tM=="") then return false end elseif tm~="Any" then if tM~=tm then return false end end
	local rs=type(tr)=="table" and tr or {tr} local any=false for _,r in pairs(rs) do if r=="Any" then any=true break end end
	if not any then if tR and tR~="" then local m=false for _,r in pairs(rs) do if tR==r then m=true break end end if not m then return false end else local wl={} for _,r in pairs(rs) do for _,n in pairs(M.getBrainrotNames(r)) do wl[n]=true end end if not wl[bn] then return false end end end
	return true
end

function M.getAvailableMutations()
	local ms={"Any","None"} local seen={Any=true,None=true}
	pcall(function() local mf=game:GetService("ReplicatedStorage"):FindFirstChild("Assets") if mf then mf=mf:FindFirstChild("Mutations") if mf then for _,m in pairs(mf:GetChildren()) do if not seen[m.Name] then seen[m.Name]=true table.insert(ms,m.Name) end end end end end)
	for _,m in pairs({"Emerald","Gold","Blood","Diamond","Rainbow","Shadow","Crystal","Void","Doom"}) do if not seen[m] then seen[m]=true table.insert(ms,m) end end return ms
end
function M.getAvailableRarities()
	local rs,seen={},{}
	for _,r in pairs({"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity"}) do if not seen[r] then seen[r]=true table.insert(rs,r) end end
	pcall(function() if M.ActiveBrainrots then for _,f in pairs(M.ActiveBrainrots:GetChildren()) do if f:IsA("Folder") and not seen[f.Name] then seen[f.Name]=true table.insert(rs,f.Name) end end end end)
	return rs
end

-- SLOTS & REMOTES
function M.isSlotEmpty(s) if not M.baseGUID then M.findBase() end if not M.baseGUID then return true end local mb=workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return true end local sm=mb:FindFirstChild("slot "..s.." brainrot") if not sm then return true end local bn=sm:GetAttribute("BrainrotName") return not bn or bn=="" end
function M.findOccupiedSlots() if not M.baseGUID then M.findBase() end if not M.baseGUID then return {} end local mb=workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return {} end local o={} for i=1,40 do local sm=mb:FindFirstChild("slot "..i.." brainrot") if sm then local bn=sm:GetAttribute("BrainrotName") local lv=sm:GetAttribute("Level") if bn and bn~="" then table.insert(o,{slot=i,name=bn,level=lv or 1}) end end end return o end

local _lastPC=0 local PC=0.15
local function tPA(...) local n=tick() if n-_lastPC<PC then task.wait(PC-(n-_lastPC)) end _lastPC=tick() if not M.PlotAction then return false end return pcall(function() M.PlotAction:InvokeServer(...) end) end

function M.placeBrainrot(s) if not M.baseGUID then return false end local ok=tPA("Place Brainrot",M.baseGUID,tostring(s)) if ok then M.Status.placeCount+=1 end return ok end
function M.pickUpBrainrot(s) if not M.baseGUID then return false end return tPA("Pick Up Brainrot",M.baseGUID,tostring(s)) end
function M.clearSlot(s) if not M.baseGUID then return end tPA("Pick Up Brainrot",M.baseGUID,tostring(s)) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
function M.upgradeBrainrot(s) if not M.baseGUID then return false end return tPA("Upgrade Brainrot",M.baseGUID,tostring(s)) end

function M.tweenToSlot(sn)
	if not M.baseGUID then M.findBase() end if not M.baseGUID then return false end
	local mb=workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return false end
	local sm=mb:FindFirstChild("slot "..sn.." brainrot") if not sm then return false end
	local r=sm:FindFirstChild("Root") if r and r:IsA("BasePart") then return M.tweenTo(r.CFrame*CFrame.new(0,3,0)) end
	local ok,pos=pcall(function() return sm:GetPivot() end) if ok and pos then return M.tweenTo(pos*CFrame.new(0,3,0)) end return false
end
function M.upgradeSlotToMax(slot)
	if not M.baseGUID then M.findBase() end if not M.baseGUID then return end
	local mb=workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) if not mb then return end
	local sm=mb:FindFirstChild("slot "..slot.." brainrot") if not sm then return end
	local cur=tonumber(sm:GetAttribute("Level")) or 1 local fails=0
	while cur<M.S.MaxLevel and M.S.AutoUpgrade do M.upgradeBrainrot(slot) task.wait(0.15) local nw=tonumber(sm:GetAttribute("Level")) or cur if nw>cur then fails=0 cur=nw M.Status.upgradeCount+=1 else fails+=1 if fails>=60 then break end end end
end

function M.findBrainrotRoot(b)
	local r=b:FindFirstChild("Root") if r and r:IsA("BasePart") then return r end
	local rd=b:FindFirstChild("RenderedBrainrot") if rd then local rr=rd:FindFirstChild("Root") if rr and rr:IsA("BasePart") then return rr end end
	for _,d in pairs(b:GetDescendants()) do if d:IsA("BasePart") then return d end end
	return b:IsA("BasePart") and b or nil
end
function M.findTargetToolInBackpack()
	local bp=Player:FindFirstChild("Backpack") if bp then for _,t in pairs(bp:GetChildren()) do if t:IsA("Tool") and M.toolMatchesRarity(t,M.S.TargetRarity,M.S.TargetMutation) then return t end end end
	local ch=Player.Character if ch then local eq=ch:FindFirstChildWhichIsA("Tool") if eq and M.toolMatchesRarity(eq,M.S.TargetRarity,M.S.TargetMutation) then return eq end end return nil
end

-- FARMING
function M.startFarming()
	if M.farmThread then return end M.S.Farming=true M.Status.farmCount=0
	M.setHomePosition() M.detectWallZ() M.returnToBase() M.enableGod()
	M.farmThread=task.spawn(function() while M.S.Farming do local ok=pcall(function()
		if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() task.wait(0.5) return end
		local ch=Player.Character local hum=ch and ch:FindFirstChild("Humanoid") if not ch or not hum then task.wait(1) return end
		if not M.baseGUID then M.findBase() end if not M.baseGUID then task.wait(2) return end
		local ws=tonumber(M.S.FarmSlot) or 5

		if M.S.FarmMode=="Collect" then
			if not M.ActiveBrainrots then M.ActiveBrainrots=workspace:FindFirstChild("ActiveBrainrots") end
			if M.ActiveBrainrots then for _,folder in pairs(M.ActiveBrainrots:GetChildren()) do if not M.S.Farming then break end
				if folder:IsA("Folder") and M.rarityMatches(folder.Name) then for _,b in pairs(folder:GetChildren()) do if not M.S.Farming or M.isDead() then break end
					if M.matchesFilter(b,folder.Name) then local root=M.findBrainrotRoot(b) if not root then continue end
						M.safePathTo(root.CFrame*CFrame.new(0,3,0))
						for a=1,5 do if not M.S.Farming then break end if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() if root and root.Parent then M.safePathTo(root.CFrame*CFrame.new(0,3,0)) else break end end
							if root and root.Parent then M.forceGrabPrompt(root) M.forceGrabPrompt(b) task.wait(0.3) M.Status.farmCount+=1 break else break end end
						M.safeUnequip() task.wait(0.1) M.safeReturnToBase()
			end end end end end task.wait(1) return end

		if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
		local tool=M.findTargetToolInBackpack()
		if tool and M.isHighRarityTool(tool) then M.Status.farm="âœ“ "..(tool:GetAttribute("Rarity") or "High") M.Status.farmCount+=1 task.wait(0.5) tool=nil end
		if not tool then local found=false
			if not M.ActiveBrainrots then M.ActiveBrainrots=workspace:FindFirstChild("ActiveBrainrots") end
			if M.ActiveBrainrots then for _,folder in pairs(M.ActiveBrainrots:GetChildren()) do if not M.S.Farming then break end
				if folder:IsA("Folder") and M.rarityMatches(folder.Name) then for _,b in pairs(folder:GetChildren()) do if not M.S.Farming or M.isDead() then break end
					if M.matchesFilter(b,folder.Name) then local root=M.findBrainrotRoot(b) if not root then continue end found=true
						M.Status.farm="Ophalen "..folder.Name M.safePathTo(root.CFrame*CFrame.new(0,3,0))
						for a=1,5 do if not M.S.Farming then break end if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() if not M.S.Farming then break end if root and root.Parent then M.safePathTo(root.CFrame*CFrame.new(0,3,0)) else found=false break end end
							if root and root.Parent then M.forceGrabPrompt(root) M.forceGrabPrompt(b) task.wait(0.3) M.Status.farmCount+=1 break else found=false break end end
						M.safeUnequip() task.wait(0.1) M.safeReturnToBase() break
			end end end if found then break end end end
			if not found then M.Status.farm="Wachten..." task.wait(2) return end
			task.wait(0.3) tool=M.findTargetToolInBackpack() if not tool then task.wait(1) return end
		end
		if M.isHighRarityTool(tool) then M.Status.farm="âœ“ High" M.Status.farmCount+=1 task.wait(0.5) return end
		local bName=tool:GetAttribute("BrainrotName") or "Brainrot"
		M.tweenToSlot(ws) task.wait(0.3) M.safeEquip(tool) task.wait(0.5) M.placeBrainrot(ws) task.wait(0.8)
		if M.isSlotEmpty(ws) then M.safeUnequip() task.wait(1) return end
		local mb=workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) local sm=mb and mb:FindFirstChild("slot "..ws.." brainrot")
		if sm then local cur=tonumber(sm:GetAttribute("Level")) or 0 local fails=0
			while cur<M.S.MaxLevel and M.S.Farming do M.upgradeBrainrot(ws) task.wait(0.15) local nw=tonumber(sm:GetAttribute("Level")) or cur if nw>cur then fails=0 cur=nw M.Status.upgradeCount+=1 M.Status.farm=bName.." Lv."..cur.."/"..M.S.MaxLevel else fails+=1 if fails>60 then break end end end
		end
		task.wait(0.3) M.pickUpBrainrot(ws) task.wait(0.8) M.safeUnequip() task.wait(0.3)
		if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(0.5) M.safeUnequip() task.wait(0.3) end
	end) if not ok then task.wait(1) end task.wait(0.3) end M.disableGod() M.Status.farm="Idle" M.farmThread=nil end)
end
function M.stopFarming() M.S.Farming=false if M.farmThread then pcall(task.cancel,M.farmThread) M.farmThread=nil end M.disableGod() M.Status.farm="Idle" end

-- FACTORY
local function fTMR(tool)
	local tM=tool:GetAttribute("Mutation") or "None" local lv=tonumber(tool:GetAttribute("Level")) or 0
	local bn=tool:GetAttribute("BrainrotName") local tR=tool:GetAttribute("Rarity")
	if not bn or bn=="" or lv>=M.S.FactoryMaxLevel then return false end
	if M.S.FactoryMutation=="None" then if not (tM:lower()=="none" or tM=="") then return false end elseif M.S.FactoryMutation~="Any" then if tM~=M.S.FactoryMutation then return false end end
	if M.S.FactoryRarity~="Any" then if tR and tR~="" then if tR~=M.S.FactoryRarity then return false end else local wl={} for _,n in pairs(M.getBrainrotNames(M.S.FactoryRarity)) do wl[n]=true end if not wl[bn] then return false end end end
	return true
end
function M.startFactoryLoop()
	if M.factoryThread then return end M.S.FactoryEnabled=true M.Status.factoryCount=0
	M.factoryThread=task.spawn(function() local sr="Idle" while M.S.FactoryEnabled do local ok=pcall(function()
		if not M.baseGUID then M.findBase() end if not M.baseGUID then task.wait(2) return end local ws=tonumber(M.S.FactorySlot) or 5
		M.tweenToSlot(ws) task.wait(0.2) if not M.isSlotEmpty(ws) then M.pickUpBrainrot(ws) task.wait(1) pcall(function() Player.Character.Humanoid:UnequipTools() end) task.wait(0.5) end
		local tool=nil local sa=0 while not tool and sa<5 do sa+=1
			local bp=Player:FindFirstChild("Backpack") if bp then for _,t in pairs(bp:GetChildren()) do if t:IsA("Tool") and fTMR(t) then tool=t break end end end
			if not tool and Player.Character then local eq=Player.Character:FindFirstChildWhichIsA("Tool") if eq and fTMR(eq) then tool=eq end end
			if not tool and sa<5 then task.wait(0.6) end end
		if not tool then sr="Klaar! âœ“" M.S.FactoryEnabled=false return end
		local bN=tool:GetAttribute("BrainrotName") or "Item" local hum=Player.Character and Player.Character:FindFirstChild("Humanoid")
		if hum then hum:EquipTool(tool) task.wait(0.5) end M.placeBrainrot(ws) task.wait(0.8)
		if M.isSlotEmpty(ws) then pcall(function() if hum then hum:UnequipTools() end end) task.wait(1) return end
		local mb=workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) local sm=mb and mb:FindFirstChild("slot "..ws.." brainrot")
		if sm then local cur=tonumber(sm:GetAttribute("Level")) or 0 local fails=0
			while cur<M.S.FactoryMaxLevel and M.S.FactoryEnabled do M.upgradeBrainrot(ws) task.wait(0.1) local nw=tonumber(sm:GetAttribute("Level")) or cur if nw>cur then fails=0 cur=nw M.Status.factory=bN.." Lv."..cur.."/"..M.S.FactoryMaxLevel else fails+=1 if fails>60 then sr="Geld op!" M.S.FactoryEnabled=false break end end end
		end
		task.wait(0.5) M.pickUpBrainrot(ws) task.wait(1.2) M.Status.factoryCount+=1 pcall(function() if hum then hum:UnequipTools() end end) task.wait(0.5) M.Status.factory="âœ“ "..bN.." (#"..M.Status.factoryCount..")"
	end) if not ok then task.wait(1) end end M.Status.factory=sr M.factoryThread=nil end)
end
function M.stopFactoryLoop() M.S.FactoryEnabled=false if M.factoryThread then pcall(task.cancel,M.factoryThread) M.factoryThread=nil end if not (string.find(M.Status.factory or "","âœ“") or string.find(M.Status.factory or "","Klaar") or string.find(M.Status.factory or "","Geld op")) then M.Status.factory="Idle" end end

-- LUCKY BLOCKS
function M.startLuckyBlockFarm()
	if M.luckyBlockThread then return end M.S.LuckyBlockEnabled=true M.Status.luckyBlockCount=0 M.setHomePosition() M.enableGod()
	M.luckyBlockThread=task.spawn(function() while M.S.LuckyBlockEnabled do local ok=pcall(function()
		if M.isDead() then M.waitForRespawn() task.wait(1) M.setHomePosition() M.enableGod() return end
		if not M.ActiveLuckyBlocks then M.ActiveLuckyBlocks=workspace:FindFirstChild("ActiveLuckyBlocks") end if not M.ActiveLuckyBlocks then task.wait(3) return end
		local lbr=type(M.S.LuckyBlockRarity)=="table" and M.S.LuckyBlockRarity or {M.S.LuckyBlockRarity}
		local found=false
		for _,block in pairs(M.ActiveLuckyBlocks:GetChildren()) do if not M.S.LuckyBlockEnabled or M.isDead() then break end
			local rm=false for _,r in pairs(lbr) do if r=="Any" or block.Name:find(r) or block.Name==r then rm=true break end end
			if rm then local mut=block:GetAttribute("Mutation") or "None" local isN=(mut:lower()=="none" or mut=="")
				local mm=M.S.LuckyBlockMutation=="Any" or (M.S.LuckyBlockMutation=="None" and isN) or mut==M.S.LuckyBlockMutation
				if mm then local root=M.findBrainrotRoot(block) if not root then continue end found=true
					M.safePathTo(root.CFrame*CFrame.new(0,3,0))
					for _,d in pairs(block:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.MaxActivationDistance=99999 d.HoldDuration=0 d.RequiresLineOfSight=false end) pcall(function() fireproximityprompt(d) end) end end
					local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
					if h then if root:IsA("BasePart") then pcall(function() firetouchinterest(h,root,0) firetouchinterest(h,root,1) end) end for _,d in pairs(block:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(h,d,0) firetouchinterest(h,d,1) end) end end end
					local t=tick() while tick()-t<0.2 do if not block.Parent or not root.Parent then break end task.wait(0.02) end
					if not block.Parent or not root.Parent then M.Status.luckyBlockCount+=1 end
					M.safeUnequip() M.safeReturnToBase() break
		end end end if not found then task.wait(2) end
	end) task.wait(0.1) end M.disableGod() M.Status.luckyBlock="Idle" M.luckyBlockThread=nil end)
end
function M.stopLuckyBlockFarm() M.S.LuckyBlockEnabled=false if M.luckyBlockThread then pcall(task.cancel,M.luckyBlockThread) M.luckyBlockThread=nil end M.disableGod() M.Status.luckyBlock="Idle" end

-- MONEY
function M.startMoney()
	if M.moneyThread then return end M.S.AutoCollectMoney=true M.Status.money="Actief" if not M.baseGUID then M.findBase() end
	M.moneyThread=task.spawn(function() while M.S.AutoCollectMoney do pcall(function() if not M.baseGUID then M.findBase() end if not M.baseGUID then return end local mb=workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID) local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not mb or not h then return end for i=1,40 do local sm=mb:FindFirstChild("slot "..i.." brainrot") if sm and sm:GetAttribute("BrainrotName") and sm:GetAttribute("BrainrotName")~="" then for _,d in pairs(sm:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(h,d,0) firetouchinterest(h,d,1) end) end end end end end) task.wait(0.5) end M.Status.money="Idle" end)
	M.moneyRemoteThread=task.spawn(function() while M.S.AutoCollectMoney do pcall(function() if M.baseGUID and M.PlotAction then for i=1,40 do if not M.S.AutoCollectMoney then break end tPA("Collect Money",M.baseGUID,tostring(i)) end end end) task.wait(5) end end)
end
function M.stopMoney() M.S.AutoCollectMoney=false if M.moneyThread then pcall(task.cancel,M.moneyThread) M.moneyThread=nil end if M.moneyRemoteThread then pcall(task.cancel,M.moneyRemoteThread) M.moneyRemoteThread=nil end M.Status.money="Idle" end

-- AUTO UPGRADE
function M.startAutoUpgrade() if M.upgradeThread then return end M.S.AutoUpgrade=true M.Status.upgradeCount=0 M.upgradeThread=task.spawn(function() while M.S.AutoUpgrade do pcall(function() for _,info in pairs(M.findOccupiedSlots()) do if not M.S.AutoUpgrade then break end if info.level<M.S.MaxLevel then M.upgradeSlotToMax(info.slot) end end M.Status.upgrade="Klaar (#"..M.Status.upgradeCount..")" end) task.wait(5) end M.Status.upgrade="Idle" end) end
function M.stopAutoUpgrade() M.S.AutoUpgrade=false if M.upgradeThread then pcall(task.cancel,M.upgradeThread) M.upgradeThread=nil end M.Status.upgrade="Idle" end

-- ANTI AFK
function M.startAFK() if M.afkThread then return end M.S.AntiAFK=true M.Status.afk="Actief" pcall(function() for _,c in pairs(getconnections(Player.Idled)) do c:Disable() end end) pcall(function() local vu=game:GetService("VirtualUser") M._afkSteppedConn=RunService.Stepped:Connect(function() if M.S.AntiAFK then pcall(function() vu:CaptureController() vu:ClickButton2(Vector2.new()) end) end end) end) M.afkThread=task.spawn(function() while M.S.AntiAFK do pcall(function() for _,c in pairs(getconnections(Player.Idled)) do c:Disable() end end) task.wait(300) end M.Status.afk="Uit" end) end
function M.stopAFK() M.S.AntiAFK=false if M.afkThread then pcall(task.cancel,M.afkThread) M.afkThread=nil end if M._afkSteppedConn then pcall(function() M._afkSteppedConn:Disconnect() end) M._afkSteppedConn=nil end M.Status.afk="Uit" end

-- INSTANT PICKUP
function M.setupInstant() for _,o in pairs(workspace:GetDescendants()) do if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration=0 end) end end if not M._instantConn then M._instantConn=workspace.DescendantAdded:Connect(function(o) if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration=0 end) end end) end end
M.setupInstant()

-- VALENTINE v2
function M.getHeartCount()
	local c=0 pcall(function() local ls=Player:FindFirstChild("leaderstats") if ls then for _,v in pairs(ls:GetChildren()) do local n=v.Name:lower() if n:find("heart") or n:find("candy") or n:find("valentine") or n:find("gram") then c=tonumber(v.Value) or 0 return end end end end)
	if c==0 then pcall(function() for _,a in pairs({"Hearts","Candy","CandyGrams","Valentines","Love","CandyHearts"}) do local v=Player:GetAttribute(a) if v and tonumber(v) and tonumber(v)>0 then c=tonumber(v) return end end end) end return c
end

function M.findValentineStation()
	local kw={"candygram","station","submit","deposit","exchange","mailbox","postbox","valentine"} local best,bd=nil,math.huge
	for _,obj in pairs(workspace:GetDescendants()) do local n=obj.Name:lower() local match=false for _,k in pairs(kw) do if n:find(k) then match=true break end end
		if match then local hp=false
			if obj:IsA("BasePart") or obj:IsA("Model") then for _,d in pairs(obj:GetDescendants()) do if d:IsA("ProximityPrompt") then hp=true break end end end
			if obj:IsA("ProximityPrompt") then hp=true end
			if hp then local pos=nil if obj:IsA("BasePart") then pos=obj.Position elseif obj:IsA("Model") then pcall(function() pos=obj:GetPivot().Position end) if not pos then for _,d in pairs(obj:GetDescendants()) do if d:IsA("BasePart") then pos=d.Position break end end end
				elseif obj:IsA("ProximityPrompt") and obj.Parent and obj.Parent:IsA("BasePart") then pos=obj.Parent.Position end
				if pos then local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") local dist=h and (h.Position-pos).Magnitude or 0 if not best or dist<bd then best=obj bd=dist M._valentineStationCF=CFrame.new(pos) M._valentineStationObj=obj end end
	end end end return best
end

function M.submitAtStation()
	local st=M._valentineStationObj or M.findValentineStation() if not st then return false end
	local tc=M._valentineStationCF if tc then if M._isGod then M.valentineTween(CFrame.new(tc.Position.X,M.S.GodWalkY,tc.Position.Z)) else M.valentineTween(tc*CFrame.new(0,3,0)) end task.wait(0.5) end
	local fired=false
	local function fp(obj) if obj:IsA("ProximityPrompt") then pcall(function() obj.HoldDuration=0 obj.MaxActivationDistance=99999 obj.RequiresLineOfSight=false end) pcall(function() fireproximityprompt(obj) end) fired=true end for _,d in pairs(obj:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration=0 d.MaxActivationDistance=99999 d.RequiresLineOfSight=false end) pcall(function() fireproximityprompt(d) end) fired=true end end end
	fp(st) if st.Parent then fp(st.Parent) end
	local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if h then local function ta(obj) if obj:IsA("BasePart") then pcall(function() firetouchinterest(h,obj,0) firetouchinterest(h,obj,1) end) end for _,d in pairs(obj:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(h,d,0) firetouchinterest(h,d,1) end) end end end ta(st) if st.Parent and not st.Parent:IsA("Workspace") then ta(st.Parent) end end
	task.wait(0.5) if not fired and h then for _,obj in pairs(workspace:GetDescendants()) do if obj:IsA("ProximityPrompt") and obj.Parent and obj.Parent:IsA("BasePart") and (obj.Parent.Position-h.Position).Magnitude<20 then pcall(function() obj.HoldDuration=0 obj.MaxActivationDistance=99999 obj.RequiresLineOfSight=false end) pcall(function() fireproximityprompt(obj) end) fired=true end end end
	return fired
end

function M.findValentineBrainrots()
	local tg={} if not M.ActiveBrainrots then M.ActiveBrainrots=workspace:FindFirstChild("ActiveBrainrots") end if not M.ActiveBrainrots then return tg end
	for _,folder in pairs(M.ActiveBrainrots:GetChildren()) do if folder:IsA("Folder") then local it=false for _,r in pairs(VAL_RARS) do if folder.Name==r then it=true break end end
		if it then for _,b in pairs(folder:GetChildren()) do local root=M.findBrainrotRoot(b) if root and root:IsA("BasePart") and root.Parent then table.insert(tg,{b=b,r=root,rar=folder.Name,pos=root.Position}) end end end
	end end
	local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if h then table.sort(tg,function(a,b) return (a.pos-h.Position).Magnitude<(b.pos-h.Position).Magnitude end) end return tg
end

function M.startValentine()
	if M.valentineThread then return end M.S.ValentineEnabled=true M.Status.valentineCount=0
	M._valentineCachedParts={} M._valentineLastCacheScan=tick()
	local kw={"heart","candy","valentine","love","gram","pickup","collect","token"}
	for _,obj in pairs(workspace:GetDescendants()) do if obj:IsA("BasePart") then local n=obj.Name:lower() for _,k in pairs(kw) do if n:find(k) then table.insert(M._valentineCachedParts,obj) break end end end end
	M.findValentineStation()
	if M._valentineDescAddedConn then pcall(function() M._valentineDescAddedConn:Disconnect() end) end
	M._valentineDescAddedConn=workspace.DescendantAdded:Connect(function(d) if not M.S.ValentineEnabled then return end
		if d:IsA("BasePart") then local n=d.Name:lower() for _,k in pairs({"heart","candy","valentine","gram","love","token"}) do if n:find(k) then table.insert(M._valentineCachedParts,d) pcall(function() local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if h then firetouchinterest(h,d,0) firetouchinterest(h,d,1) end end) break end end end
		if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration=0 d.MaxActivationDistance=99999 end) end end)
	M.valentineCollectorConn=RunService.Heartbeat:Connect(function() if not M.S.ValentineEnabled then return end pcall(function()
		local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not h then return end
		if tick()-M._valentineLastCacheScan>10 then local a={} for _,p in pairs(M._valentineCachedParts) do if p and p.Parent then table.insert(a,p) end end M._valentineCachedParts=a M._valentineLastCacheScan=tick() end
		for _,p in pairs(M._valentineCachedParts) do if p and p.Parent then firetouchinterest(h,p,0) firetouchinterest(h,p,1) end end end)
	end)
	M.valentineThread=task.spawn(function() while M.S.ValentineEnabled do local ok=pcall(function()
		if M.isDead() then M.waitForRespawn() task.wait(1) return end
		local hearts=M.getHeartCount() M.Status.valentineHearts=hearts
		if hearts>=100 then M.Status.valentine="Submit ("..hearts..")" M.findValentineStation() local prev=hearts
			for a=1,5 do if not M.S.ValentineEnabled then break end M.submitAtStation() task.wait(1.5) local nw=M.getHeartCount() if nw<prev or nw==0 then M.Status.valentineCount+=1 M.Status.valentine="âœ“ #"..M.Status.valentineCount break end task.wait(1) end
			M._valentineCachedParts={} M._valentineLastCacheScan=0 task.wait(0.5) return end
		local brs=M.findValentineBrainrots()
		if #brs==0 then M.Status.valentine="Wachten H:"..hearts task.wait(2) return end
		for _,tg in pairs(brs) do if not M.S.ValentineEnabled or M.isDead() then break end
			local ch=M.getHeartCount() M.Status.valentineHearts=ch if ch>=100 then break end
			M.Status.valentine="â†’ "..tg.rar.." H:"..ch.."/100"
			M.valentineTween(tg.r.CFrame*CFrame.new(0,3,0))
			if tg.r and tg.r.Parent then local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if h then
				pcall(function() firetouchinterest(h,tg.r,0) firetouchinterest(h,tg.r,1) end)
				for _,d in pairs(tg.b:GetDescendants()) do if d:IsA("BasePart") then pcall(function() firetouchinterest(h,d,0) firetouchinterest(h,d,1) end) end end
				for _,d in pairs(tg.b:GetDescendants()) do if d:IsA("ProximityPrompt") then pcall(function() d.HoldDuration=0 d.MaxActivationDistance=99999 end) pcall(function() fireproximityprompt(d) end) end end
			end M.safeUnequip() end task.wait(0.15)
	end end) if not ok then task.wait(1) end task.wait(0.2) end M.Status.valentine="Idle" M.valentineThread=nil end)
end
function M.stopValentine() M.S.ValentineEnabled=false if M.valentineThread then pcall(task.cancel,M.valentineThread) M.valentineThread=nil end if M.valentineCollectorConn then pcall(function() M.valentineCollectorConn:Disconnect() end) M.valentineCollectorConn=nil end if M._valentineDescAddedConn then pcall(function() M._valentineDescAddedConn:Disconnect() end) M._valentineDescAddedConn=nil end M._valentineCachedParts={} M._valentineStationObj=nil M.Status.valentine="Idle" end

-- ARCADE
function M.startArcade() if M.arcadeThread then return end M.S.ArcadeEnabled=true M.Status.arcadeCount=0 M.arcadeThread=task.spawn(function() while M.S.ArcadeEnabled do pcall(function() local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") if not h then return end for _,fn in pairs({"ArcadeEventConsoles","ArcadeEventTickets"}) do local f=workspace:FindFirstChild(fn) if f then for _,item in pairs(f:GetChildren()) do for _,d in pairs(item:GetDescendants()) do if d:IsA("BasePart") and d:FindFirstChild("TouchInterest") then pcall(function() firetouchinterest(h,d,0) task.wait(0.01) firetouchinterest(h,d,1) end) M.Status.arcadeCount+=1 end end end end end end) task.wait(0.05) end M.Status.arcade="Idle" M.arcadeThread=nil end) end
function M.stopArcade() M.S.ArcadeEnabled=false if M.arcadeThread then pcall(task.cancel,M.arcadeThread) M.arcadeThread=nil end M.Status.arcade="Idle" end

-- MAP FIXER
local MF={W=420,WH=80,WT=6,INT=8} MF.SZ=MF.W/2 MF.WY=MF.WH/2-10
local MFR={"RightWalls","LeftWalls","Gaps","VIPWalls","SideWalls","Barriers","Fences","Walls","Decorations"}
local function sdf(p,fn) if not p then return end local f=p:FindFirstChild(fn) if not f or f.Name=="MzDHubWalls" then return end pcall(function() for _,d in pairs(f:GetDescendants()) do if d:IsA("BasePart") then d:Destroy() end end f:Destroy() end) end
local function isWP(p) if not p:IsA("BasePart") or isMzD(p) then return false end local n=p.Name:lower() for _,k in pairs({"vipwall","sidewall","barrier","fence","blocker","border"}) do if n==k or n:find("^"..k) then return true end end if p.Size.Y>15 and p.Size.Y>p.Size.X*3 and p.Size.Y>p.Size.Z*3 and math.abs(p.Position.Z)>60 then return true end return false end

function M.mapDetectXRange(map,si)
	local mi,mx=math.huge,-math.huge local found=false
	local function chk(p) if not p:IsA("BasePart") or isMzD(p) or (p.Size.Y>p.Size.X and p.Size.Y>p.Size.Z) or p.Position.Y>50 or p.Position.Y<-30 or p.Size.X<5 then return end local l=p.Position.X-p.Size.X/2 local r=p.Position.X+p.Size.X/2 if l<mi then mi=l end if r>mx then mx=r end found=true end
	for _,c in pairs(map:GetChildren()) do if c:IsA("BasePart") then chk(c) end end local sp=map:FindFirstChild("Spawners") if sp then for _,s in pairs(sp:GetChildren()) do chk(s) end end
	if si then for _,c in pairs(si:GetChildren()) do if c:IsA("BasePart") then chk(c) end end local sf=si:FindFirstChild("Floors") if sf then for _,f in pairs(sf:GetChildren()) do chk(f) end end end
	return found and mi-5 or -15, found and mx+5 or 4385
end
function M.mapFindShared(mn) return workspace:FindFirstChild(mn.."_SharedInstances") end

local function gfp(map,si)
	local fl={} local function af(p) if not p:IsA("BasePart") or isMzD(p) or (p.Size.Y>p.Size.X and p.Size.Y>p.Size.Z) or p.Position.Y>30 or p.Position.Y<-20 or p.Size.X<5 then return end for _,f in pairs(fl) do if f==p then return end end table.insert(fl,p) end
	local ff=map:FindFirstChild("FirstFloor") if ff and ff:IsA("BasePart") then af(ff) end local gr=map:FindFirstChild("Ground") if gr and gr:IsA("BasePart") then af(gr) end
	local sp=map:FindFirstChild("Spawners") if sp then for _,s in pairs(sp:GetChildren()) do if s:IsA("BasePart") then af(s) end end end
	for _,c in pairs(map:GetChildren()) do if c:IsA("BasePart") then local n=c.Name:lower() if n=="firstfloor" or n=="ground" or n=="bridgefloor" or n=="floor" or n=="grass" or n=="path" or n=="platform" then af(c) elseif c.Size.X>50 and c.Size.Z>10 and c.Size.Y<10 then af(c) end end end
	if si then local sf=si:FindFirstChild("Floors") if sf then for _,f in pairs(sf:GetChildren()) do if f:IsA("BasePart") then af(f) end end end end return fl
end

function M.mapCleanup(map) for _,n in pairs(MFR) do sdf(map,n) end for _,d in pairs(map:GetDescendants()) do if d.Parent and not isMzD(d) and d:IsA("BasePart") and isWP(d) then pcall(function() d:Destroy() end) end end end
function M.mapCleanupShared(si) if not si then return end for _,n in pairs(MFR) do sdf(si,n) end for _,d in pairs(si:GetDescendants()) do if d:IsA("BasePart") and not isMzD(d) and isWP(d) then pcall(function() d:Destroy() end) end end end

function M.mapWidenFloors(map,si) for _,p in pairs(gfp(map,si)) do pcall(function() if math.abs(p.Size.Z-MF.W)>1 then p.Size=Vector3.new(p.Size.X,p.Size.Y,MF.W) p.Position=Vector3.new(p.Position.X,p.Position.Y,0) end end) end end

function M.mapFillGaps(map,sx,ex)
	local ref=nil local ff=map:FindFirstChild("FirstFloor") if ff and ff:IsA("BasePart") then ref=ff end
	if not ref then local g=map:FindFirstChild("Ground") if g and g:IsA("BasePart") then ref=g end end
	if not ref then local sp=map:FindFirstChild("Spawners") if sp then for _,s in pairs(sp:GetChildren()) do if s:IsA("BasePart") then ref=s break end end end end
	if not ref then for _,c in pairs(map:GetChildren()) do if c:IsA("BasePart") and not isMzD(c) and c.Size.X>50 and c.Size.Y<10 and c.Position.Y<20 then ref=c break end end end
	if not ref then return end local fY,fH,fC,fM=ref.Position.Y,ref.Size.Y,ref.Color,ref.Material
	for _,c in pairs(map:GetChildren()) do if c:IsA("BasePart") and c.Name=="BridgeFloor" then pcall(function() c:Destroy() end) end end
	local cx=sx while cx<ex do local sl=math.min(2000,ex-cx) local b=Instance.new("Part") b.Name="BridgeFloor" b.Size=Vector3.new(sl,fH,MF.W) b.Position=Vector3.new(cx+sl/2,fY,0) b.Anchored=true b.CanCollide=true b.Color=fC b.Material=fM b.TopSurface=Enum.SurfaceType.Smooth b.BottomSurface=Enum.SurfaceType.Smooth b.Parent=map cx=cx+sl end
end

function M.mapBuildWalls(map,sx,ex)
	local sc=getScheme() local mf=map:FindFirstChild("MzDHubWalls") if mf then pcall(function() mf:Destroy() end) end
	mf=Instance.new("Folder") mf.Name="MzDHubWalls" mf.Parent=map
	local function mw(nm,sz,ps) local w=Instance.new("Part") w.Name=nm w.Size=sz w.Position=ps w.Anchored=true w.CanCollide=true w.Color=sc[4] w.Material=Enum.Material.SmoothPlastic w.TopSurface=Enum.SurfaceType.Smooth w.BottomSurface=Enum.SurfaceType.Smooth w.Parent=mf return w end
	local function ms(nm,sz,ps) local s=Instance.new("Part") s.Name=nm s.Size=sz s.Position=ps s.Anchored=true s.CanCollide=false s.Color=sc[6] s.Material=Enum.Material.Neon s.Parent=mf end
	local function at(w,f) local sg=Instance.new("SurfaceGui") sg.Face=f sg.CanvasSize=Vector2.new(800,400) sg.Parent=w local t=Instance.new("TextLabel") t.Size=UDim2.new(1,0,0.5,0) t.Position=UDim2.new(0,0,0.1,0) t.BackgroundTransparency=1 t.Text="MzD Hub" t.TextColor3=sc[5] t.TextScaled=true t.Font=Enum.Font.GothamBold t.Parent=sg local s2=Instance.new("TextLabel") s2.Size=UDim2.new(0.6,0,0.2,0) s2.Position=UDim2.new(0.2,0,0.6,0) s2.BackgroundTransparency=1 s2.Text="v12.3" s2.TextColor3=Color3.fromRGB(200,200,200) s2.TextScaled=true s2.Font=Enum.Font.Gotham s2.Parent=sg end
	local segs={} local p=sx while p<ex do local l=math.min(2000,ex-p) table.insert(segs,{s=p,l=l}) p=p+l end
	for i,s in pairs(segs) do local cx=s.s+s.l/2
		local fw=mw("FrontWall_"..i,Vector3.new(s.l,MF.WH,MF.WT),Vector3.new(cx,MF.WY,MF.SZ+MF.WT/2)) at(fw,Enum.NormalId.Front) at(fw,Enum.NormalId.Back)
		ms("FS_t"..i,Vector3.new(s.l,1.5,0.3),Vector3.new(cx,20,MF.SZ+MF.WT+0.2)) ms("FS_b"..i,Vector3.new(s.l,1.5,0.3),Vector3.new(cx,2,MF.SZ+MF.WT+0.2))
		local bw=mw("BackWall_"..i,Vector3.new(s.l,MF.WH,MF.WT),Vector3.new(cx,MF.WY,-MF.SZ-MF.WT/2)) at(bw,Enum.NormalId.Front) at(bw,Enum.NormalId.Back)
		ms("BS_t"..i,Vector3.new(s.l,1.5,0.3),Vector3.new(cx,20,-MF.SZ-MF.WT-0.2)) ms("BS_b"..i,Vector3.new(s.l,1.5,0.3),Vector3.new(cx,2,-MF.SZ-MF.WT-0.2))
	end
	mw("LeftWall",Vector3.new(MF.WT,MF.WH,MF.SZ*2+MF.WT*2+2),Vector3.new(sx-MF.WT/2,MF.WY,0))
	mw("RightWall",Vector3.new(MF.WT,MF.WH,MF.SZ*2+MF.WT*2+2),Vector3.new(ex+MF.WT/2,MF.WY,0))
	M._wallZ_front=MF.SZ-3 M._wallZ_back=-MF.SZ+3
end

function M.mapFixCollision(map,si)
	for _,p in pairs(gfp(map,si)) do if M._isGod then pcall(function() p.CanCollide=false p.Transparency=1 end) else pcall(function() p.CanCollide=true p.Transparency=0 end) end end
	for _,c in pairs(map:GetChildren()) do if c:IsA("BasePart") and c.Name=="BridgeFloor" then if M._isGod then pcall(function() c.CanCollide=false c.Transparency=1 end) else pcall(function() c.CanCollide=true end) end end end
	local mf=map:FindFirstChild("MzDHubWalls") if mf then for _,w in pairs(mf:GetChildren()) do if w:IsA("BasePart") then if w.Name:find("FS_") or w.Name:find("BS_") then w.CanCollide=false else w.CanCollide=true w.Anchored=true end end end end
end

M._lastFixedMapName=""
function M.mapRunFix()
	local map=M.mapFindCurrentMap() if not map then return end local si=M.mapFindShared(map.Name) local mc=map.Name~=M._lastFixedMapName
	if mc then M._lastFixedMapName=map.Name M.lastMapName=map.Name end local sx,ex=M.mapDetectXRange(map,si)
	if mc then
		pcall(function() M.mapCleanup(map) end) pcall(function() M.mapCleanupShared(si) end)
		pcall(function() local misc=workspace:FindFirstChild("Misc") if misc then for _,c in pairs(misc:GetChildren()) do if c.Name=="BrickAddition" or c.Name=="Roof" then pcall(function() c:Destroy() end) end end end end)
		for _,mn in pairs({"ValentinesMap","ArcadeMap","CandyMap","HalloweenMap","ChristmasMap","DoomMap"}) do local em=workspace:FindFirstChild(mn) if em then for _,fn in pairs(MFR) do sdf(em,fn) end for _,d in pairs(em:GetDescendants()) do if d:IsA("BasePart") and not isMzD(d) and isWP(d) then pcall(function() d:Destroy() end) end end end end
		task.wait(0.1) pcall(function() M.mapWidenFloors(map,si) end) pcall(function() M.mapFillGaps(map,sx,ex) end) pcall(function() M.mapBuildWalls(map,sx,ex) end)
		M.Status.mapFixer="Fixed: "..map.Name if M.S.DoomTowerEnabled then task.wait(0.5) M.enableTowerDrop() end if M._isGod then recolorGod() end
	end
	pcall(function() M.mapFixCollision(map,si) end)
end

function M.startMapFixer() if M.mapFixerThread then return end M.S.MapFixerEnabled=true M._lastFixedMapName="" pcall(function() M.mapRunFix() end) M.mapFixerThread=task.spawn(function() while M.S.MapFixerEnabled do pcall(function() M.mapRunFix() end) M.Status.mapFixer="Actief" task.wait(MF.INT) end M.Status.mapFixer="Uit" M.mapFixerThread=nil end) end
function M.stopMapFixer() M.S.MapFixerEnabled=false if M.mapFixerThread then pcall(task.cancel,M.mapFixerThread) M.mapFixerThread=nil end M.Status.mapFixer="Uit" end

-- GUI
task.wait(0.5)
pcall(function() for _,gui in pairs(Player.PlayerGui:GetChildren()) do if gui:IsA("ScreenGui") then for _,d in pairs(gui:GetDescendants()) do if d:IsA("TextLabel") and d.Text=="MzD Hub" then gui:Destroy() break end end end end end) task.wait(0.3)

local Fluent=loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager=loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager=loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local RAR=M.getAvailableRarities() local MUT=M.getAvailableMutations()
local SL={} for i=1,40 do table.insert(SL,tostring(i)) end
local SPM={["200"]=200,["400"]=400,["600"]=600,["800"]=800,["1000"]=1000,["1500"]=1500,["2000"]=2000,["3000"]=3000,["4000"]=4000,["INSTANT"]=9999}
local VALSPM={["100"]=100,["200"]=200,["300"]=300,["400"]=400,["500"]=500,["800"]=800,["1000"]=1000,["INSTANT"]=9999}
local CS={"Auto","Default","Doom","Valentine","Ocean","Emerald","Void","Blood","White"}

local W=Fluent:CreateWindow({Title="MzD Hub",SubTitle="v12.3",TabWidth=160,Size=UDim2.fromOffset(580,480),Acrylic=true,Theme="Dark",MinimizeKey=Enum.KeyCode.RightControl})

-- FARM TAB
local FT=W:AddTab({Title="Farm",Icon="swords"})
local BDD
local RDD=FT:AddDropdown("FR",{Title="Rarity",Values=RAR,Default={"Common"},Multi=true})
RDD:OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end if #s==0 then s={"Common"} end local any=false for _,r in pairs(s) do if r=="Any" then any=true break end end M.S.TargetRarity=any and "Any" or s M.S.SelectedBrainrots={} pcall(function() BDD:SetValues(M.getBrainrotNamesMulti(M.S.TargetRarity)) BDD:SetValue({}) end) end)
BDD=FT:AddDropdown("FB",{Title="Brainrots",Values=M.getBrainrotNamesMulti(M.S.TargetRarity),Default={},Multi=true})
BDD:OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end M.S.SelectedBrainrots=s end)
FT:AddDropdown("FM",{Title="Mutatie",Values=MUT,Default="None",Multi=false}):OnChanged(function(v) M.S.TargetMutation=v end)
FT:AddDropdown("FMo",{Title="Mode",Values={"Collect","Collect, Place & Max"},Default=M.S.FarmMode,Multi=false}):OnChanged(function(v) M.S.FarmMode=v end)
FT:AddDropdown("FS",{Title="Slot",Values=SL,Default=M.S.FarmSlot,Multi=false}):OnChanged(function(v) M.S.FarmSlot=v end)
FT:AddSlider("FML",{Title="Max Level",Default=M.S.MaxLevel,Min=1,Max=500,Rounding=0}):OnChanged(function(v) M.S.MaxLevel=math.floor(v) end)
local FSP=FT:AddParagraph({Title="Status",Content="Idle"})
local FTG=FT:AddToggle("FT",{Title="ðŸš€ Auto Farm",Default=false}) FTG:OnChanged(function(v) if v then M.findBase() M.startFarming() else M.stopFarming() end end)

FT:AddParagraph({Title="ðŸŽ² Lucky Blocks",Content=""})
FT:AddDropdown("LR",{Title="Rarity",Values={"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity"},Default={"Common"},Multi=true}):OnChanged(function(v) local s={} for n,on in pairs(v) do if on then table.insert(s,n) end end if #s==0 then s={"Common"} end M.S.LuckyBlockRarity=s end)
FT:AddDropdown("LM",{Title="Mutatie",Values=MUT,Default="Any",Multi=false}):OnChanged(function(v) M.S.LuckyBlockMutation=v end)
local LBSP=FT:AddParagraph({Title="LB",Content="Idle"})
local LBTG=FT:AddToggle("LT",{Title="ðŸŽ² Auto LB",Default=false}) LBTG:OnChanged(function(v) if v then M.findBase() M.startLuckyBlockFarm() else M.stopLuckyBlockFarm() end end)

-- FACTORY TAB
local FCT=W:AddTab({Title="Factory",Icon="hammer"})
FCT:AddDropdown("FCR",{Title="Rarity",Values=RAR,Default=M.S.FactoryRarity,Multi=false}):OnChanged(function(v) M.S.FactoryRarity=v end)
FCT:AddDropdown("FCM",{Title="Mutatie",Values=MUT,Default=M.S.FactoryMutation,Multi=false}):OnChanged(function(v) M.S.FactoryMutation=v end)
FCT:AddDropdown("FCS",{Title="Slot",Values=SL,Default=M.S.FactorySlot,Multi=false}):OnChanged(function(v) M.S.FactorySlot=v end)
FCT:AddSlider("FCML",{Title="Max Level",Default=M.S.FactoryMaxLevel,Min=1,Max=500,Rounding=0}):OnChanged(function(v) M.S.FactoryMaxLevel=math.floor(v) end)
local FCSP=FCT:AddParagraph({Title="Status",Content="Idle"})
local FCTG=FCT:AddToggle("FCT",{Title="ðŸ” Factory",Default=false}) FCTG:OnChanged(function(v) if v then M.findBase() M.startFactoryLoop() else M.stopFactoryLoop() end end)

-- EVENTS TAB
local ET=W:AddTab({Title="Events",Icon="party-popper"})
local DMSP=ET:AddParagraph({Title="ðŸª™ Doom",Content="Uit"})
local DMTG=ET:AddToggle("DT",{Title="ðŸª™ Doom Coins",Default=false}) DMTG:OnChanged(function(v) if v then M.startDoomCollector() else M.stopDoomCollector() end end)
ET:AddDropdown("TO",{Title="Tower Offset",Values={"-5","-3","-2","-1","0","1","2","3","5"},Default="0",Multi=false}):OnChanged(function(v) M.S.DoomTowerOffset=tonumber(v) or 0 if M.S.DoomTowerEnabled and M._towerDetectedFloorY then moveTower(M._towerDetectedFloorY,M.S.DoomTowerOffset) end end)
local DTSP=ET:AddParagraph({Title="ðŸ—¼ Tower",Content="Uit"})
local DTTG=ET:AddToggle("DTT",{Title="ðŸ—¼ Towerâ†’Vloer",Default=false}) DTTG:OnChanged(function(v) if v then M.enableTowerDrop() else M.disableTowerDrop() end end)
ET:AddButton({Title="âš¡ Doom Alles Aan",Callback=function() if not M.S.DoomTowerEnabled then M.enableTowerDrop() pcall(function() DTTG:SetValue(true) end) end if not M.S.DoomEnabled then M.startDoomCollector() pcall(function() DMTG:SetValue(true) end) end end})
ET:AddButton({Title="â¹ Doom Alles Uit",Callback=function() if M.S.DoomEnabled then M.stopDoomCollector() pcall(function() DMTG:SetValue(false) end) end if M.S.DoomTowerEnabled then M.disableTowerDrop() pcall(function() DTTG:SetValue(false) end) end end})

ET:AddParagraph({Title="ðŸ’ Valentine v2",Content="Rent naar brainrots, submit bij 100"})
ET:AddDropdown("VS",{Title="Speed",Values={"100","200","300","400","500","800","1000","INSTANT"},Default="300",Multi=false}):OnChanged(function(v) M.S.ValentineSpeed=VALSPM[v] or 300 end)
local VSP=ET:AddParagraph({Title="ðŸ’ Status",Content="Idle"})
local VTG=ET:AddToggle("VT",{Title="ðŸ’ Valentine",Default=false}) VTG:OnChanged(function(v) if v then M.startValentine() else M.stopValentine() end end)
ET:AddButton({Title="ðŸ’ Find Station",Callback=function() local s=M.findValentineStation() Fluent:Notify({Title="Station",Content=s and s.Name or "Niet gevonden!",Duration=4}) end})

local ASP=ET:AddParagraph({Title="ðŸ•¹ï¸ Arcade",Content="Idle"})
local ATG=ET:AddToggle("AT",{Title="ðŸ•¹ï¸ Arcade",Default=false}) ATG:OnChanged(function(v) if v then M.startArcade() else M.stopArcade() end end)

-- AUTO TAB
local AT2=W:AddTab({Title="Auto",Icon="rocket"})
local MSP=AT2:AddParagraph({Title="ðŸ’° Money",Content="Idle"})
local MTG=AT2:AddToggle("MT",{Title="ðŸ’° Money",Default=false}) MTG:OnChanged(function(v) if v then M.findBase() M.startMoney() else M.stopMoney() end end)
local USP=AT2:AddParagraph({Title="â¬†ï¸ Upgrade",Content="Idle"})
local UTG=AT2:AddToggle("UT",{Title="â¬†ï¸ Upgrade All",Default=false}) UTG:OnChanged(function(v) if v then M.findBase() M.startAutoUpgrade() else M.stopAutoUpgrade() end end)
local MFSP=AT2:AddParagraph({Title="ðŸ—ºï¸ Map",Content="Uit"})
local MFTG=AT2:AddToggle("MFT",{Title="ðŸ—ºï¸ Map Fixer",Default=false}) MFTG:OnChanged(function(v) if v then M.startMapFixer() else M.stopMapFixer() end end)
AT2:AddButton({Title="ðŸ—ºï¸ Fix 1x",Callback=function() M._lastFixedMapName="" pcall(function() M.mapRunFix() end) end})

AT2:AddDropdown("GWY",{Title="God Walk Y",Values={"0","-1","-2","-3","-5","-8","-10","-15"},Default="-2",Multi=false}):OnChanged(function(v) M.S.GodWalkY=tonumber(v) or -2 if M._isGod then godTP() end end)
AT2:AddDropdown("GFY",{Title="God Floor Y",Values={"-3","-5","-8","-10","-15","-20"},Default="-5",Multi=false}):OnChanged(function(v) M.S.GodFloorY=tonumber(v) or -5 end)
local GDSP=AT2:AddParagraph({Title="ðŸ›¡ï¸ God",Content="Uit"})
local GDTG=AT2:AddToggle("GT",{Title="ðŸ›¡ï¸ God Mode",Default=false}) GDTG:OnChanged(function(v) if v then M.enableGod() else M.disableGod() end end)

AT2:AddParagraph({Title="ðŸŽ¨ Kleuren",Content="Auto past aan per map"})
local CSSP=AT2:AddParagraph({Title="Schema",Content="Auto"})
AT2:AddDropdown("CS",{Title="Schema",Values=CS,Default="Auto",Multi=false}):OnChanged(function(v) M.S.ColorScheme=v if M._isGod then recolorGod() M._lastFixedMapName="" pcall(function() M.mapRunFix() end) end local sc,det=getScheme() CSSP:SetDesc(v=="Auto" and detectMapType() or v) end)
AT2:AddButton({Title="ðŸŽ¨ Recolor",Callback=function() if M._isGod then recolorGod() end M._lastFixedMapName="" pcall(function() M.mapRunFix() end) end})

AT2:AddToggle("IT",{Title="âš¡ Instant Pickup",Default=true}):OnChanged(function(v) M.S.InstantPickup=v if v then M.setupInstant() end end)
local AFKSP=AT2:AddParagraph({Title="AFK",Content="Uit"})
local AFKTG=AT2:AddToggle("AFT",{Title="ðŸ›¡ï¸ Anti-AFK",Default=false}) AFKTG:OnChanged(function(v) if v then M.startAFK() else M.stopAFK() end end)

-- CONFIG TAB
local CT=W:AddTab({Title="Config",Icon="settings"})
CT:AddDropdown("TS",{Title="Speed",Values={"200","400","600","800","1000","1500","2000","3000","4000","INSTANT"},Default="INSTANT",Multi=false}):OnChanged(function(v) M.S.TweenSpeed=SPM[v] or 9999 end)
CT:AddDropdown("CrS",{Title="Corridor",Values={"100","200","300","400","500","600","800","1000","1500","2000"},Default="1500",Multi=false}):OnChanged(function(v) M.S.CorridorSpeed=tonumber(v) or 1500 end)
CT:AddButton({Title="ðŸ”„ Herlaad",Callback=function() M.S.SelectedBrainrots={} pcall(function() BDD:SetValues(M.getBrainrotNamesMulti(M.S.TargetRarity)) BDD:SetValue({}) end) end})
CT:AddButton({Title="ðŸ  Zoek Base",Callback=function() M.findBase() Fluent:Notify({Title="Base",Content=M.baseGUID or "?",Duration=3}) end})
CT:AddButton({Title="ðŸ“ Home Op",Callback=function() M.setHomePosition() end})
CT:AddButton({Title="ðŸ  Ga Base",Callback=function() M.findBase() M.returnToBase() end})
CT:AddButton({Title="ðŸ—‘ï¸ Leeg Slot",Callback=function() M.findBase() M.clearSlot(tonumber(M.S.FarmSlot) or 5) end})
local IP=CT:AddParagraph({Title="Info",Content="..."})

-- SETTINGS TAB
local ST2=W:AddTab({Title="Settings",Icon="shield"})
SaveManager:SetLibrary(Fluent) InterfaceManager:SetLibrary(Fluent) SaveManager:SetFolder("MzDHub") InterfaceManager:SetFolder("MzDHub")
InterfaceManager:BuildInterfaceSection(ST2) SaveManager:BuildConfigSection(ST2)

-- STATUS LOOP
task.spawn(function() while task.wait(1) do pcall(function()
	FSP:SetDesc((M.S.Farming and M.Status.farm or "Idle").." #"..M.Status.farmCount.." P:"..M.Status.placeCount.." U:"..M.Status.upgradeCount)
	if not M.S.Farming then pcall(function() if FTG.Value then FTG:SetValue(false) end end) end
	LBSP:SetDesc((M.S.LuckyBlockEnabled and M.Status.luckyBlock or "Idle").." #"..M.Status.luckyBlockCount)
	if not M.S.LuckyBlockEnabled then pcall(function() if LBTG.Value then LBTG:SetValue(false) end end) end
	FCSP:SetDesc((M.Status.factory or "Idle").." #"..M.Status.factoryCount) if not M.S.FactoryEnabled then pcall(function() if FCTG.Value then FCTG:SetValue(false) end end) end
	if M.S.DoomEnabled then local f=workspace:FindFirstChild("DoomEventParts") DMSP:SetDesc("AAN P:"..#M._doomCachedParts.." F:"..(f and #f:GetChildren() or 0)) else DMSP:SetDesc("Uit") end
	if not M.S.DoomEnabled then pcall(function() if DMTG.Value then DMTG:SetValue(false) end end) end
	if M.S.DoomTowerEnabled then DTSP:SetDesc("AAN Y:"..(getTowerY() and string.format("%.0f",getTowerY()) or "?").." Off:"..M.S.DoomTowerOffset) else DTSP:SetDesc("Uit") end
	if not M.S.DoomTowerEnabled then pcall(function() if DTTG.Value then DTTG:SetValue(false) end end) end
	if M.S.ValentineEnabled then local h=M.getHeartCount() VSP:SetDesc(M.Status.valentine.." H:"..h.."/100 #"..M.Status.valentineCount) else VSP:SetDesc("Idle") end
	if not M.S.ValentineEnabled then pcall(function() if VTG.Value then VTG:SetValue(false) end end) end
	ASP:SetDesc(M.S.ArcadeEnabled and ("Actief #"..M.Status.arcadeCount) or "Idle")
	if not M.S.ArcadeEnabled then pcall(function() if ATG.Value then ATG:SetValue(false) end end) end
	MSP:SetDesc(M.S.AutoCollectMoney and "Actief" or "Idle") if not M.S.AutoCollectMoney then pcall(function() if MTG.Value then MTG:SetValue(false) end end) end
	USP:SetDesc((M.S.AutoUpgrade and M.upgradeThread and M.Status.upgrade or "Idle").." #"..M.Status.upgradeCount) if not(M.S.AutoUpgrade and M.upgradeThread) then pcall(function() if UTG.Value then UTG:SetValue(false) end end) end
	MFSP:SetDesc(M.S.MapFixerEnabled and M.Status.mapFixer or "Uit") if not M.S.MapFixerEnabled then pcall(function() if MFTG.Value then MFTG:SetValue(false) end end) end
	AFKSP:SetDesc(M.Status.afk) if not M.S.AntiAFK then pcall(function() if AFKTG.Value then AFKTG:SetValue(false) end end) end
	GDSP:SetDesc(M.Status.god..(M._isGod and " ðŸŽ¨"..detectMapType() or "")) if not M._isGod then pcall(function() if GDTG.Value then GDTG:SetValue(false) end end) end
	CSSP:SetDesc(M.S.ColorScheme=="Auto" and detectMapType() or M.S.ColorScheme)
	local h=Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	IP:SetDesc(Player.Name.." | "..(M.baseGUID and M.baseGUID:sub(1,8) or "?").." | ðŸŽ¨"..detectMapType().." | Y:"..(h and string.format("%.0f",h.Position.Y) or "?"))
end) end end)

task.spawn(function() task.wait(1) M.findBase() task.wait(0.5) M.detectWallZ()
	Fluent:Notify({Title="MzD Hub v12.3",Content="ðŸŽ¨ "..detectMapType().." kleuren\nðŸ’ Valentine v2\nðŸ”¥ Doom support",Duration=5})
end)
W:SelectTab(1)
print("[MzD Hub] v12.3 âœ“ Schema:"..detectMapType())
