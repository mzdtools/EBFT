-- ============================================
-- MzD Hub v10.7 - VOLLEDIG
-- God Mode v18: Vervangende Vloer methode
-- Kill zone op Yâ‰ˆ0, wij lopen op Yâ‰ˆ-17
-- loadstring(game:HttpGet("https://raw.githubusercontent.com/mzdtools/EBFT/main/Escape"))()
-- ============================================
getgenv().MzD = {}
local M = getgenv().MzD

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Player = Players.LocalPlayer

-- ========== INIT ==========
M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots")
if not M.ActiveBrainrots then
    task.spawn(function() M.ActiveBrainrots = workspace:WaitForChild("ActiveBrainrots", 15) end)
end

M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks")
if not M.ActiveLuckyBlocks then
    task.spawn(function() M.ActiveLuckyBlocks = workspace:WaitForChild("ActiveLuckyBlocks", 15) end)
end

M.PlotAction = nil
pcall(function()
    M.PlotAction = game:GetService("ReplicatedStorage")
        :WaitForChild("Packages", 10)
        :WaitForChild("Net", 10)
        :WaitForChild("RF/Plot.PlotAction", 10)
end)

-- ========== SETTINGS ==========
M.S = {
    Farming = false,
    SelectedBrainrots = {},
    TargetMutation = "None",
    TargetRarity = {"Common"},
    TweenSpeed = 9999,
    CorridorSpeed = 1500,
    AutoCollectMoney = false,
    InstantPickup = true,
    AntiAFK = false,
    AutoUpgrade = false,
    MaxLevel = 250,
    FactoryEnabled = false,
    FactorySlot = "5",
    FactoryRarity = "Common",
    FactoryMutation = "None",
    FactoryMaxLevel = 250,
    FarmMode = "Collect, Place & Max",
    FarmSlot = "5",
    ValentineEnabled = false,
    ArcadeEnabled = false,
    MapFixerEnabled = false,
    LuckyBlockEnabled = false,
    LuckyBlockRarity = {"Common"},
    LuckyBlockMutation = "Any",
    GodEnabled = false,
    GodFloorY = -20,
    GodWalkY = -17,
}

M.Status = {
    farm = "Idle", farmCount = 0,
    money = "Idle",
    afk = "Uit",
    placeCount = 0, upgradeCount = 0,
    upgrade = "Idle",
    factory = "Idle", factoryCount = 0,
    valentine = "Idle", valentineCount = 0,
    arcade = "Idle", arcadeCount = 0,
    mapFixer = "Uit",
    luckyBlock = "Idle", luckyBlockCount = 0,
    god = "Uit",
}

-- ========== STATE ==========
M.baseGUID = nil
M.baseCFrame = nil
M.homePosition = nil
M.farmThread = nil
M.factoryThread = nil
M.moneyThread = nil
M.moneyRemoteThread = nil
M.afkThread = nil
M._afkSteppedConn = nil
M._instantConn = nil
M.upgradeThread = nil
M.valentineThread = nil
M.valentineCollectorConn = nil
M.valentineTurboThread = nil
M.valentineNoclipConn = nil
M._valentineDescAddedConn = nil
M.arcadeThread = nil
M.mapFixerThread = nil
M.lastMapName = ""
M._valentineCachedParts = {}
M._valentineLastCacheScan = 0
M._valentineFoundRemotes = {}
M._valentineDebugLog = {}
M.luckyBlockThread = nil

-- God Mode v18 state
M._isGod = false
M._godNoclipThread = nil
M._godHealthConn = nil
M._godDiedConn = nil
M._godOriginalFloors = {}
M._godCreatedFloors = {}
M._godKillParts = {}

M._wallZ_front = 173
M._wallZ_back = -173

local HIGH_RARITIES = {["Celestial"] = true, ["Divine"] = true, ["Infinity"] = true}

-- ============================================
-- GOD MODE v18 - VERVANGENDE VLOER
-- ============================================

local function godFindFloorParts()
    local floors = {}
    local map = nil

    for _, c in pairs(workspace:GetChildren()) do
        if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
            if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or
               c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then
                map = c break
            end
        end
    end

    local function checkPart(p)
        if not p:IsA("BasePart") then return end
        if p.Size.X > 15 and p.Size.Z > 5 and p.Size.Y < 20 then
            if p.Position.Y > -10 and p.Position.Y < 30 then
                table.insert(floors, p)
            end
        end
    end

    if map then
        for _, c in pairs(map:GetChildren()) do
            if c:IsA("BasePart") then
                local n = c.Name:lower()
                if n == "firstfloor" or n == "ground" or n == "floor" or
                   n == "grass" or n == "path" or n == "road" or n == "platform" or
                   n == "bridgefloor" then
                    table.insert(floors, c)
                else
                    checkPart(c)
                end
            end
        end
        local sp = map:FindFirstChild("Spawners")
        if sp then for _, s in pairs(sp:GetChildren()) do checkPart(s) end end
    end

    for _, c in pairs(workspace:GetChildren()) do
        if c.Name:find("SharedInstances") then
            local fl = c:FindFirstChild("Floors")
            if fl then for _, f in pairs(fl:GetChildren()) do checkPart(f) end end
            for _, f in pairs(c:GetChildren()) do checkPart(f) end
        end
    end

    if #floors == 0 then
        for _, c in pairs(workspace:GetChildren()) do
            if c:IsA("BasePart") then checkPart(c) end
        end
    end

    return floors, map
end

local function godFindKillParts()
    local kills = {}
    for _, c in pairs(workspace:GetDescendants()) do
        if c:IsA("BasePart") then
            -- Kill zone: size 1, 0.05, 260 op Yâ‰ˆ0
            if c.Size.Y < 0.5 and c.Size.Z > 100 and c.Position.Y < 2 and c.Position.Y > -2 then
                table.insert(kills, c)
            end
            -- Ook zoeken op naam
            local n = c.Name:lower()
            if n:find("kill") or n:find("tsunami") or n:find("death") or n:find("damage") then
                table.insert(kills, c)
            end
        end
    end
    return kills
end

local function godDisableKillParts()
    M._godKillParts = {}
    local kills = godFindKillParts()
    for _, p in pairs(kills) do
        table.insert(M._godKillParts, {
            part = p,
            canCollide = p.CanCollide,
            canTouch = p.CanTouch,
            size = p.Size,
            position = p.Position,
            transparency = p.Transparency,
        })
        pcall(function()
            p.CanCollide = false
            p.CanTouch = false
            p.Size = Vector3.new(0, 0, 0)
            p.Transparency = 1
            p.Position = Vector3.new(0, -9999, 0)
        end)
    end
    print("[MzD God] Kill parts uitgeschakeld: " .. #kills)
end

local function godRestoreKillParts()
    for _, data in pairs(M._godKillParts) do
        pcall(function()
            if data.part and data.part.Parent then
                data.part.CanCollide = data.canCollide
                data.part.CanTouch = data.canTouch
                data.part.Size = data.size
                data.part.Position = data.position
                data.part.Transparency = data.transparency
            end
        end)
    end
    M._godKillParts = {}
end

local function godReplaceFloors()
    local floors, map = godFindFloorParts()
    if #floors == 0 then
        M.Status.god = "Geen vloer gevonden!"
        return false
    end

    M._godOriginalFloors = {}
    M._godCreatedFloors = {}

    local floorY = M.S.GodFloorY
    local floorThickness = 4

    for _, p in pairs(floors) do
        -- Sla origineel op
        table.insert(M._godOriginalFloors, {
            part = p,
            size = p.Size,
            position = p.Position,
            canCollide = p.CanCollide,
            transparency = p.Transparency,
            color = p.Color,
            material = p.Material,
            anchored = p.Anchored,
        })

        -- Maak nieuwe vloer op lagere Y
        pcall(function()
            local newFloor = Instance.new("Part")
            newFloor.Name = "MzDGodFloor"
            newFloor.Size = Vector3.new(p.Size.X + 10, floorThickness, p.Size.Z + 10)
            newFloor.Position = Vector3.new(p.Position.X, floorY, p.Position.Z)
            newFloor.Anchored = true
            newFloor.CanCollide = true
            newFloor.Color = p.Color
            newFloor.Material = p.Material
            newFloor.Transparency = 0.3
            newFloor.TopSurface = Enum.SurfaceType.Smooth
            newFloor.BottomSurface = Enum.SurfaceType.Smooth
            newFloor.Parent = workspace

            table.insert(M._godCreatedFloors, newFloor)
        end)

        -- Maak originele vloer onzichtbaar en niet-collision
        pcall(function()
            p.CanCollide = false
            p.Transparency = 1
        end)
    end

    -- Extra: grote vangvloer voor het geval
    pcall(function()
        local catchFloor = Instance.new("Part")
        catchFloor.Name = "MzDGodCatchFloor"
        catchFloor.Size = Vector3.new(10000, 2, 10000)
        catchFloor.Position = Vector3.new(0, floorY - 5, 0)
        catchFloor.Anchored = true
        catchFloor.CanCollide = true
        catchFloor.Transparency = 1
        catchFloor.Color = Color3.fromRGB(50, 50, 50)
        catchFloor.Parent = workspace
        table.insert(M._godCreatedFloors, catchFloor)
    end)

    print("[MzD God] Vloeren vervangen: " .. #floors .. " â†’ Y=" .. floorY)
    return true
end

local function godRestoreFloors()
    -- Herstel originele vloeren
    for _, data in pairs(M._godOriginalFloors) do
        pcall(function()
            if data.part and data.part.Parent then
                data.part.Size = data.size
                data.part.Position = data.position
                data.part.CanCollide = data.canCollide
                data.part.Transparency = data.transparency
                data.part.Color = data.color
                data.part.Material = data.material
                data.part.Anchored = data.anchored
            end
        end)
    end
    M._godOriginalFloors = {}

    -- Verwijder gemaakte vloeren
    for _, f in pairs(M._godCreatedFloors) do
        pcall(function()
            if f and f.Parent then f:Destroy() end
        end)
    end
    M._godCreatedFloors = {}
end

local function godTeleportUnder()
    local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.CFrame = CFrame.new(hrp.Position.X, M.S.GodWalkY, hrp.Position.Z)
end

local function godStartNoclip()
    if M._godNoclipThread then pcall(task.cancel, M._godNoclipThread) end
    M._godNoclipThread = task.spawn(function()
        while M._isGod do
            pcall(function()
                local ch = Player.Character
                if not ch then return end
                local hrp = ch:FindFirstChild("HumanoidRootPart")

                -- Character noclip door originele vloer (die nu onzichtbaar is)
                for _, p in pairs(ch:GetDescendants()) do
                    if p:IsA("BasePart") then
                        p.CanCollide = false
                    end
                end

                -- Houd speler op juiste Y-hoogte
                if hrp then
                    local curY = hrp.Position.Y
                    local targetY = M.S.GodWalkY

                    -- Als te ver van target Y, corrigeer
                    if curY > targetY + 8 then
                        -- Speler is te hoog (boven originele vloer)
                        hrp.Velocity = Vector3.new(hrp.Velocity.X, -5, hrp.Velocity.Z)
                        hrp.CFrame = CFrame.new(hrp.Position.X, targetY, hrp.Position.Z)
                    elseif curY < targetY - 30 then
                        -- Speler is te ver gevallen
                        hrp.Velocity = Vector3.new(0, 0, 0)
                        hrp.CFrame = CFrame.new(hrp.Position.X, targetY, hrp.Position.Z)
                    end
                end

                -- Houd kill parts uitgeschakeld
                for _, data in pairs(M._godKillParts) do
                    pcall(function()
                        if data.part and data.part.Parent then
                            data.part.CanCollide = false
                            data.part.CanTouch = false
                        end
                    end)
                end

                -- Houd originele vloeren onzichtbaar
                for _, data in pairs(M._godOriginalFloors) do
                    pcall(function()
                        if data.part and data.part.Parent then
                            data.part.CanCollide = false
                            data.part.Transparency = 1
                        end
                    end)
                end
            end)
            task.wait(0.03)
        end
    end)
end

local function godSetupHealth(char)
    if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) end
    if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) end

    local hum = char:WaitForChild("Humanoid", 5)
    if not hum then return end

    pcall(function()
        hum.MaxHealth = math.huge
        hum.Health = math.huge
        hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
    end)

    for _, ff in pairs(char:GetChildren()) do
        if ff:IsA("ForceField") then ff:Destroy() end
    end
    local ff = Instance.new("ForceField")
    ff.Visible = false
    ff.Parent = char

    M._godHealthConn = hum:GetPropertyChangedSignal("Health"):Connect(function()
        if not M._isGod then return end
        pcall(function()
            if hum.Health ~= math.huge then hum.Health = math.huge end
        end)
    end)

    M._godDiedConn = hum.Died:Connect(function()
        if not M._isGod then return end
        M.Status.god = "Died geblokkeerd!"
        task.defer(function()
            pcall(function()
                hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
                hum:ChangeState(Enum.HumanoidStateType.GettingUp)
                hum.MaxHealth = math.huge
                hum.Health = math.huge
            end)
        end)
    end)
end

function M.enableGod()
    if M._isGod then return end
    M._isGod = true
    M.S.GodEnabled = true
    M.Status.god = "Starten..."

    -- Stap 1: Kill parts uitschakelen
    godDisableKillParts()
    task.wait(0.1)

    -- Stap 2: Vloeren vervangen
    local ok = godReplaceFloors()
    task.wait(0.2)

    -- Stap 3: Noclip starten (VOOR teleport)
    godStartNoclip()
    task.wait(0.2)

    -- Stap 4: Teleport onder de vloer
    godTeleportUnder()
    task.wait(0.2)

    -- Stap 5: Health bescherming
    if Player.Character then godSetupHealth(Player.Character) end

    if ok then
        M.Status.god = "Aan ðŸ›¡ï¸ (Onder Vloer Y=" .. M.S.GodWalkY .. ")"
    else
        M.Status.god = "Aan ðŸ›¡ï¸ (Fallback - geen vloer gevonden)"
    end

    print("[MzD God] ACTIEF! WalkY=" .. M.S.GodWalkY .. " FloorY=" .. M.S.GodFloorY)
end

function M.disableGod()
    M._isGod = false
    M.S.GodEnabled = false

    -- Stop noclip
    if M._godNoclipThread then pcall(task.cancel, M._godNoclipThread) M._godNoclipThread = nil end
    if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) M._godHealthConn = nil end
    if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) M._godDiedConn = nil end

    -- Herstel alles
    godRestoreFloors()
    godRestoreKillParts()

    -- Zet character terug boven vloer
    local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.Velocity = Vector3.new(0, 0, 0)
        hrp.CFrame = CFrame.new(hrp.Position.X, 10, hrp.Position.Z)
    end

    -- Herstel collision
    local ch = Player.Character
    if ch then
        for _, p in pairs(ch:GetDescendants()) do
            if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
                pcall(function() p.CanCollide = true end)
            end
        end
        for _, ff2 in pairs(ch:GetChildren()) do
            if ff2:IsA("ForceField") then ff2:Destroy() end
        end
        local hum = ch:FindFirstChild("Humanoid")
        if hum then
            pcall(function()
                hum.MaxHealth = 100
                hum.Health = 100
                hum:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
            end)
        end
    end

    M.Status.god = "Uit"
    print("[MzD God] Uitgeschakeld, alles hersteld")
end

-- ========== EQUIP ==========
function M.safeEquip(tool)
    if not tool then return end
    local ch = Player.Character
    if not ch then return end
    local hum = ch:FindFirstChild("Humanoid")
    if not hum then return end
    pcall(function() hum:EquipTool(tool) end)
    task.wait(0.4)
end

function M.safeUnequip()
    local ch = Player.Character
    if not ch then return end
    local hum = ch:FindFirstChild("Humanoid")
    if not hum then return end
    pcall(function() hum:UnequipTools() end)
    task.wait(0.2)
end

-- ========== MAP HELPERS ==========
function M.mapFindCurrentMap()
    local best, bc = nil, 0
    for _, c in pairs(workspace:GetChildren()) do
        if c:IsA("Model") and c.Name:find("Map") and not c.Name:find("SharedInstances") then
            if c:FindFirstChild("Spawners") or c:FindFirstChild("Gaps") or c:FindFirstChild("RightWalls") or
                c:FindFirstChild("FirstFloor") or c:FindFirstChild("Ground") then return c end
            local cnt = 0
            for _, d in pairs(c:GetDescendants()) do
                if d:IsA("BasePart") then cnt += 1 end
                if cnt > 10 then return c end
            end
            if cnt > bc then bc = cnt best = c end
        end
    end
    return best
end

function M.detectWallZ()
    local map = M.mapFindCurrentMap()
    if not map then return end
    local mzwalls = map:FindFirstChild("MzDHubWalls")
    if not mzwalls then return end
    local fw = mzwalls:FindFirstChild("FrontWall_1")
    local bw = mzwalls:FindFirstChild("BackWall_1")
    if fw then M._wallZ_front = fw.Position.Z - fw.Size.Z / 2 - 3 end
    if bw then M._wallZ_back = bw.Position.Z + bw.Size.Z / 2 + 3 end
end

function M.getCorridorZ()
    M.detectWallZ()
    local homePos = M.getHomePosition().Position
    if homePos.Z >= 0 then return M._wallZ_front else return M._wallZ_back end
end

-- ========== BASE ==========
function M.findBase()
    local bases = workspace:FindFirstChild("Bases")
    if not bases then return end
    for _, base in pairs(bases:GetChildren()) do
        pcall(function()
            local pn = base.Title.TitleGui.Frame.PlayerName
            if pn.Text == Player.Name or pn.Text == Player.DisplayName then
                M.baseGUID = base.Name
                local s1 = base:FindFirstChild("slot 1 brainrot")
                if s1 and s1:FindFirstChild("Root") then M.baseCFrame = s1.Root.CFrame end
            end
        end)
    end
    if not M.homePosition then M.setHomePosition() end
end

function M.setHomePosition()
    local ch = Player.Character if not ch then return end
    local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return end
    M.homePosition = hrp.CFrame
end

function M.getHomePosition()
    if M.homePosition then return M.homePosition end
    if M.baseCFrame then return M.baseCFrame end
    return CFrame.new(124, 3.8, 22)
end

task.spawn(function() task.wait(3) M.findBase() end)

-- ========== RESPAWN ==========
Player.CharacterAdded:Connect(function(character)
    task.wait(1.5)
    if M.S.InstantPickup then M.setupInstant() end
    task.wait(0.5)
    M.detectWallZ()
    if M._isGod then
        if M._godHealthConn then pcall(function() M._godHealthConn:Disconnect() end) M._godHealthConn = nil end
        if M._godDiedConn then pcall(function() M._godDiedConn:Disconnect() end) M._godDiedConn = nil end
        task.wait(0.5)
        godSetupHealth(character)
        -- Kill parts opnieuw uitschakelen na respawn
        godDisableKillParts()
        task.wait(0.3)
        godTeleportUnder()
        M.Status.god = "Respawn âœ“ (Y=" .. M.S.GodWalkY .. ")"
    end
end)

-- ========== TWEEN ==========
function M.tweenTo(cf)
    local ch = Player.Character if not ch then return false end
    local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end

    -- Als god mode aan, tween op god Y-hoogte
    local targetCF = cf
    if M._isGod then
        targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z)
    end

    local d = (hrp.Position - targetCF.Position).Magnitude
    local t = math.max(d / M.S.TweenSpeed, 0.01)
    local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF})
    tw:Play() tw.Completed:Wait()
    return true
end

function M.fastTween(cf)
    local ch = Player.Character if not ch then return false end
    local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end

    local targetCF = cf
    if M._isGod then
        targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z)
    end

    local d = (hrp.Position - targetCF.Position).Magnitude
    local t = math.max(d / 99999, 0.005)
    local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF})
    tw:Play() tw.Completed:Wait()
    return true
end

function M.corridorTween(cf)
    local ch = Player.Character if not ch then return false end
    local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end

    local targetCF = cf
    if M._isGod then
        targetCF = CFrame.new(cf.Position.X, M.S.GodWalkY, cf.Position.Z)
    end

    local d = (hrp.Position - targetCF.Position).Magnitude
    local t = math.max(d / math.max(M.S.CorridorSpeed or 1500, 50), 0.01)
    local tw = TweenService:Create(hrp, TweenInfo.new(t, Enum.EasingStyle.Linear), {CFrame = targetCF})
    tw:Play() tw.Completed:Wait()
    return true
end

-- ========== SAFE PATH ==========
function M.safePathTo(targetCFrame)
    local ch = Player.Character if not ch then return false end
    local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return false end
    local startPos = hrp.Position
    local endPos = targetCFrame.Position
    local SAFE_Z = M.getCorridorZ()
    local SAFE_Y = M._isGod and M.S.GodWalkY or (M.getHomePosition().Position.Y + 8)

    M.fastTween(CFrame.new(startPos.X, SAFE_Y, startPos.Z)) task.wait(0.05)
    M.corridorTween(CFrame.new(startPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
    M.corridorTween(CFrame.new(endPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
    M.corridorTween(CFrame.new(endPos.X, SAFE_Y, endPos.Z)) task.wait(0.05)

    -- Voor brainrot pakken: ga naar de juiste positie (ook op god Y)
    local finalCF = M._isGod and CFrame.new(endPos.X, M.S.GodWalkY, endPos.Z) or targetCFrame
    M.tweenTo(finalCF) task.wait(0.05)
    return true
end

function M.safeReturnToBase()
    local ch = Player.Character if not ch then return end
    local hrp = ch:FindFirstChild("HumanoidRootPart") if not hrp then return end
    local curPos = hrp.Position
    local homePos = M.getHomePosition().Position
    M.detectWallZ()
    local SAFE_Z = M.getCorridorZ()
    local SAFE_Y = M._isGod and M.S.GodWalkY or (homePos.Y + 8)

    M.fastTween(CFrame.new(curPos.X, SAFE_Y, curPos.Z)) task.wait(0.05)
    M.corridorTween(CFrame.new(curPos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
    M.corridorTween(CFrame.new(homePos.X, SAFE_Y, SAFE_Z)) task.wait(0.05)
    M.corridorTween(CFrame.new(homePos.X, SAFE_Y, homePos.Z)) task.wait(0.05)
    M.tweenTo(CFrame.new(homePos.X, M._isGod and M.S.GodWalkY or homePos.Y, homePos.Z)) task.wait(0.05)
end

function M.returnToBase()
    if M._isGod then
        local hp = M.getHomePosition().Position
        M.tweenTo(CFrame.new(hp.X, M.S.GodWalkY, hp.Z))
    else
        M.tweenTo(M.getHomePosition())
    end
    task.wait(0.1)
end

-- ========== HELPERS ==========
function M.isHighRarity(r) return HIGH_RARITIES[r] == true end

function M.isHighRarityTool(tool)
    if not tool then return false end
    local r = tool:GetAttribute("Rarity") or ""
    return HIGH_RARITIES[r] == true
end

function M.isDead()
    local ch = Player.Character if not ch then return true end
    local hum = ch:FindFirstChild("Humanoid") if not hum then return true end
    return hum.Health <= 0
end

function M.waitForRespawn()
    if not M.isDead() then return true end
    local timeout = tick() + 15
    while M.isDead() and tick() < timeout do task.wait(0.2) end
    task.wait(1)
    return not M.isDead()
end

-- ========== FORCE GRAB ==========
function M.forceGrabPrompt(target)
    if not target then return end
    local prompts = {}
    if target:IsA("ProximityPrompt") then
        table.insert(prompts, target)
    else
        for _, d in pairs(target:GetDescendants()) do
            if d:IsA("ProximityPrompt") then table.insert(prompts, d) end
        end
    end
    for _, p in pairs(prompts) do
        pcall(function() p.MaxActivationDistance = 99999 p.HoldDuration = 0 end)
        pcall(function() fireproximityprompt(p) end)
        task.wait(0.02)
        pcall(function() fireproximityprompt(p) end)
    end
    local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        local parent = target
        if parent:IsA("ProximityPrompt") then parent = parent.Parent end
        if parent and parent:IsA("BasePart") then
            pcall(function() firetouchinterest(hrp, parent, 0) end)
            pcall(function() firetouchinterest(hrp, parent, 1) end)
        end
        local searchRoot = parent
        if searchRoot and searchRoot.Parent and not searchRoot.Parent:IsA("Workspace") then
            searchRoot = searchRoot.Parent
        end
        if searchRoot then
            for _, d in pairs(searchRoot:GetDescendants()) do
                if d:IsA("BasePart") then
                    pcall(function() firetouchinterest(hrp, d, 0) end)
                    pcall(function() firetouchinterest(hrp, d, 1) end)
                end
            end
        end
    end
    task.wait(0.02)
end

-- ========== RARITY ==========
function M.getTargetRarities()
    return type(M.S.TargetRarity) == "table" and M.S.TargetRarity or {M.S.TargetRarity}
end

function M.rarityMatches(fn)
    for _, r in pairs(M.getTargetRarities()) do
        if r == "Any" or r == fn then return true end
    end
    return false
end

function M.getBrainrotNames(rarity)
    local names, seen = {}, {}
    if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
    if not M.ActiveBrainrots then return names end
    for _, f in pairs(M.ActiveBrainrots:GetChildren()) do
        if f:IsA("Folder") and (rarity == "Any" or f.Name == rarity) then
            for _, b in pairs(f:GetChildren()) do
                local n = nil
                if b:FindFirstChild("RenderedBrainrot") then n = b.RenderedBrainrot:GetAttribute("BrainrotName")
                elseif b.Name == "RenderedBrainrot" then n = b:GetAttribute("BrainrotName")
                else n = b:GetAttribute("BrainrotName") or b.Name end
                if n and n ~= "" and not seen[n] then seen[n] = true table.insert(names, n) end
            end
        end
    end
    table.sort(names) return names
end

function M.getBrainrotNamesMulti(rarities)
    if type(rarities) ~= "table" then return M.getBrainrotNames(rarities) end
    local names, seen = {}, {}
    for _, r in pairs(rarities) do if r == "Any" then return M.getBrainrotNames("Any") end end
    for _, r in pairs(rarities) do
        for _, n in pairs(M.getBrainrotNames(r)) do
            if not seen[n] then seen[n] = true table.insert(names, n) end
        end
    end
    table.sort(names) return names
end

function M.matchesFilter(b, folderRarity)
    if not M.rarityMatches(folderRarity) then return false end
    if M.isHighRarity(folderRarity) then return true end
    local mut = b:GetAttribute("Mutation") or "None"
    local isNone = (mut:lower() == "none" or mut == "")
    if M.S.TargetMutation == "None" then if not isNone then return false end
    elseif M.S.TargetMutation ~= "Any" then if mut ~= M.S.TargetMutation then return false end end
    if #M.S.SelectedBrainrots > 0 then
        local bName = b:GetAttribute("BrainrotName") or ""
        local found = false
        for _, sel in pairs(M.S.SelectedBrainrots) do if sel == bName then found = true break end end
        if not found then return false end
    end
    return true
end

function M.toolMatchesRarity(tool, targetRarity, targetMutation)
    local tMut = tool:GetAttribute("Mutation") or "None"
    local lvl = tonumber(tool:GetAttribute("Level")) or 0
    local bName = tool:GetAttribute("BrainrotName")
    local toolRarity = tool:GetAttribute("Rarity")
    if not bName or bName == "" then return false end
    if lvl >= M.S.MaxLevel then return false end
    if toolRarity and M.isHighRarity(toolRarity) then
        local tR = type(targetRarity) == "table" and targetRarity or {targetRarity}
        for _, r in pairs(tR) do if r == "Any" or r == toolRarity then return true end end
        return false
    end
    if targetMutation == "None" then
        if not (tMut:lower() == "none" or tMut == "") then return false end
    elseif targetMutation ~= "Any" then
        if tMut ~= targetMutation then return false end
    end
    local tR = type(targetRarity) == "table" and targetRarity or {targetRarity}
    local isAny = false
    for _, r in pairs(tR) do if r == "Any" then isAny = true break end end
    if not isAny then
        if toolRarity and toolRarity ~= "" then
            local m2 = false
            for _, r in pairs(tR) do if toolRarity == r then m2 = true break end end
            if not m2 then return false end
        else
            local wl = {}
            for _, r in pairs(tR) do for _, n in pairs(M.getBrainrotNames(r)) do wl[n] = true end end
            if not wl[bName] then return false end
        end
    end
    return true
end

-- ========== FACTORY TOOL ZOEKEN ==========
local function factoryToolMatchesRarity(tool)
    local tMut = tool:GetAttribute("Mutation") or "None"
    local lvl = tonumber(tool:GetAttribute("Level")) or 0
    local bName = tool:GetAttribute("BrainrotName")
    local toolRarity = tool:GetAttribute("Rarity")
    if not bName or bName == "" then return false end
    if lvl >= M.S.FactoryMaxLevel then return false end
    if M.S.FactoryMutation == "None" then
        if not (tMut:lower() == "none" or tMut == "") then return false end
    elseif M.S.FactoryMutation ~= "Any" then
        if tMut ~= M.S.FactoryMutation then return false end
    end
    if M.S.FactoryRarity ~= "Any" then
        if toolRarity and toolRarity ~= "" then
            if toolRarity ~= M.S.FactoryRarity then return false end
        else
            local wl = {}
            for _, n in pairs(M.getBrainrotNames(M.S.FactoryRarity)) do wl[n] = true end
            if not wl[bName] then return false end
        end
    end
    if tool:GetAttribute("Locked") then return false end
    return true
end

-- ========== FACTORY ==========
function M.startFactoryLoop()
    if M.factoryThread then return end
    M.S.FactoryEnabled = true
    M.Status.factoryCount = 0
    M.Status.factory = "Starten..."

    M.factoryThread = task.spawn(function()
        local stopReason = "Idle"
        while M.S.FactoryEnabled do
            local ok, err = pcall(function()
                M.Status.factory = "Scanning..."
                if not M.baseGUID then M.findBase() end
                if not M.baseGUID then M.Status.factory = "Geen base gevonden!" task.wait(2) return end
                local ws = tonumber(M.S.FactorySlot) or 5
                M.tweenToSlot(ws) task.wait(0.2)
                if not M.isSlotEmpty(ws) then
                    M.Status.factory = "Slot " .. ws .. " leegmaken..."
                    M.pickUpBrainrot(ws) task.wait(1)
                    pcall(function() Player.Character.Humanoid:UnequipTools() end) task.wait(0.5)
                end
                local tool = nil
                local scanAttempts = 0
                local maxScanAttempts = 5
                while not tool and scanAttempts < maxScanAttempts do
                    scanAttempts += 1
                    M.Status.factory = "Scannen backpack... (" .. scanAttempts .. "/" .. maxScanAttempts .. ")"
                    local bp = Player:FindFirstChild("Backpack")
                    if bp then
                        for _, t in pairs(bp:GetChildren()) do
                            if t:IsA("Tool") and factoryToolMatchesRarity(t) then tool = t break end
                        end
                    end
                    if not tool and Player.Character then
                        local eq = Player.Character:FindFirstChildWhichIsA("Tool")
                        if eq and factoryToolMatchesRarity(eq) then tool = eq end
                    end
                    if not tool and scanAttempts < maxScanAttempts then task.wait(0.6) end
                end
                if not tool then
                    stopReason = "Klaar! Alle " .. M.S.FactoryRarity .. " (" .. M.S.FactoryMutation .. ") gemaxt âœ“"
                    M.S.FactoryEnabled = false return
                end
                local bName = tool:GetAttribute("BrainrotName") or "Item"
                M.Status.factory = "Bezig: " .. bName
                local hum = Player.Character and Player.Character:FindFirstChild("Humanoid")
                if hum then hum:EquipTool(tool) task.wait(0.5) end
                M.Status.factory = "Plaatsen: " .. bName
                M.placeBrainrot(ws) task.wait(0.8)
                if M.isSlotEmpty(ws) then
                    M.Status.factory = "Plaatsen mislukt, retry..."
                    pcall(function() if hum then hum:UnequipTools() end end) task.wait(1) return
                end
                local myBase = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
                local sm = myBase and myBase:FindFirstChild("slot " .. ws .. " brainrot")
                if sm then
                    local cur = tonumber(sm:GetAttribute("Level")) or 0
                    local fails = 0
                    while cur < M.S.FactoryMaxLevel and M.S.FactoryEnabled do
                        for i = 1, 3 do task.spawn(function() M.upgradeBrainrot(ws) end) end
                        task.wait()
                        local nw = tonumber(sm:GetAttribute("Level")) or cur
                        if nw > cur then fails = 0 cur = nw M.Status.factory = bName .. " Lv." .. cur .. "/" .. M.S.FactoryMaxLevel
                        else fails += 1 if fails > 60 then stopReason = "Geld op bij Lv." .. cur .. "!" M.S.FactoryEnabled = false break end end
                    end
                end
                M.Status.factory = "Oprapen: " .. bName
                task.wait(0.5) M.pickUpBrainrot(ws) task.wait(1.2)
                M.Status.factoryCount += 1
                pcall(function() if hum then hum:UnequipTools() end end) task.wait(0.5)
                M.Status.factory = "âœ“ " .. bName .. " klaar! (#" .. M.Status.factoryCount .. ")"
            end)
            if not ok then warn("[MzD Factory] " .. tostring(err)) M.Status.factory = "Fout! Retry..." task.wait(1) end
        end
        M.Status.factory = stopReason
        M.factoryThread = nil
    end)
end

function M.stopFactoryLoop()
    M.S.FactoryEnabled = false
    if M.factoryThread then pcall(task.cancel, M.factoryThread) M.factoryThread = nil end
    if not (string.find(M.Status.factory or "", "âœ“") or string.find(M.Status.factory or "", "Klaar") or string.find(M.Status.factory or "", "Geld op")) then
        M.Status.factory = "Idle"
    end
end

-- ========== FIND TARGET TOOL ==========
function M.findTargetToolInBackpack()
    local bp = Player:FindFirstChild("Backpack")
    if bp then
        for _, t in pairs(bp:GetChildren()) do
            if t:IsA("Tool") and M.toolMatchesRarity(t, M.S.TargetRarity, M.S.TargetMutation) then return t end
        end
    end
    local ch = Player.Character
    if ch then
        local eq = ch:FindFirstChildWhichIsA("Tool")
        if eq and M.toolMatchesRarity(eq, M.S.TargetRarity, M.S.TargetMutation) then return eq end
    end
    return nil
end

function M.findBrainrotRoot(b)
    local root = b:FindFirstChild("Root")
    if root and root:IsA("BasePart") then return root end
    local rendered = b:FindFirstChild("RenderedBrainrot")
    if rendered then
        local rr = rendered:FindFirstChild("Root")
        if rr and rr:IsA("BasePart") then return rr end
    end
    for _, desc in pairs(b:GetDescendants()) do
        if desc:IsA("BasePart") then return desc end
    end
    if b:IsA("BasePart") then return b end
    return nil
end

-- ========== SLOTS ==========
function M.isSlotEmpty(s)
    if not M.baseGUID then M.findBase() end
    if not M.baseGUID then return true end
    local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
    if not mb then return true end
    local sm = mb:FindFirstChild("slot " .. s .. " brainrot")
    if not sm then return true end
    local bn = sm:GetAttribute("BrainrotName")
    return not bn or bn == ""
end

function M.findOccupiedSlots()
    if not M.baseGUID then M.findBase() end
    if not M.baseGUID then return {} end
    local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
    if not mb then return {} end
    local o = {}
    for i = 1, 40 do
        local sm = mb:FindFirstChild("slot " .. i .. " brainrot")
        if sm then
            local bn = sm:GetAttribute("BrainrotName")
            local lv = sm:GetAttribute("Level")
            if bn and bn ~= "" then table.insert(o, {slot = i, name = bn, level = lv or 1}) end
        end
    end
    return o
end

-- ========== REMOTES ==========
function M.placeBrainrot(s)
    if not M.baseGUID or not M.PlotAction then return false end
    local ok = pcall(function() M.PlotAction:InvokeServer("Place Brainrot", M.baseGUID, tostring(s)) end)
    if ok then M.Status.placeCount += 1 end
    return ok
end

function M.pickUpBrainrot(s)
    if not M.baseGUID or not M.PlotAction then return false end
    return pcall(function() M.PlotAction:InvokeServer("Pick Up Brainrot", M.baseGUID, tostring(s)) end)
end

function M.clearSlot(s)
    if not M.baseGUID or not M.PlotAction then return end
    pcall(function() M.PlotAction:InvokeServer("Pick Up Brainrot", M.baseGUID, tostring(s)) end)
    task.wait(0.5) M.safeUnequip() task.wait(0.3)
end

function M.upgradeBrainrot(s)
    if not M.baseGUID or not M.PlotAction then return false end
    return pcall(function() M.PlotAction:InvokeServer("Upgrade Brainrot", M.baseGUID, tostring(s)) end)
end

function M.tweenToSlot(slotNumber)
    if not M.baseGUID then M.findBase() end
    if not M.baseGUID then return false end
    local myBase = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
    if not myBase then return false end
    local sm = myBase:FindFirstChild("slot " .. slotNumber .. " brainrot")
    if not sm then return false end
    local root = sm:FindFirstChild("Root")
    if root and root:IsA("BasePart") then return M.tweenTo(root.CFrame * CFrame.new(0, 3, 0)) end
    local ok, pos = pcall(function() return sm:GetPivot() end)
    if ok and pos then return M.tweenTo(pos * CFrame.new(0, 3, 0)) end
    return false
end

function M.upgradeSlotToMax(slot)
    if not M.baseGUID then M.findBase() end
    if not M.baseGUID then return end
    local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
    if not mb then return end
    local sm = mb:FindFirstChild("slot " .. slot .. " brainrot")
    if not sm then return end
    local cur = tonumber(sm:GetAttribute("Level")) or 1
    local fails = 0
    while cur < M.S.MaxLevel and M.S.AutoUpgrade do
        for i = 1, 3 do task.spawn(function() M.upgradeBrainrot(slot) end) end
        task.wait()
        local nw = tonumber(sm:GetAttribute("Level")) or cur
        if nw > cur then fails = 0 cur = nw M.Status.upgradeCount += 1
        else fails += 1 if fails >= 60 then break end end
    end
end

-- ========== FARMING ==========
function M.startFarming()
    if M.farmThread then return end
    M.S.Farming = true
    M.Status.farmCount = 0
    M.setHomePosition()
    M.detectWallZ()
    M.returnToBase()
    M.enableGod()

    M.farmThread = task.spawn(function()
        while M.S.Farming do
            local ok, err = pcall(function()
                if M.isDead() then
                    M.Status.farm = "Dood! Wachten..."
                    M.waitForRespawn() task.wait(1)
                    M.setHomePosition() M.enableGod() task.wait(0.5) return
                end
                local ch = Player.Character
                local hum = ch and ch:FindFirstChild("Humanoid")
                if not ch or not hum then task.wait(1) return end
                if not M.baseGUID then M.findBase() end
                if not M.baseGUID then M.Status.farm = "Geen base!" task.wait(2) return end
                local ws = tonumber(M.S.FarmSlot) or 5

                if M.S.FarmMode == "Collect" then
                    M.Status.farm = "Zoeken..."
                    if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
                    if M.ActiveBrainrots then
                        for _, folder in pairs(M.ActiveBrainrots:GetChildren()) do
                            if not M.S.Farming then break end
                            if folder:IsA("Folder") and M.rarityMatches(folder.Name) then
                                for _, b in pairs(folder:GetChildren()) do
                                    if not M.S.Farming or M.isDead() then break end
                                    if M.matchesFilter(b, folder.Name) then
                                        local root = M.findBrainrotRoot(b) if not root then continue end
                                        M.Status.farm = "Ga naar " .. folder.Name .. "..."
                                        M.safePathTo(root.CFrame * CFrame.new(0, 3, 0))
                                        for attempt = 1, 5 do
                                            if not M.S.Farming then break end
                                            if M.isDead() then
                                                M.waitForRespawn() task.wait(1)
                                                M.setHomePosition() M.enableGod()
                                                if root and root.Parent then M.safePathTo(root.CFrame * CFrame.new(0, 3, 0)) else break end
                                            end
                                            if root and root.Parent then
                                                M.Status.farm = "Pakken " .. folder.Name .. "..."
                                                M.forceGrabPrompt(root) M.forceGrabPrompt(b)
                                                task.wait(0.3) M.Status.farmCount += 1 break
                                            else break end
                                        end
                                        M.safeUnequip() task.wait(0.1)
                                        M.Status.farm = "Terug via muur..."
                                        M.safeReturnToBase()
                                    end
                                end
                            end
                        end
                    end
                    task.wait(1) return
                end

                if not M.isSlotEmpty(ws) then
                    M.Status.farm = "Slot leegmaken..."
                    M.pickUpBrainrot(ws) task.wait(0.5)
                    M.safeUnequip() task.wait(0.3)
                end

                local tool = M.findTargetToolInBackpack()
                if tool and M.isHighRarityTool(tool) then
                    local rr = tool:GetAttribute("Rarity") or "High"
                    local bn = tool:GetAttribute("BrainrotName") or "?"
                    M.Status.farm = "âœ“ " .. rr .. " in backpack: " .. bn
                    M.Status.farmCount += 1 task.wait(0.5) tool = nil
                end

                if not tool then
                    M.Status.farm = "Zoeken op map..."
                    local found = false
                    if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
                    if M.ActiveBrainrots then
                        for _, folder in pairs(M.ActiveBrainrots:GetChildren()) do
                            if not M.S.Farming then break end
                            if folder:IsA("Folder") and M.rarityMatches(folder.Name) then
                                for _, b in pairs(folder:GetChildren()) do
                                    if not M.S.Farming or M.isDead() then break end
                                    if M.matchesFilter(b, folder.Name) then
                                        local root = M.findBrainrotRoot(b) if not root then continue end
                                        found = true
                                        M.Status.farm = "Ophalen " .. folder.Name .. "..."
                                        M.safePathTo(root.CFrame * CFrame.new(0, 3, 0))
                                        for attempt = 1, 5 do
                                            if not M.S.Farming then break end
                                            if M.isDead() then
                                                M.waitForRespawn() task.wait(1)
                                                M.setHomePosition() M.enableGod()
                                                if not M.S.Farming then break end
                                                if root and root.Parent then M.safePathTo(root.CFrame * CFrame.new(0, 3, 0))
                                                else found = false break end
                                            end
                                            if root and root.Parent then
                                                M.forceGrabPrompt(root) M.forceGrabPrompt(b)
                                                task.wait(0.3) M.Status.farmCount += 1 break
                                            else found = false break end
                                        end
                                        M.safeUnequip() task.wait(0.1)
                                        M.Status.farm = "Terug via muur..."
                                        M.safeReturnToBase()
                                        break
                                    end
                                end
                            end
                            if found then break end
                        end
                    end
                    if not found then M.Status.farm = "Geen brainrots..." task.wait(2) return end
                    task.wait(0.3)
                    tool = M.findTargetToolInBackpack()
                    if not tool then M.Status.farm = "Item verloren..." task.wait(1) return end
                end

                if M.isHighRarityTool(tool) then
                    local rr = tool:GetAttribute("Rarity") or "High"
                    M.Status.farm = "âœ“ " .. rr .. " gepakt (backpack)"
                    M.Status.farmCount += 1 task.wait(0.5) return
                end

                local bName = tool:GetAttribute("BrainrotName") or "Brainrot"
                M.Status.farm = "Naar slot " .. ws
                M.tweenToSlot(ws) task.wait(0.3)
                M.safeEquip(tool) task.wait(0.5)
                M.Status.farm = "Plaatsen " .. bName
                M.placeBrainrot(ws) task.wait(0.8)
                if M.isSlotEmpty(ws) then
                    M.Status.farm = "Plaatsen mislukt..."
                    M.safeUnequip() task.wait(1) return
                end
                M.Status.farm = "Upgraden " .. bName .. "..."
                local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
                local sm = mb and mb:FindFirstChild("slot " .. ws .. " brainrot")
                if sm then
                    local cur = tonumber(sm:GetAttribute("Level")) or 0
                    local fails = 0
                    while cur < M.S.MaxLevel and M.S.Farming do
                        for i = 1, 3 do task.spawn(function() M.upgradeBrainrot(ws) end) end
                        task.wait()
                        local nw = tonumber(sm:GetAttribute("Level")) or cur
                        if nw > cur then
                            fails = 0 cur = nw M.Status.upgradeCount += 1
                            M.Status.farm = bName .. " Lv." .. cur .. "/" .. M.S.MaxLevel
                        else fails += 1 if fails > 60 then task.wait(1) break end end
                    end
                end
                M.Status.farm = bName .. " KLAAR!"
                task.wait(0.3)
                M.pickUpBrainrot(ws) task.wait(0.8)
                M.safeUnequip() task.wait(0.3)
                if not M.isSlotEmpty(ws) then
                    M.pickUpBrainrot(ws) task.wait(0.5)
                    M.safeUnequip() task.wait(0.3)
                end
                M.Status.farm = "Volgende..."
            end)
            if not ok then warn("[MzD Farm] " .. tostring(err)) task.wait(1) end
            task.wait(0.3)
        end
        M.disableGod()
        M.Status.farm = "Idle" M.farmThread = nil
    end)
end

function M.stopFarming()
    M.S.Farming = false
    if M.farmThread then pcall(task.cancel, M.farmThread) M.farmThread = nil end
    M.disableGod()
    M.Status.farm = "Idle"
end

-- ========== LUCKY BLOCKS ==========
local LB_KNOWN = {"Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity","Admin","UFO","Candy","Money"}

function M.getLuckyBlockRarities()
    return type(M.S.LuckyBlockRarity) == "table" and M.S.LuckyBlockRarity or {M.S.LuckyBlockRarity}
end

function M.luckyBlockRarityMatches(bn)
    for _, r in pairs(M.getLuckyBlockRarities()) do
        if r == "Any" or bn:find("" .. r) or bn == r then return true end
    end
    return false
end

function M.luckyBlockMutationMatches(block)
    local mut = block:GetAttribute("Mutation") or "None"
    local isNone = (mut:lower() == "none" or mut == "")
    if M.S.LuckyBlockMutation == "Any" then return true end
    if M.S.LuckyBlockMutation == "None" then return isNone end
    return mut == M.S.LuckyBlockMutation
end

function M.luckyBlockGetRarityFromName(bn)
    return bn:match("LuckyBlock_(.+)") or bn
end

function M.findLuckyBlockRoot(block)
    local r = block:FindFirstChild("Root")
    if r and r:IsA("BasePart") then return r end
    if block:IsA("BasePart") then return block end
    local p = nil pcall(function() p = block.PrimaryPart end) if p then return p end
    for _, d in pairs(block:GetDescendants()) do if d:IsA("BasePart") then return d end end
    return nil
end

function M.grabLuckyBlock(block, rootPart)
    if not block or not rootPart then return end
    local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    for _, d in pairs(block:GetDescendants()) do
        if d:IsA("ProximityPrompt") then
            pcall(function() d.MaxActivationDistance = 99999 d.HoldDuration = 0 end)
            pcall(function() fireproximityprompt(d) end)
        end
    end
    if rootPart:IsA("ProximityPrompt") then
        pcall(function() rootPart.MaxActivationDistance = 99999 rootPart.HoldDuration = 0 end)
        pcall(function() fireproximityprompt(rootPart) end)
    else
        for _, d in pairs(rootPart:GetDescendants()) do
            if d:IsA("ProximityPrompt") then
                pcall(function() d.MaxActivationDistance = 99999 d.HoldDuration = 0 end)
                pcall(function() fireproximityprompt(d) end)
            end
        end
    end
    if hrp then
        local function touchAll(obj)
            if obj:IsA("BasePart") then
                pcall(function() firetouchinterest(hrp, obj, 0) end)
                pcall(function() firetouchinterest(hrp, obj, 1) end)
            end
            for _, d in pairs(obj:GetDescendants()) do
                if d:IsA("BasePart") then
                    pcall(function() firetouchinterest(hrp, d, 0) end)
                    pcall(function() firetouchinterest(hrp, d, 1) end)
                end
            end
        end
        touchAll(block)
        if rootPart ~= block then touchAll(rootPart) end
    end
end

function M.startLuckyBlockFarm()
    if M.luckyBlockThread then return end
    M.S.LuckyBlockEnabled = true
    M.Status.luckyBlockCount = 0
    M.Status.luckyBlock = "Starten..."
    M.setHomePosition()
    M.enableGod()

    M.luckyBlockThread = task.spawn(function()
        while M.S.LuckyBlockEnabled do
            local ok, err = pcall(function()
                if M.isDead() then
                    M.Status.luckyBlock = "Dood! Wachten..."
                    M.waitForRespawn() task.wait(1)
                    M.setHomePosition() M.enableGod() task.wait(0.5) return
                end
                if not M.ActiveLuckyBlocks then M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks") end
                if not M.ActiveLuckyBlocks then M.Status.luckyBlock = "Geen folder!" task.wait(3) return end
                local ch = Player.Character
                local hum = ch and ch:FindFirstChild("Humanoid")
                if not ch or not hum then task.wait(1) return end
                M.Status.luckyBlock = "Scannen..."
                local foundBlock = false
                for _, block in pairs(M.ActiveLuckyBlocks:GetChildren()) do
                    if not M.S.LuckyBlockEnabled or M.isDead() then break end
                    if M.luckyBlockRarityMatches(block.Name) and M.luckyBlockMutationMatches(block) then
                        local rootPart = M.findLuckyBlockRoot(block)
                        if not rootPart then continue end
                        foundBlock = true
                        local rarityName = M.luckyBlockGetRarityFromName(block.Name)
                        M.Status.luckyBlock = "Ga naar " .. rarityName .. "..."
                        M.safePathTo(rootPart.CFrame * CFrame.new(0, 3, 0))
                        M.Status.luckyBlock = "Openen " .. rarityName .. "..."
                        M.grabLuckyBlock(block, rootPart)
                        local t = tick()
                        while tick() - t < 0.2 do
                            if not block.Parent or not rootPart.Parent then break end
                            task.wait(0.02)
                        end
                        if not block.Parent or not rootPart.Parent then
                            M.Status.luckyBlockCount += 1
                            M.Status.luckyBlock = rarityName .. " geopend! (#" .. M.Status.luckyBlockCount .. ")"
                        else
                            M.Status.luckyBlock = rarityName .. " geprobeerd..."
                        end
                        M.safeUnequip()
                        M.Status.luckyBlock = "Terug via muur..."
                        M.safeReturnToBase()
                        break
                    end
                end
                if not foundBlock then M.Status.luckyBlock = "Geen blocks, wachten..." task.wait(2) end
            end)
            if not ok then warn("[MzD LB] " .. tostring(err)) task.wait(1) end
            task.wait(0.1)
        end
        M.disableGod()
        M.Status.luckyBlock = "Idle" M.luckyBlockThread = nil
    end)
end

function M.stopLuckyBlockFarm()
    M.S.LuckyBlockEnabled = false
    if M.luckyBlockThread then pcall(task.cancel, M.luckyBlockThread) M.luckyBlockThread = nil end
    M.disableGod()
    M.Status.luckyBlock = "Idle"
end

function M.scanLuckyBlockTypes()
    local found, seen = {}, {}
    if not M.ActiveLuckyBlocks then M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks") end
    if M.ActiveLuckyBlocks then
        for _, c in pairs(M.ActiveLuckyBlocks:GetChildren()) do
            local nm = c.Name:match("LuckyBlock(.+)")
            if nm and not seen[nm] then seen[nm] = true table.insert(found, nm) end
            local ar = c:GetAttribute("Rarity")
            if ar and not seen[ar] then seen[ar] = true table.insert(found, ar) end
        end
    end
    for _, k in pairs(LB_KNOWN) do
        if not seen[k] then seen[k] = true table.insert(found, k) end
    end
    table.sort(found) return found
end

-- ========== MONEY ==========
function M.startMoney()
    if M.moneyThread then return end
    M.S.AutoCollectMoney = true M.Status.money = "Actief"
    if not M.baseGUID then M.findBase() end
    M.moneyThread = task.spawn(function()
        while M.S.AutoCollectMoney do
            pcall(function()
                if not M.baseGUID then M.findBase() end
                if not M.baseGUID then return end
                local mb = workspace:FindFirstChild("Bases") and workspace.Bases:FindFirstChild(M.baseGUID)
                local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
                if not mb or not hrp then return end
                for i = 1, 40 do
                    local sm = mb:FindFirstChild("slot " .. i .. " brainrot")
                    if sm and sm:GetAttribute("BrainrotName") and sm:GetAttribute("BrainrotName") ~= "" then
                        for _, d in pairs(sm:GetDescendants()) do
                            if d:IsA("BasePart") then
                                pcall(function() firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end)
                            end
                        end
                    end
                end
            end) task.wait(0.1)
        end
        M.Status.money = "Idle"
    end)
    M.moneyRemoteThread = task.spawn(function()
        while M.S.AutoCollectMoney do
            pcall(function()
                if M.baseGUID and M.PlotAction then
                    for i = 1, 40 do
                        task.spawn(function()
                            pcall(function() M.PlotAction:InvokeServer("Collect Money", M.baseGUID, tostring(i)) end)
                        end)
                    end
                end
            end) task.wait(1)
        end
    end)
end

function M.stopMoney()
    M.S.AutoCollectMoney = false
    if M.moneyThread then pcall(task.cancel, M.moneyThread) M.moneyThread = nil end
    if M.moneyRemoteThread then pcall(task.cancel, M.moneyRemoteThread) M.moneyRemoteThread = nil end
    M.Status.money = "Idle"
end

-- ========== AUTO UPGRADE ==========
function M.startAutoUpgrade()
    if M.upgradeThread then return end
    M.S.AutoUpgrade = true M.Status.upgradeCount = 0
    M.upgradeThread = task.spawn(function()
        while M.S.AutoUpgrade do
            pcall(function()
                for _, info in pairs(M.findOccupiedSlots()) do
                    if not M.S.AutoUpgrade then break end
                    if info.level < M.S.MaxLevel then M.upgradeSlotToMax(info.slot) end
                end
                M.Status.upgrade = "Klaar (#" .. M.Status.upgradeCount .. ")"
            end) task.wait(3)
        end
        M.Status.upgrade = "Idle"
    end)
end

function M.stopAutoUpgrade()
    M.S.AutoUpgrade = false
    if M.upgradeThread then pcall(task.cancel, M.upgradeThread) M.upgradeThread = nil end
    M.Status.upgrade = "Idle"
end

-- ========== ANTI AFK ==========
function M.startAFK()
    if M.afkThread then return end
    M.S.AntiAFK = true M.Status.afk = "Actief"
    pcall(function() for _, c in pairs(getconnections(Player.Idled)) do c:Disable() end end)
    pcall(function()
        local vu = game:GetService("VirtualUser")
        M._afkSteppedConn = RunService.Stepped:Connect(function()
            if M.S.AntiAFK then pcall(function() vu:CaptureController() vu:ClickButton2(Vector2.new()) end) end
        end)
    end)
    M.afkThread = task.spawn(function()
        while M.S.AntiAFK do
            pcall(function() for _, c in pairs(getconnections(Player.Idled)) do c:Disable() end end)
            task.wait(300)
        end
        M.Status.afk = "Uit"
    end)
end

function M.stopAFK()
    M.S.AntiAFK = false
    if M.afkThread then pcall(task.cancel, M.afkThread) M.afkThread = nil end
    if M._afkSteppedConn then pcall(function() M._afkSteppedConn:Disconnect() end) M._afkSteppedConn = nil end
    M.Status.afk = "Uit"
end

-- ========== INSTANT PICKUP ==========
function M.setupInstant()
    for _, o in pairs(workspace:GetDescendants()) do
        if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration = 0 end) end
    end
    if not M._instantConn then
        M._instantConn = workspace.DescendantAdded:Connect(function(o)
            if o:IsA("ProximityPrompt") then pcall(function() o.HoldDuration = 0 end) end
        end)
    end
end
M.setupInstant()

-- ========== VALENTINE HELPERS ==========
function M.getHeartCount()
    local count = 0
    pcall(function()
        local ls = Player:FindFirstChild("leaderstats")
        if ls then
            for _, v in pairs(ls:GetChildren()) do
                local n = v.Name:lower()
                if n:find("heart") or n:find("candy") or n:find("valentine") or n:find("gram") or n:find("love") then
                    count = tonumber(v.Value) or 0
                    return
                end
            end
        end
    end)
    if count == 0 then
        pcall(function()
            for _, attr in pairs({"Hearts","Candy","CandyGrams","Valentines","Love","CandyHearts","ValentineHearts"}) do
                local v = Player:GetAttribute(attr)
                if v and tonumber(v) and tonumber(v) > 0 then
                    count = tonumber(v) return
                end
            end
        end)
    end
    if count == 0 then
        pcall(function()
            local ch = Player.Character
            if ch then
                for _, attr in pairs({"Hearts","Candy","CandyGrams","Valentines"}) do
                    local v = ch:GetAttribute(attr)
                    if v and tonumber(v) and tonumber(v) > 0 then
                        count = tonumber(v) return
                    end
                end
            end
        end)
    end
    if count == 0 then
        pcall(function()
            for _, gui in pairs(Player.PlayerGui:GetDescendants()) do
                if gui:IsA("TextLabel") then
                    local txt = gui.Text:lower()
                    if txt:find("heart") or txt:find("candy") or txt:find("/100") or txt:find("gram") then
                        local num = gui.Text:match("(%d+)")
                        if num and tonumber(num) > 0 then count = tonumber(num) return end
                    end
                end
            end
        end)
    end
    if count == 0 then
        pcall(function()
            for _, v in pairs(Player:GetDescendants()) do
                if (v:IsA("IntValue") or v:IsA("NumberValue")) then
                    local n = v.Name:lower()
                    if n:find("heart") or n:find("candy") or n:find("gram") or n:find("valentine") then
                        if tonumber(v.Value) and tonumber(v.Value) > 0 then
                            count = tonumber(v.Value) return
                        end
                    end
                end
            end
        end)
    end
    return count
end

function M.refreshValentineCache()
    M._valentineCachedParts = {}
    M._valentineLastCacheScan = tick()
    local keywords = {"heart","candy","valentine","love","gram","pickup","collect","token","coin"}
    local function shouldCache(obj)
        if not obj:IsA("BasePart") then return false end
        local n = obj.Name:lower()
        for _, k in pairs(keywords) do if n:find(k) then return true end end
        if obj.Parent then
            local pn = obj.Parent.Name:lower()
            for _, k in pairs(keywords) do if pn:find(k) then return true end end
            if obj.Parent.Parent then
                local gpn = obj.Parent.Parent.Name:lower()
                for _, k in pairs(keywords) do if gpn:find(k) then return true end end
            end
        end
        if obj:FindFirstChild("TouchInterest") then return true end
        return false
    end
    for _, obj in pairs(workspace:GetDescendants()) do
        if shouldCache(obj) then table.insert(M._valentineCachedParts, obj) end
    end
    local eventFolders = {"ValentineItems","Hearts","CandyGrams","Valentines","EventItems","Collectibles","Pickups","CandyHearts","ValentineEvent","EventCollectibles","Tokens","Coins"}
    for _, fn in pairs(eventFolders) do
        local f = workspace:FindFirstChild(fn)
        if f then
            for _, d in pairs(f:GetDescendants()) do
                if d:IsA("BasePart") then table.insert(M._valentineCachedParts, d) end
            end
        end
    end
    for _, c in pairs(workspace:GetChildren()) do
        if c:IsA("Model") or c:IsA("Folder") then
            local cn = c.Name:lower()
            if cn:find("valentine") or cn:find("event") or cn:find("heart") or cn:find("candy") then
                for _, d in pairs(c:GetDescendants()) do
                    if d:IsA("BasePart") and d:FindFirstChild("TouchInterest") then
                        table.insert(M._valentineCachedParts, d)
                    end
                end
            end
        end
    end
end

function M._valentineOnDescAdded(d)
    if not M.S.ValentineEnabled then return end
    local keywords = {"heart","candy","valentine","love","gram","pickup","collect","token"}
    if d:IsA("BasePart") then
        local n = d.Name:lower()
        local matched = false
        for _, k in pairs(keywords) do if n:find(k) then matched = true break end end
        if not matched and d.Parent then
            local pn = d.Parent.Name:lower()
            for _, k in pairs(keywords) do if pn:find(k) then matched = true break end end
        end
        if not matched and d:FindFirstChild("TouchInterest") then matched = true end
        if matched then
            table.insert(M._valentineCachedParts, d)
            pcall(function()
                local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then firetouchinterest(hrp, d, 0) firetouchinterest(hrp, d, 1) end
            end)
        end
    end
    if d:IsA("ProximityPrompt") then
        pcall(function() d.HoldDuration = 0 d.MaxActivationDistance = 99999 end)
    end
end

-- ========== VALENTINE REMOTE SCANNER ==========
function M.scanValentineRemotes()
    M._valentineFoundRemotes = {}
    M._valentineDebugLog = {}
    local keywords = {"valentine","candy","heart","gram","gift","submit","turn","exchange","redeem","deliver","deposit","collect","love","token"}
    local function addLog(msg)
        table.insert(M._valentineDebugLog, msg)
        print("[MzD V-Debug] " .. msg)
    end
    local function scanFolder(parent, path, depth)
        if depth > 10 then return end
        for _, v in pairs(parent:GetChildren()) do
            local n = v.Name:lower()
            local fullPath = path .. "/" .. v.Name
            local matched = false
            for _, k in pairs(keywords) do if n:find(k) then matched = true break end end
            if matched then
                local rType = "Unknown"
                if v:IsA("RemoteEvent") then rType = "RemoteEvent"
                elseif v:IsA("RemoteFunction") then rType = "RemoteFunction"
                elseif v:IsA("BindableEvent") then rType = "BindableEvent"
                elseif v:IsA("BindableFunction") then rType = "BindableFunction"
                else rType = v.ClassName end
                table.insert(M._valentineFoundRemotes, {name = v.Name, path = fullPath, type = rType, object = v})
                addLog("âœ“ " .. rType .. ": " .. fullPath)
            end
            scanFolder(v, fullPath, depth + 1)
        end
    end
    addLog("=== VALENTINE REMOTE SCAN ===")
    pcall(function() addLog("Scanning ReplicatedStorage...") scanFolder(game:GetService("ReplicatedStorage"), "RS", 0) end)
    pcall(function()
        addLog("Scanning Workspace voor stations...")
        local stationKeywords = {"station","gram","submit","turn","exchange","valentine","heart","candy"}
        for _, c in pairs(workspace:GetDescendants()) do
            if c:IsA("ProximityPrompt") then
                local pn = c.Parent and c.Parent.Name:lower() or ""
                local ppn = c.Parent and c.Parent.Parent and c.Parent.Parent.Name:lower() or ""
                for _, k in pairs(stationKeywords) do
                    if pn:find(k) or ppn:find(k) then
                        table.insert(M._valentineFoundRemotes, {name = c.Name, path = "WS/" .. (c.Parent and c.Parent.Name or "?") .. "/" .. c.Name, type = "ProximityPrompt", object = c})
                        addLog("âœ“ Prompt: " .. (c.Parent and c.Parent.Name or "?") .. "/" .. c.Name)
                        break
                    end
                end
            end
        end
    end)
    pcall(function()
        addLog("Scanning Player values...")
        for _, v in pairs(Player:GetDescendants()) do
            if v:IsA("IntValue") or v:IsA("NumberValue") or v:IsA("StringValue") then
                local n = v.Name:lower()
                for _, k in pairs(keywords) do
                    if n:find(k) then addLog("âœ“ Value: " .. v:GetFullName() .. " = " .. tostring(v.Value)) break end
                end
            end
        end
        for _, attr in pairs({"Hearts","Candy","CandyGrams","Valentines","Love","CandyHearts","ValentineHearts"}) do
            local v = Player:GetAttribute(attr)
            if v ~= nil then addLog("âœ“ Attr: Player." .. attr .. " = " .. tostring(v)) end
        end
    end)
    addLog("=== Gevonden: " .. #M._valentineFoundRemotes .. " remotes/prompts ===")
    addLog("Hearts count: " .. M.getHeartCount())
    return M._valentineFoundRemotes, M._valentineDebugLog
end

-- ========== VALENTINE SUBMIT ==========
function M.submitHearts()
    local submitted = false
    if #M._valentineFoundRemotes > 0 then
        for _, remote in pairs(M._valentineFoundRemotes) do
            local obj = remote.object
            if obj and obj.Parent then
                if remote.type == "RemoteEvent" then
                    pcall(function() obj:FireServer() submitted = true end)
                    pcall(function() obj:FireServer(true) end)
                    pcall(function() obj:FireServer(Player.Character) end)
                    pcall(function() obj:FireServer("submit") end)
                    pcall(function() obj:FireServer(100) end)
                elseif remote.type == "RemoteFunction" then
                    pcall(function() obj:InvokeServer() submitted = true end)
                    pcall(function() obj:InvokeServer(true) end)
                    pcall(function() obj:InvokeServer("submit") end)
                    pcall(function() obj:InvokeServer(100) end)
                elseif remote.type == "ProximityPrompt" then
                    pcall(function() obj.MaxActivationDistance = math.huge obj.HoldDuration = 0 fireproximityprompt(obj) submitted = true end)
                end
            end
        end
    end
    pcall(function()
        local rs = game:GetService("ReplicatedStorage")
        local keywords = {"valentine","candy","submit","heart","gram","gift","collect","turn","exchange","redeem","deliver","deposit","love"}
        local function searchRemotes(parent, depth)
            if depth > 8 then return end
            for _, v in pairs(parent:GetChildren()) do
                local n = v.Name:lower()
                local matched = false
                for _, k in pairs(keywords) do if n:find(k) then matched = true break end end
                if matched then
                    if v:IsA("RemoteEvent") then
                        pcall(function() v:FireServer() end) pcall(function() v:FireServer(true) end)
                        pcall(function() v:FireServer("submit") end) pcall(function() v:FireServer(Player.Character) end)
                        submitted = true
                    elseif v:IsA("RemoteFunction") then
                        pcall(function() v:InvokeServer() end) pcall(function() v:InvokeServer(true) end)
                        pcall(function() v:InvokeServer("submit") end)
                        submitted = true
                    end
                end
                searchRemotes(v, depth + 1)
            end
        end
        searchRemotes(rs, 0)
    end)
    pcall(function()
        local net = game:GetService("ReplicatedStorage"):FindFirstChild("Packages")
        if net then net = net:FindFirstChild("Net") end
        if not net then return end
        for _, v in pairs(net:GetDescendants()) do
            local n = v.Name:lower()
            if n:find("candy") or n:find("heart") or n:find("valentine") or n:find("gram") or n:find("submit") or n:find("collect") then
                if v:IsA("RemoteFunction") then pcall(function() v:InvokeServer() submitted = true end) pcall(function() v:InvokeServer(true) end)
                elseif v:IsA("RemoteEvent") then pcall(function() v:FireServer() submitted = true end) pcall(function() v:FireServer(true) end) end
            end
        end
    end)
    pcall(function()
        local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        for _, d in pairs(workspace:GetDescendants()) do
            if d:IsA("ProximityPrompt") then
                local pn = d.Parent and d.Parent.Name:lower() or ""
                local ppn = d.Parent and d.Parent.Parent and d.Parent.Parent.Name:lower() or ""
                if pn:find("station") or pn:find("gram") or pn:find("submit") or pn:find("valentine") or pn:find("heart") or ppn:find("station") or ppn:find("gram") or ppn:find("submit") or ppn:find("valentine") then
                    pcall(function() d.MaxActivationDistance = math.huge d.HoldDuration = 0 fireproximityprompt(d) submitted = true end)
                end
            end
        end
        for _, d in pairs(workspace:GetDescendants()) do
            if d:IsA("BasePart") then
                local n = d.Name:lower()
                local pn = d.Parent and d.Parent.Name:lower() or ""
                if n:find("station") or n:find("submit") or n:find("gram") or pn:find("station") or pn:find("submit") or pn:find("gram") then
                    pcall(function() firetouchinterest(hrp, d, 0) end) pcall(function() firetouchinterest(hrp, d, 1) end)
                end
            end
        end
    end)
    pcall(function()
        if M.PlotAction then
            pcall(function() M.PlotAction:InvokeServer("Submit Hearts") end)
            pcall(function() M.PlotAction:InvokeServer("Submit Candy") end)
            pcall(function() M.PlotAction:InvokeServer("Submit CandyGram") end)
            pcall(function() M.PlotAction:InvokeServer("Collect Valentine") end)
        end
    end)
    return submitted
end

-- ========== VALENTINE MAIN ==========
function M.startValentine()
    if M.valentineThread then return end
    M.S.ValentineEnabled = true
    M.Status.valentineCount = 0
    M._valentineCollecting = true
    M.scanValentineRemotes()
    M.refreshValentineCache()
    if M._valentineDescAddedConn then pcall(function() M._valentineDescAddedConn:Disconnect() end) end
    M._valentineDescAddedConn = workspace.DescendantAdded:Connect(function(d)
        pcall(function() M._valentineOnDescAdded(d) end)
    end)
    M.valentineCollectorConn = RunService.Heartbeat:Connect(function()
        if not M.S.ValentineEnabled or not M._valentineCollecting then return end
        pcall(function()
            local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            if tick() - M._valentineLastCacheScan > 10 then
                local alive = {}
                for _, p in pairs(M._valentineCachedParts) do if p and p.Parent then table.insert(alive, p) end end
                M._valentineCachedParts = alive
                M._valentineLastCacheScan = tick()
            end
            for _, p in pairs(M._valentineCachedParts) do
                if p and p.Parent then firetouchinterest(hrp, p, 0) firetouchinterest(hrp, p, 1) end
            end
        end)
    end)
    M.valentineTurboThread = task.spawn(function()
        while M.S.ValentineEnabled do
            if M._valentineCollecting then
                pcall(function()
                    local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
                    if not hrp then return end
                    for _, p in pairs(M._valentineCachedParts) do
                        if p and p.Parent then firetouchinterest(hrp, p, 0) firetouchinterest(hrp, p, 1) end
                    end
                end)
            end
            task.wait()
        end
    end)
    M.valentineNoclipConn = RunService.Stepped:Connect(function()
        if not M.S.ValentineEnabled then return end
        pcall(function()
            if Player.Character then
                for _, p in pairs(Player.Character:GetDescendants()) do
                    if p:IsA("BasePart") then p.CanCollide = false end
                end
            end
        end)
    end)
    M.valentineThread = task.spawn(function()
        local submitCooldown = 0
        local remoteScanCooldown = 0
        while M.S.ValentineEnabled do
            local ok, err = pcall(function()
                if tick() - remoteScanCooldown > 60 then
                    M.scanValentineRemotes()
                    remoteScanCooldown = tick()
                end
                local h = M.getHeartCount()
                M.Status.valentine = "Collecten " .. h .. " | Cache:" .. #M._valentineCachedParts .. " | R:" .. #M._valentineFoundRemotes .. " | #" .. M.Status.valentineCount
                if h >= 100 then
                    if tick() - submitCooldown < 1 then task.wait(0.2) return end
                    M.Status.valentine = "Inleveren... (" .. h .. " harten)"
                    M._valentineCollecting = false
                    task.wait(0.3)
                    local prevH = h
                    local success = false
                    for attempt = 1, 10 do
                        if not M.S.ValentineEnabled then break end
                        M.Status.valentine = "Submit poging " .. attempt .. "/10... (H:" .. M.getHeartCount() .. ")"
                        M.submitHearts()
                        task.wait(0.8)
                        local newH = M.getHeartCount()
                        if newH < prevH or newH == 0 then
                            M.Status.valentineCount += 1
                            M.Status.valentine = "âœ“ Ingeleverd! (#" .. M.Status.valentineCount .. ")"
                            submitCooldown = tick()
                            success = true
                            break
                        end
                        task.wait(0.5)
                    end
                    if not success then
                        M.Status.valentine = "Submit mislukt! Check debug. Verder collecten..."
                        submitCooldown = tick() + 5
                    end
                    task.wait(0.5)
                    M.refreshValentineCache()
                    M._valentineCollecting = true
                end
            end)
            if not ok then warn("[MzD Valentine] " .. tostring(err)) end
            task.wait(0.5)
        end
        M.Status.valentine = "Idle"
        M.valentineThread = nil
    end)
end

function M.stopValentine()
    M.S.ValentineEnabled = false M._valentineCollecting = false
    if M.valentineThread then pcall(task.cancel, M.valentineThread) M.valentineThread = nil end
    if M.valentineTurboThread then pcall(task.cancel, M.valentineTurboThread) M.valentineTurboThread = nil end
    if M.valentineCollectorConn then pcall(function() M.valentineCollectorConn:Disconnect() end) M.valentineCollectorConn = nil end
    if M.valentineNoclipConn then pcall(function() M.valentineNoclipConn:Disconnect() end) M.valentineNoclipConn = nil end
    if M._valentineDescAddedConn then pcall(function() M._valentineDescAddedConn:Disconnect() end) M._valentineDescAddedConn = nil end
    M._valentineCachedParts = {}
    pcall(function()
        if Player.Character then
            for _, p in pairs(Player.Character:GetDescendants()) do
                if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then p.CanCollide = true end
            end
        end
    end)
    M.Status.valentine = "Idle"
end

-- ========== ARCADE ==========
function M.startArcade()
    if M.arcadeThread then return end
    M.S.ArcadeEnabled = true M.Status.arcadeCount = 0
    M.arcadeThread = task.spawn(function()
        while M.S.ArcadeEnabled do
            pcall(function()
                local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                for _, fn in pairs({"ArcadeEventConsoles","ArcadeEventTickets"}) do
                    local f = workspace:FindFirstChild(fn)
                    if f then
                        for _, item in pairs(f:GetChildren()) do
                            if not M.S.ArcadeEnabled then break end
                            for _, d in pairs(item:GetDescendants()) do
                                if d:IsA("BasePart") and d:FindFirstChild("TouchInterest") then
                                    pcall(function() firetouchinterest(hrp, d, 0) task.wait(0.01) firetouchinterest(hrp, d, 1) end)
                                    M.Status.arcadeCount += 1
                                end
                            end
                        end
                    end
                end
                M.Status.arcade = "Actief"
            end)
            task.wait(0.05)
        end
        M.Status.arcade = "Idle" M.arcadeThread = nil
    end)
end

function M.stopArcade()
    M.S.ArcadeEnabled = false
    if M.arcadeThread then pcall(task.cancel, M.arcadeThread) M.arcadeThread = nil end
    M.Status.arcade = "Idle"
end

-- ========== MAP FIXER ==========
local MF = {
    W = 350, WH = 50, WT = 2, INT = 3,
    BLK = Color3.fromRGB(0,0,0),
    GLD = Color3.fromRGB(255,200,50),
    GLW = Color3.fromRGB(255,215,0)
}
MF.SZ = MF.W/2
MF.WY = MF.WH/2

local function isOwnWall(obj)
    local p = obj.Parent
    while p do if p.Name == "MzDHubWalls" then return true end p = p.Parent end
    return false
end

local function isOwnGodFloor(obj)
    return obj.Name == "MzDGodFloor" or obj.Name == "MzDGodCatchFloor"
end

local function safeDestroyFolder(parent, folderName)
    if not parent then return end
    local f = parent:FindFirstChild(folderName)
    if not f then return end
    if f.Name == "MzDHubWalls" then return end
    pcall(function()
        for _, d in pairs(f:GetDescendants()) do if d:IsA("BasePart") then d:Destroy() end end
        f:Destroy()
    end)
end

local MAP_FOLDERS_REMOVE = {"RightWalls","LeftWalls","Gaps","VIPWalls","SideWalls","Barriers","Fences","Walls","Decorations"}
local EVENT_FOLDERS_REMOVE = {"Walls","Decorations","Barriers","Fences","SideWalls","Blockers"}
local EVENT_MAPS = {"ValentinesMap","ArcadeMap","CandyMap","HalloweenMap","ChristmasMap","EasterMap","SummerMap","SpringMap","WinterMap"}

local function isWallPart(p)
    if not p:IsA("BasePart") then return false end
    if isOwnWall(p) then return false end
    if isOwnGodFloor(p) then return false end
    local n = p.Name:lower()
    local keywords = {"vipwall","sidewall","barrier","fence","blocker","border"}
    for _, k in pairs(keywords) do if n == k or n:find("^"..k) then return true end end
    if p.Size.Y > 15 and p.Size.Y > p.Size.X * 3 and p.Size.Y > p.Size.Z * 3 then
        if math.abs(p.Position.Z) > 60 then return true end
    end
    return false
end

function M.mapDetectXRange(map, si)
    local minX, maxX = math.huge, -math.huge
    local found = false
    local function chk(p)
        if not p:IsA("BasePart") then return end
        if isOwnWall(p) then return end
        if isOwnGodFloor(p) then return end
        if p.Size.Y > p.Size.X and p.Size.Y > p.Size.Z then return end
        if p.Position.Y > 50 or p.Position.Y < -30 then return end
        if p.Size.X < 5 then return end
        local l = p.Position.X - p.Size.X/2
        local r = p.Position.X + p.Size.X/2
        if l < minX then minX = l end
        if r > maxX then maxX = r end
        found = true
    end
    for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") then chk(c) end end
    local sp = map:FindFirstChild("Spawners")
    if sp then for _, s in pairs(sp:GetChildren()) do chk(s) end end
    if si then
        for _, c in pairs(si:GetChildren()) do if c:IsA("BasePart") then chk(c) end end
        local sf = si:FindFirstChild("Floors")
        if sf then for _, f in pairs(sf:GetChildren()) do chk(f) end end
    end
    if found and maxX > minX then return minX - 5, maxX + 5 end
    return -15, 4385
end

function M.mapFindShared(mn) return workspace:FindFirstChild(mn .. "_SharedInstances") end

local function getFloorParts(map, si)
    local fl = {}
    local function af(p)
        if not p:IsA("BasePart") then return end
        if isOwnWall(p) then return end
        if isOwnGodFloor(p) then return end
        if p.Size.Y > p.Size.X and p.Size.Y > p.Size.Z then return end
        if p.Position.Y > 30 or p.Position.Y < -20 then return end
        if p.Size.X < 5 then return end
        for _, f in pairs(fl) do if f == p then return end end
        table.insert(fl, p)
    end
    local ff = map:FindFirstChild("FirstFloor") if ff and ff:IsA("BasePart") then af(ff) end
    local gr = map:FindFirstChild("Ground") if gr and gr:IsA("BasePart") then af(gr) end
    local sp = map:FindFirstChild("Spawners")
    if sp then for _, s in pairs(sp:GetChildren()) do if s:IsA("BasePart") then af(s) end end end
    for _, c in pairs(map:GetChildren()) do
        if c:IsA("BasePart") then
            local n = c.Name:lower()
            if n=="firstfloor" or n=="ground" or n=="bridgefloor" or n=="floor" or n=="grass" or n=="path" or n=="road" or n=="platform" then af(c) end
        end
    end
    for _, c in pairs(map:GetChildren()) do
        if c:IsA("BasePart") and c.Size.X > 50 and c.Size.Z > 10 and c.Size.Y < 10 then af(c) end
    end
    if si then
        local sf = si:FindFirstChild("Floors")
        if sf then for _, f in pairs(sf:GetChildren()) do if f:IsA("BasePart") then af(f) end end end
        for _, c in pairs(si:GetChildren()) do
            if c:IsA("BasePart") and c.Size.X > 50 and c.Size.Z > 10 and c.Size.Y < 10 then af(c) end
        end
    end
    return fl
end

function M.mapCleanup(map)
    for _, n in pairs(MAP_FOLDERS_REMOVE) do safeDestroyFolder(map, n) end
    for _, d in pairs(map:GetDescendants()) do
        if d.Parent and not isOwnWall(d) and not isOwnGodFloor(d) and d:IsA("BasePart") then
            if isWallPart(d) then pcall(function() d:Destroy() end) end
        end
    end
end

function M.mapCleanupShared(si)
    if not si then return end
    for _, n in pairs(MAP_FOLDERS_REMOVE) do safeDestroyFolder(si, n) end
    for _, d in pairs(si:GetDescendants()) do
        if d:IsA("BasePart") and not isOwnWall(d) and not isOwnGodFloor(d) and isWallPart(d) then pcall(function() d:Destroy() end) end
    end
end

function M.mapCleanupMisc()
    local misc = workspace:FindFirstChild("Misc")
    if misc then
        for _, c in pairs(misc:GetChildren()) do
            if c.Name == "BrickAddition" or c.Name == "Roof" then pcall(function() c:Destroy() end) end
        end
    end
end

function M.cleanupEventMaps()
    for _, mapName in pairs(EVENT_MAPS) do
        local eventMap = workspace:FindFirstChild(mapName)
        if eventMap then
            for _, folderName in pairs(EVENT_FOLDERS_REMOVE) do safeDestroyFolder(eventMap, folderName) end
            for _, d in pairs(eventMap:GetDescendants()) do
                if d:IsA("BasePart") and not isOwnWall(d) and not isOwnGodFloor(d) and isWallPart(d) then pcall(function() d:Destroy() end) end
            end
        end
    end
    local currentMap = M.mapFindCurrentMap()
    for _, obj in pairs(workspace:GetChildren()) do
        if obj:IsA("Model") and obj.Name:lower():find("map") and obj ~= currentMap then
            for _, folderName in pairs(EVENT_FOLDERS_REMOVE) do safeDestroyFolder(obj, folderName) end
        end
    end
end

function M.mapWidenFloors(map, si)
    for _, p in pairs(getFloorParts(map, si)) do
        pcall(function()
            if math.abs(p.Size.Z - MF.W) > 1 then
                p.Size = Vector3.new(p.Size.X, p.Size.Y, MF.W)
                p.Position = Vector3.new(p.Position.X, p.Position.Y, 0)
            end
        end)
    end
end

function M.mapFillGaps(map, sx, ex)
    local ref = nil
    local ff = map:FindFirstChild("FirstFloor") if ff and ff:IsA("BasePart") then ref = ff end
    if not ref then local g = map:FindFirstChild("Ground") if g and g:IsA("BasePart") then ref = g end end
    if not ref then
        local sp = map:FindFirstChild("Spawners")
        if sp then for _, s in pairs(sp:GetChildren()) do if s:IsA("BasePart") then ref = s break end end end
    end
    if not ref then
        for _, c in pairs(map:GetChildren()) do
            if c:IsA("BasePart") and not isOwnGodFloor(c) and c.Size.X > 50 and c.Size.Y < 10 and c.Position.Y < 20 then ref = c break end
        end
    end
    if not ref then return end
    local fY, fH, fC, fM = ref.Position.Y, ref.Size.Y, ref.Color, ref.Material
    local segs = {}
    local function as(p)
        if p:IsA("BasePart") and not isOwnGodFloor(p) and p.Size.X > 3 and math.abs(p.Position.Y - fY) < 10 and p.Size.Y < 15 then
            if not isOwnWall(p) then
                table.insert(segs, {s = p.Position.X - p.Size.X/2, e = p.Position.X + p.Size.X/2})
            end
        end
    end
    for _, c in pairs(map:GetChildren()) do if c:IsA("BasePart") then as(c) end end
    local sp = map:FindFirstChild("Spawners")
    if sp then for _, s in pairs(sp:GetChildren()) do as(s) end end
    if #segs == 0 then return end
    table.sort(segs, function(a, b) return a.s < b.s end)
    local mg = {segs[1]}
    for i = 2, #segs do
        local l = mg[#mg]
        if segs[i].s <= l.e + 1 then l.e = math.max(l.e, segs[i].e)
        else table.insert(mg, segs[i]) end
    end
    local function mb(x, w)
        local b = Instance.new("Part")
        b.Name = "BridgeFloor" b.Size = Vector3.new(w, fH, MF.W)
        b.Position = Vector3.new(x, fY, 0)
        b.Anchored = true b.CanCollide = true
        b.Color = fC b.Material = fM
        b.TopSurface = Enum.SurfaceType.Smooth b.BottomSurface = Enum.SurfaceType.Smooth
        b.Parent = map
    end
    if mg[1].s > sx + 1 then local w = mg[1].s - sx mb(sx + w/2, w) end
    for i = 1, #mg - 1 do
        local g = mg[i+1].s - mg[i].e
        if g > 0.5 then mb(mg[i].e + g/2, g) end
    end
    if mg[#mg].e < ex - 1 then local w = ex - mg[#mg].e mb(mg[#mg].e + w/2, w) end
end

function M.mapBuildWalls(map, sx, ex)
    local mf = map:FindFirstChild("MzDHubWalls")
    if mf then
        local fw = mf:FindFirstChild("FrontWall_1")
        if fw and math.abs(fw.Position.Z - (MF.SZ + MF.WT/2)) < 1 then
            M._wallZ_front = MF.SZ - 3
            M._wallZ_back = -MF.SZ + 3
            return
        end
        pcall(function() mf:Destroy() end)
    end
    mf = Instance.new("Folder") mf.Name = "MzDHubWalls" mf.Parent = map
    local function mw(nm, sz, ps)
        local w = Instance.new("Part")
        w.Name = nm w.Size = sz w.Position = ps
        w.Anchored = true w.CanCollide = true
        w.Color = MF.BLK w.Material = Enum.Material.SmoothPlastic
        w.TopSurface = Enum.SurfaceType.Smooth w.BottomSurface = Enum.SurfaceType.Smooth
        w.Parent = mf return w
    end
    local function ms(nm, sz, ps)
        local s = Instance.new("Part")
        s.Name = nm s.Size = sz s.Position = ps
        s.Anchored = true s.CanCollide = false
        s.Color = MF.GLD s.Material = Enum.Material.Neon
        s.Parent = mf
    end
    local function at(w, f)
        local sg = Instance.new("SurfaceGui")
        sg.Face = f sg.CanvasSize = Vector2.new(800, 400) sg.Parent = w
        local t = Instance.new("TextLabel")
        t.Size = UDim2.new(1,0,0.5,0) t.Position = UDim2.new(0,0,0.1,0)
        t.BackgroundTransparency = 1 t.Text = "MzD Hub"
        t.TextColor3 = MF.GLW t.TextScaled = true t.Font = Enum.Font.GothamBold t.Parent = sg
        local s2 = Instance.new("TextLabel")
        s2.Size = UDim2.new(0.6,0,0.2,0) s2.Position = UDim2.new(0.2,0,0.6,0)
        s2.BackgroundTransparency = 1 s2.Text = "v10.7"
        s2.TextColor3 = Color3.fromRGB(200,200,200) s2.TextScaled = true s2.Font = Enum.Font.Gotham s2.Parent = sg
    end
    local segs = {} local sl = 2000 local p = sx
    while p < ex do
        local l = math.min(sl, ex - p)
        table.insert(segs, {s = p, l = l})
        p = p + l
    end
    for i, s in pairs(segs) do
        local cx = s.s + s.l/2
        local fw = mw("FrontWall_"..i, Vector3.new(s.l, MF.WH, MF.WT), Vector3.new(cx, MF.WY, MF.SZ+MF.WT/2))
        at(fw, Enum.NormalId.Front) at(fw, Enum.NormalId.Back)
        ms("FS_t"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, MF.WY+MF.WH/2-0.75, MF.SZ+MF.WT+0.2))
        ms("FS_b"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, MF.WY-MF.WH/2+0.75, MF.SZ+MF.WT+0.2))
        ms("FS_m"..i, Vector3.new(s.l,0.5,0.3), Vector3.new(cx, MF.WY, MF.SZ+MF.WT+0.2))
        local bw = mw("BackWall_"..i, Vector3.new(s.l, MF.WH, MF.WT), Vector3.new(cx, MF.WY, -MF.SZ-MF.WT/2))
        at(bw, Enum.NormalId.Front) at(bw, Enum.NormalId.Back)
        ms("BS_t"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, MF.WY+MF.WH/2-0.75, -MF.SZ-MF.WT-0.2))
        ms("BS_b"..i, Vector3.new(s.l,1.5,0.3), Vector3.new(cx, MF.WY-MF.WH/2+0.75, -MF.SZ-MF.WT-0.2))
        ms("BS_m"..i, Vector3.new(s.l,0.5,0.3), Vector3.new(cx, MF.WY, -MF.SZ-MF.WT-0.2))
    end
    mw("LeftWall", Vector3.new(MF.WT, MF.WH, MF.SZ*2+MF.WT*2+2), Vector3.new(sx-MF.WT/2, MF.WY, 0))
    mw("RightWall", Vector3.new(MF.WT, MF.WH, MF.SZ*2+MF.WT*2+2), Vector3.new(ex+MF.WT/2, MF.WY, 0))
    M._wallZ_front = MF.SZ - 3
    M._wallZ_back = -MF.SZ + 3
end

function M.mapFixCollision(map, si, sx, ex)
    for _, p in pairs(getFloorParts(map, si)) do
        -- Bij god mode: originele vloeren NIET collision maken
        if M._isGod then
            pcall(function() p.CanCollide = false p.Transparency = 1 end)
        else
            pcall(function() p.CanCollide = true p.Transparency = 0 end)
        end
    end
    for _, c in pairs(map:GetChildren()) do
        if c:IsA("BasePart") and c.Name == "BridgeFloor" then
            if M._isGod then
                pcall(function() c.CanCollide = false c.Transparency = 1 c.Anchored = true end)
            else
                pcall(function() c.CanCollide = true c.Anchored = true end)
            end
        end
    end
    local mf = map:FindFirstChild("MzDHubWalls")
    if mf then
        for _, w in pairs(mf:GetChildren()) do
            if w:IsA("BasePart") then
                local n = w.Name
                if not n:find("_m") and not n:find("t") and not n:find("b") and not n:find("FS") and not n:find("BS") then
                    pcall(function() w.CanCollide = true w.Anchored = true end)
                end
            end
        end
    end
end

function M.mapRunFix()
    local map = M.mapFindCurrentMap()
    if not map then return end
    local si = M.mapFindShared(map.Name)
    local mc = map.Name ~= M.lastMapName
    if mc then M.lastMapName = map.Name end
    local sx, ex = M.mapDetectXRange(map, si)
    pcall(function() M.mapCleanup(map) end)
    pcall(function() M.mapCleanupShared(si) end)
    pcall(function() M.mapCleanupMisc() end)
    pcall(function() M.cleanupEventMaps() end)
    task.wait(0.1)
    pcall(function() M.mapWidenFloors(map, si) end)
    pcall(function() M.mapFillGaps(map, sx, ex) end)
    pcall(function() M.mapBuildWalls(map, sx, ex) end)
    pcall(function() M.mapFixCollision(map, si, sx, ex) end)
    if mc then M.Status.mapFixer = "Gefixed: " .. map.Name end
end

function M.startMapFixer()
    if M.mapFixerThread then return end
    M.S.MapFixerEnabled = true
    M.Status.mapFixer = "Starten..."
    pcall(function() M.mapRunFix() end)
    M.mapFixerThread = task.spawn(function()
        while M.S.MapFixerEnabled do
            pcall(function() M.mapRunFix() end)
            M.Status.mapFixer = "Actief (" .. (M.lastMapName ~= "" and M.lastMapName or "scannen") .. ")"
            task.wait(MF.INT)
        end
        M.Status.mapFixer = "Uit" M.mapFixerThread = nil
    end)
end

function M.stopMapFixer()
    M.S.MapFixerEnabled = false
    if M.mapFixerThread then pcall(task.cancel, M.mapFixerThread) M.mapFixerThread = nil end
    M.Status.mapFixer = "Uit"
end

print("[MzD Hub] Core v10.7 Geladen")

-- ============================================
-- GUI
-- ============================================
task.wait(0.5)

pcall(function()
    for _, gui in pairs(Player.PlayerGui:GetChildren()) do
        if gui:IsA("ScreenGui") then
            for _, d in pairs(gui:GetDescendants()) do
                if d:IsA("TextLabel") and d.Text == "MzD Hub" then gui:Destroy() break end
            end
        end
    end
end)
task.wait(0.3)

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local RAR = {"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity"}
local MUT = {"Any","None","Emerald","Gold","Blood","Diamond","Rainbow","Shadow","Crystal","Void"}
local FM = {"Collect","Collect, Place & Max"}
local FR = {"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity"}
local LBR = {"Any","Common","Uncommon","Rare","Epic","Legendary","Mythical","Cosmic","Secret","Celestial","Divine","Infinity","Admin","UFO","Candy","Money"}
local SL = {} for i = 1, 40 do table.insert(SL, tostring(i)) end
local SPD = {"200","400","600","800","1000","1500","2000","3000","4000","INSTANT"}
local SPM = {["200"]=200,["400"]=400,["600"]=600,["800"]=800,["1000"]=1000,["1500"]=1500,["2000"]=2000,["3000"]=3000,["4000"]=4000,["INSTANT"]=9999}
local CSPD = {"100","200","300","400","500","600","800","1000","1500","2000"}
local GODWALKY = {"-10","-15","-17","-20","-25","-30","-40","-50"}
local GODFLOORY = {"-15","-18","-20","-25","-30","-40","-50"}

local W = Fluent:CreateWindow({
    Title = "MzD Hub", SubTitle = "v10.7 - Escape Tsunami From Brainrot",
    TabWidth = 160, Size = UDim2.fromOffset(600, 500),
    Acrylic = true, Theme = "Dark", MinimizeKey = Enum.KeyCode.RightControl
})

-- ===== FARM TAB =====
local FT = W:AddTab({Title = "Farm", Icon = "swords"})
FT:AddParagraph({Title = "ðŸŒ¾ Filters", Content = "Celestial/Divine/Infinity negeert filters altijd"})
local BDD = nil
local RDD = FT:AddDropdown("FarmRarity", {Title = "Target Rarity", Values = RAR, Default = {"Common"}, Multi = true})
RDD:OnChanged(function(v)
    local s = {} for n, on in pairs(v) do if on then table.insert(s, n) end end
    if #s == 0 then s = {"Common"} end
    local any = false for _, r in pairs(s) do if r == "Any" then any = true break end end
    M.S.TargetRarity = any and "Any" or s
    M.S.SelectedBrainrots = {}
    pcall(function() BDD:SetValues(M.getBrainrotNamesMulti(M.S.TargetRarity)) BDD:SetValue({}) end)
end)
BDD = FT:AddDropdown("FarmBrainrots", {
    Title = "Specifieke Brainrots", Description = "Leeg = alle van rarity",
    Values = M.getBrainrotNamesMulti(M.S.TargetRarity), Default = {}, Multi = true
})
BDD:OnChanged(function(v)
    local s = {} for n, on in pairs(v) do if on then table.insert(s, n) end end
    M.S.SelectedBrainrots = s
end)
FT:AddDropdown("FarmMutation", {Title = "Mutatie Filter", Values = MUT, Default = "None", Multi = false}):OnChanged(function(v) M.S.TargetMutation = v end)
FT:AddDropdown("FarmMode", {Title = "Farm Mode", Values = FM, Default = M.S.FarmMode, Multi = false}):OnChanged(function(v) M.S.FarmMode = v end)
FT:AddDropdown("FarmSlot", {Title = "Werk Slot", Values = SL, Default = M.S.FarmSlot, Multi = false}):OnChanged(function(v) M.S.FarmSlot = v end)
FT:AddSlider("FarmMaxLevel", {Title = "Max Level", Default = M.S.MaxLevel, Min = 1, Max = 500, Rounding = 0}):OnChanged(function(v) M.S.MaxLevel = math.floor(v) end)
local FSP = FT:AddParagraph({Title = "Farm Status", Content = "Idle"})
local FPP = FT:AddParagraph({Title = "Statistieken", Content = "Geplaatst: 0 | Geupgrade: 0"})
local FTG = FT:AddToggle("FarmToggle", {Title = "ðŸš€ Auto Farm", Default = false})
FTG:OnChanged(function(v)
    if v then M.findBase() M.startFarming() Fluent:Notify({Title="Farm",Content="Gestart! God Mode aan âœ“\nJe loopt nu ONDER de vloer!",Duration=4})
    else M.stopFarming() Fluent:Notify({Title="Farm",Content="Gestopt. #"..M.Status.farmCount,Duration=3}) end
end)

FT:AddParagraph({Title = "ðŸŽ² Lucky Block Farm", Content = ""})
FT:AddDropdown("LBRarity", {Title = "Rarity", Values = LBR, Default = {"Common"}, Multi = true}):OnChanged(function(v)
    local s = {} for n, on in pairs(v) do if on then table.insert(s, n) end end
    if #s == 0 then s = {"Common"} end
    local any = false for _, r in pairs(s) do if r == "Any" then any = true break end end
    M.S.LuckyBlockRarity = any and {"Any"} or s
end)
FT:AddDropdown("LBMutation", {Title = "Mutatie", Values = MUT, Default = "Any", Multi = false}):OnChanged(function(v) M.S.LuckyBlockMutation = v end)
local LBSP = FT:AddParagraph({Title = "Lucky Block Status", Content = "Idle"})
local LBTG = FT:AddToggle("LBToggle", {Title = "ðŸŽ² Auto Lucky Block Farm", Default = false})
LBTG:OnChanged(function(v)
    if v then M.findBase() M.startLuckyBlockFarm() Fluent:Notify({Title="Lucky Block",Content="Gestart!",Duration=3})
    else M.stopLuckyBlockFarm() Fluent:Notify({Title="Lucky Block",Content="Gestopt. #"..M.Status.luckyBlockCount,Duration=3}) end
end)

-- ===== FACTORY TAB =====
local FCT = W:AddTab({Title = "Factory", Icon = "hammer"})
FCT:AddParagraph({Title = "ðŸ­ Factory", Content = "Maxet alle items in backpack.\nâš¡ Turbo Upgrade: 3x sneller!"})
FCT:AddDropdown("FactoryRarity", {Title = "Rarity", Values = FR, Default = M.S.FactoryRarity, Multi = false}):OnChanged(function(v) M.S.FactoryRarity = v end)
FCT:AddDropdown("FactoryMutation", {Title = "Mutatie", Values = MUT, Default = M.S.FactoryMutation, Multi = false}):OnChanged(function(v) M.S.FactoryMutation = v end)
FCT:AddDropdown("FactorySlot", {Title = "Werk Slot", Values = SL, Default = M.S.FactorySlot, Multi = false}):OnChanged(function(v) M.S.FactorySlot = v end)
FCT:AddSlider("FactoryMaxLevel", {Title = "Max Level", Default = M.S.FactoryMaxLevel, Min = 1, Max = 500, Rounding = 0}):OnChanged(function(v) M.S.FactoryMaxLevel = math.floor(v) end)
local FCSP = FCT:AddParagraph({Title = "Status", Content = "Idle"})
local FCTG = FCT:AddToggle("FactoryToggle", {Title = "ðŸ” Start Factory", Default = false})
FCTG:OnChanged(function(v)
    if v then M.findBase() M.startFactoryLoop() Fluent:Notify({Title="Factory",Content="Gestart! âš¡",Duration=4})
    else M.stopFactoryLoop() Fluent:Notify({Title="Factory",Content="Gestopt. #"..M.Status.factoryCount,Duration=3}) end
end)

-- ===== EVENTS TAB =====
local ET = W:AddTab({Title = "Events", Icon = "party-popper"})
ET:AddParagraph({Title = "ðŸ’ Valentine", Content = "Collecten + inleveren op afstand âœ“\nDebug beschikbaar in Config tab"})
local VSP = ET:AddParagraph({Title = "Status", Content = "Idle"})
local VTG = ET:AddToggle("ValentineToggle", {Title = "ðŸ’ Valentine Farm", Default = false})
VTG:OnChanged(function(v) if v then M.startValentine() else M.stopValentine() end end)
ET:AddParagraph({Title = "ðŸ•¹ï¸ Arcade", Content = ""})
local ASP = ET:AddParagraph({Title = "Status", Content = "Idle"})
local ATG = ET:AddToggle("ArcadeToggle", {Title = "ðŸ•¹ï¸ Arcade Collector", Default = false})
ATG:OnChanged(function(v) if v then M.startArcade() else M.stopArcade() end end)

-- ===== AUTO TAB =====
local AT2 = W:AddTab({Title = "Auto", Icon = "rocket"})
AT2:AddParagraph({Title = "ðŸ’° Auto Money", Content = ""})
local MSP = AT2:AddParagraph({Title = "Status", Content = "Idle"})
local MTG = AT2:AddToggle("MoneyToggle", {Title = "ðŸ’° Auto Collect Money", Default = false})
MTG:OnChanged(function(v) if v then M.findBase() M.startMoney() else M.stopMoney() end end)
AT2:AddParagraph({Title = "â¬†ï¸ Auto Upgrade", Content = ""})
local USP = AT2:AddParagraph({Title = "Status", Content = "Idle"})
local UTG = AT2:AddToggle("UpgradeToggle", {Title = "â¬†ï¸ Upgrade All Slots", Default = false})
UTG:OnChanged(function(v) if v then M.findBase() M.startAutoUpgrade() else M.stopAutoUpgrade() end end)
AT2:AddParagraph({Title = "ðŸ—ºï¸ Map Fixer", Content = ""})
local MFSP = AT2:AddParagraph({Title = "Status", Content = "Uit"})
local MFTG = AT2:AddToggle("MapToggle", {Title = "ðŸ—ºï¸ Map Fixer Loop", Default = false})
MFTG:OnChanged(function(v) if v then M.startMapFixer() else M.stopMapFixer() end end)
AT2:AddButton({Title = "ðŸ—ºï¸ Fix Map Eenmalig", Callback = function()
    pcall(function() M.mapRunFix() end) Fluent:Notify({Title="Map",Content="Gefixed!",Duration=3})
end})

-- God Mode sectie
AT2:AddParagraph({Title = "ðŸ›¡ï¸ God Mode v18", Content = "Vervangt de vloer naar Y=-20\nJij loopt eronder op Y=-17\nKill zone zit op Yâ‰ˆ0 â†’ jij bent eronder!\nBrainrots pakken via noclip + forceGrab âœ“"})
AT2:AddDropdown("GodWalkY", {
    Title = "Loop Hoogte (Y)",
    Description = "Hoe diep je onder de vloer loopt\n-17 = dicht bij kill zone maar brainrots in bereik\n-30 = veiliger maar verder weg",
    Values = GODWALKY,
    Default = "-17",
    Multi = false
}):OnChanged(function(v)
    M.S.GodWalkY = tonumber(v) or -17
    if M._isGod then
        godTeleportUnder()
    end
end)
AT2:AddDropdown("GodFloorY", {
    Title = "Vloer Hoogte (Y)",
    Description = "Waar de vervangende vloer komt\nMoet lager zijn dan Loop Hoogte - 3",
    Values = GODFLOORY,
    Default = "-20",
    Multi = false
}):OnChanged(function(v)
    M.S.GodFloorY = tonumber(v) or -20
end)
local GDSP = AT2:AddParagraph({Title = "God Status", Content = "Uit"})
local GDTG = AT2:AddToggle("GodToggle", {Title = "ðŸ›¡ï¸ God Mode AAN/UIT", Default = false})
GDTG:OnChanged(function(v)
    if v then
        M.enableGod()
        Fluent:Notify({Title="God Mode v18",Content="Aan! Vloer vervangen â†’ Y="..M.S.GodFloorY.."\nJij loopt op Y="..M.S.GodWalkY.."\nKill zone = Yâ‰ˆ0 â†’ jij bent veilig!",Duration=6})
    else
        M.disableGod()
        Fluent:Notify({Title="God Mode",Content="Uit. Alles hersteld.",Duration=3})
    end
end)
AT2:AddButton({Title = "ðŸ“ Teleport Onder Vloer", Callback = function()
    if M._isGod then
        godTeleportUnder()
        Fluent:Notify({Title="God Mode",Content="Naar Y=" .. M.S.GodWalkY,Duration=3})
    else
        Fluent:Notify({Title="God Mode",Content="Zet eerst God Mode aan!",Duration=3})
    end
end})

AT2:AddParagraph({Title = "âœ¨ Overige", Content = ""})
AT2:AddToggle("InstantToggle", {Title = "âš¡ Instant Pickup", Default = true}):OnChanged(function(v)
    M.S.InstantPickup = v if v then M.setupInstant() end
end)
local AFKSP = AT2:AddParagraph({Title = "AFK", Content = "Uit"})
local AFKTG = AT2:AddToggle("AFKToggle", {Title = "ðŸ›¡ï¸ Anti-AFK", Default = false})
AFKTG:OnChanged(function(v) if v then M.startAFK() else M.stopAFK() end end)

-- ===== CONFIG TAB =====
local CT = W:AddTab({Title = "Config", Icon = "settings"})
CT:AddDropdown("TweenSpeed", {Title = "Farm Snelheid", Values = SPD, Default = "INSTANT", Multi = false}):OnChanged(function(v) M.S.TweenSpeed = SPM[v] or 9999 end)
CT:AddDropdown("CorridorSpeed", {
    Title = "Corridor Snelheid", Description = "Lager = veiliger\nâš ï¸ 2000+ kan je killen!",
    Values = CSPD, Default = "1500", Multi = false
}):OnChanged(function(v) M.S.CorridorSpeed = tonumber(v) or 1500 end)
CT:AddButton({Title = "ðŸ”„ Herlaad Brainrot Lijst", Callback = function()
    M.S.SelectedBrainrots = {}
    pcall(function() BDD:SetValues(M.getBrainrotNamesMulti(M.S.TargetRarity)) BDD:SetValue({}) end)
    Fluent:Notify({Title="MzD",Content="Lijst herladen!",Duration=3})
end})
CT:AddButton({Title = "ðŸ  Zoek Base", Callback = function()
    M.findBase()
    Fluent:Notify({Title="Base",Content=M.baseGUID and("Gevonden: "..M.baseGUID) or "Niet gevonden!",Duration=3})
end})
CT:AddButton({Title = "ðŸ“ Sla Home Op", Callback = function()
    M.setHomePosition()
    local hp = M.homePosition and M.homePosition.Position
    if hp then Fluent:Notify({Title="Home",Content=string.format("X:%.1f Y:%.1f Z:%.1f",hp.X,hp.Y,hp.Z),Duration=5})
    else Fluent:Notify({Title="Home",Content="Mislukt!",Duration=3}) end
end})
CT:AddButton({Title = "ðŸ§± Detecteer Muren", Callback = function()
    M.detectWallZ()
    Fluent:Notify({Title="Muren",Content=string.format("Front Z: %.1f\nBack Z: %.1f\nCoridor: %.1f",M._wallZ_front,M._wallZ_back,M.getCorridorZ()),Duration=8})
end})
CT:AddButton({Title = "ðŸ“‹ Toon Slots", Callback = function()
    M.findBase()
    local o = M.findOccupiedSlots()
    if #o == 0 then Fluent:Notify({Title="Slots",Content="Alle slots leeg!",Duration=3}) return end
    local info = "" for _, s in pairs(o) do info = info.."Slot "..s.slot..": "..s.name.." Lv."..s.level.."\n" end
    Fluent:Notify({Title="Slots ("..#o..")",Content=info,Duration=8})
end})
CT:AddButton({Title = "ðŸ—‘ï¸ Leeg Werk Slot", Callback = function()
    M.findBase() M.clearSlot(tonumber(M.S.FarmSlot) or 5)
    Fluent:Notify({Title="Slot",Content="Slot "..M.S.FarmSlot.." geleegd!",Duration=3})
end})
CT:AddButton({Title = "ðŸ  Ga Naar Base", Callback = function() M.findBase() M.returnToBase() end})

CT:AddParagraph({Title = "ðŸ’ Valentine Debug", Content = ""})
CT:AddButton({Title = "ðŸ” Scan Valentine Remotes", Callback = function()
    local remotes, log = M.scanValentineRemotes()
    local info = "Gevonden: " .. #remotes .. " remotes/prompts\n"
    info = info .. "Hearts: " .. M.getHeartCount() .. "\n\n"
    for i, entry in pairs(remotes) do
        if i > 15 then info = info .. "... +" .. (#remotes - 15) .. " meer\n" break end
        info = info .. entry.type .. ": " .. entry.path .. "\n"
    end
    Fluent:Notify({Title="Valentine Scan",Content=info,Duration=15})
end})
CT:AddButton({Title = "ðŸ’ Test Submit Nu", Callback = function()
    local prevH = M.getHeartCount()
    local ok = M.submitHearts()
    task.wait(1)
    local newH = M.getHeartCount()
    local info = "Before: " .. prevH .. " hearts\nAfter: " .. newH .. " hearts\nVerschil: " .. (prevH - newH) .. "\nSubmit: " .. tostring(ok) .. "\nRemotes: " .. #M._valentineFoundRemotes
    Fluent:Notify({Title="Submit Test",Content=info,Duration=10})
end})
CT:AddButton({Title = "ðŸ’ Scan Hearts/Values", Callback = function()
    local info = "Hearts count: " .. M.getHeartCount() .. "\n\n"
    pcall(function()
        local ls = Player:FindFirstChild("leaderstats")
        if ls then
            info = info .. "Leaderstats:\n"
            for _, v in pairs(ls:GetChildren()) do info = info .. "  " .. v.Name .. " = " .. tostring(v.Value) .. "\n" end
        else info = info .. "Geen leaderstats!\n" end
    end)
    pcall(function()
        info = info .. "\nPlayer Attributes:\n"
        local found = false
        for _, attr in pairs({"Hearts","Candy","CandyGrams","Valentines","Love","CandyHearts","Money","Coins","Tokens"}) do
            local v = Player:GetAttribute(attr)
            if v ~= nil then info = info .. "  " .. attr .. " = " .. tostring(v) .. "\n" found = true end
        end
        if not found then info = info .. "  (geen relevante)\n" end
    end)
    info = info .. "\nCached parts: " .. #M._valentineCachedParts
    Fluent:Notify({Title="Valentine Values",Content=info,Duration=15})
end})
CT:AddButton({Title = "ðŸ” Scan Lucky Blocks", Callback = function()
    if not M.ActiveLuckyBlocks then M.ActiveLuckyBlocks = workspace:FindFirstChild("ActiveLuckyBlocks") end
    local cnt = 0 local info = ""
    if M.ActiveLuckyBlocks then
        for _, b in pairs(M.ActiveLuckyBlocks:GetChildren()) do
            cnt += 1
            local r = M.luckyBlockGetRarityFromName(b.Name)
            local mt = b:GetAttribute("Mutation") or "None"
            if cnt <= 12 then
                info = info..r
                if mt ~= "None" and mt ~= "" then info = info.." ["..mt.."]" end
                info = info.."\n"
            end
        end
    end
    if cnt == 0 then Fluent:Notify({Title="Lucky Blocks",Content="Geen actieve blocks!",Duration=5})
    else if cnt > 12 then info = info.."... +"..(cnt-12).." meer" end
        Fluent:Notify({Title="Lucky Blocks ("..cnt..")",Content=info,Duration=8}) end
end})
CT:AddButton({Title = "ðŸ” Debug Brainrots", Callback = function()
    if not M.ActiveBrainrots then M.ActiveBrainrots = workspace:FindFirstChild("ActiveBrainrots") end
    if not M.ActiveBrainrots then Fluent:Notify({Title="Debug",Content="Geen ActiveBrainrots!",Duration=5}) return end
    local info = ""
    for _, folder in pairs(M.ActiveBrainrots:GetChildren()) do
        local count = 0 for _ in pairs(folder:GetChildren()) do count += 1 end
        if count > 0 then
            info = info..folder.Name.." ("..count.."):\n"
            local shown = 0
            for _, b in pairs(folder:GetChildren()) do
                if shown >= 4 then info = info.." ...\n" break end
                local bName = b:GetAttribute("BrainrotName") or b.Name
                local mut = b:GetAttribute("Mutation") or "None"
                local hasRoot = M.findBrainrotRoot(b) and "âœ“" or "âœ—"
                info = info.." ["..hasRoot.."] "..bName
                if mut ~= "None" and mut ~= "" then info = info.." ("..mut..")" end
                info = info.."\n" shown += 1
            end
        end
    end
    if info == "" then info = "Leeg!" end
    Fluent:Notify({Title="Brainrots Debug",Content=info,Duration=12})
end})

CT:AddParagraph({Title = "ðŸ›¡ï¸ God Mode Debug", Content = ""})
CT:AddButton({Title = "ðŸ›¡ï¸ Debug God Mode", Callback = function()
    local info = "God Mode: " .. (M._isGod and "AAN" or "UIT") .. "\n"
    info = info .. "WalkY: " .. M.S.GodWalkY .. " | FloorY: " .. M.S.GodFloorY .. "\n"
    info = info .. "Originele vloeren: " .. #M._godOriginalFloors .. "\n"
    info = info .. "Gemaakte vloeren: " .. #M._godCreatedFloors .. "\n"
    info = info .. "Kill parts: " .. #M._godKillParts .. "\n"
    local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        info = info .. "Huidige Y: " .. string.format("%.1f", hrp.Position.Y) .. "\n"
    end
    local floors, map = godFindFloorParts()
    info = info .. "Gevonden vloerdelen: " .. #floors .. "\n"
    if map then info = info .. "Map: " .. map.Name end
    Fluent:Notify({Title="God Debug",Content=info,Duration=10})
end})
CT:AddButton({Title = "ðŸ” Scan Kill Parts", Callback = function()
    local kills = godFindKillParts()
    local info = "Gevonden kill parts: " .. #kills .. "\n\n"
    for i, p in pairs(kills) do
        if i > 10 then info = info .. "... +" .. (#kills - 10) .. " meer\n" break end
        info = info .. p.Name .. " | Size: " .. tostring(p.Size) .. " | Y: " .. string.format("%.2f", p.Position.Y) .. "\n"
    end
    Fluent:Notify({Title="Kill Parts Scan",Content=info,Duration=10})
end})

local IP = CT:AddParagraph({Title = "Info", Content = "Laden..."})

-- ===== SETTINGS TAB =====
local ST2 = W:AddTab({Title = "Settings", Icon = "shield"})
SaveManager:SetLibrary(Fluent) InterfaceManager:SetLibrary(Fluent)
SaveManager:SetFolder("MzDHub") InterfaceManager:SetFolder("MzDHub")
InterfaceManager:BuildInterfaceSection(ST2)
SaveManager:BuildConfigSection(ST2)

-- ===== LIVE UPDATER =====
task.spawn(function()
    while task.wait(0.5) do
        pcall(function()
            FSP:SetDesc((M.S.Farming and M.Status.farm or "Idle") .. " | #" .. M.Status.farmCount)
            FPP:SetDesc("Geplaatst: " .. M.Status.placeCount .. " | Geupgrade: " .. M.Status.upgradeCount)
            if not M.S.Farming then pcall(function() if FTG.Value then FTG:SetValue(false) end end) end

            LBSP:SetDesc((M.S.LuckyBlockEnabled and M.Status.luckyBlock or "Idle") .. " | #" .. M.Status.luckyBlockCount)
            if not M.S.LuckyBlockEnabled then pcall(function() if LBTG.Value then LBTG:SetValue(false) end end) end

            local factoryInfo = (M.Status.factory or "Idle") .. " | #" .. M.Status.factoryCount
            if M.S.FactoryEnabled then
                factoryInfo = factoryInfo .. "\n" .. M.S.FactoryRarity .. " / " .. M.S.FactoryMutation .. " â†’ Lv." .. M.S.FactoryMaxLevel
            end
            FCSP:SetDesc(factoryInfo)
            if not M.S.FactoryEnabled then pcall(function() if FCTG.Value then FCTG:SetValue(false) end end) end

            VSP:SetDesc((M.S.ValentineEnabled and M.Status.valentine or "Idle") .. " | #" .. M.Status.valentineCount)
            if not M.S.ValentineEnabled then pcall(function() if VTG.Value then VTG:SetValue(false) end end) end

            ASP:SetDesc(M.S.ArcadeEnabled and ("Actief | #" .. M.Status.arcadeCount) or "Idle")
            if not M.S.ArcadeEnabled then pcall(function() if ATG.Value then ATG:SetValue(false) end end) end

            MSP:SetDesc(M.S.AutoCollectMoney and "Actief" or "Idle")
            if not M.S.AutoCollectMoney then pcall(function() if MTG.Value then MTG:SetValue(false) end end) end

            local ua = M.S.AutoUpgrade and M.upgradeThread
            USP:SetDesc((ua and M.Status.upgrade or "Idle") .. " | #" .. M.Status.upgradeCount)
            if not ua then pcall(function() if UTG.Value then UTG:SetValue(false) end end) end

            MFSP:SetDesc((M.S.MapFixerEnabled and M.Status.mapFixer or "Uit") .. (M.lastMapName ~= "" and (" | " .. M.lastMapName) or ""))
            if not M.S.MapFixerEnabled then pcall(function() if MFTG.Value then MFTG:SetValue(false) end end) end

            AFKSP:SetDesc("Anti-AFK: " .. M.Status.afk)
            if not M.S.AntiAFK then pcall(function() if AFKTG.Value then AFKTG:SetValue(false) end end) end

            GDSP:SetDesc(M.Status.god)
            if not M._isGod then pcall(function() if GDTG.Value then GDTG:SetValue(false) end end) end

            local hp = M.homePosition and M.homePosition.Position
            local hs = hp and string.format("X:%.1f Y:%.1f Z:%.1f", hp.X, hp.Y, hp.Z) or "Niet ingesteld"
            local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
            local curY = hrp and string.format("%.1f", hrp.Position.Y) or "?"
            IP:SetDesc(
                "Speler: " .. Player.Name ..
                "\nBase: " .. (M.baseGUID or "Niet gevonden") ..
                "\nHome: " .. hs ..
                "\nCoridor Z: " .. string.format("%.1f", M.getCorridorZ()) ..
                "\nGod: " .. (M._isGod and ("AAN ðŸ›¡ï¸ Y=" .. M.S.GodWalkY) or "UIT") ..
                "\nHuidige Y: " .. curY ..
                "\nKill zone: Yâ‰ˆ0 | Vloer: Y=" .. M.S.GodFloorY .. " | Loop: Y=" .. M.S.GodWalkY ..
                "\nFarm: INSTANT | Corridor: " .. (M.S.CorridorSpeed or 1500) .. " studs/s" ..
                "\nValentine remotes: " .. #M._valentineFoundRemotes .. " | Cache: " .. #M._valentineCachedParts
            )
        end)
    end
end)

-- ===== INIT =====
task.spawn(function()
    task.wait(1) M.findBase() task.wait(0.5) M.detectWallZ()
    if M.baseGUID then
        Fluent:Notify({Title="MzD Hub v10.7",Content="Base: "..M.baseGUID.."\nSpeed: INSTANT + Corridor "..M.S.CorridorSpeed.."\nðŸ›¡ï¸ God Mode v18: Vervangende Vloer!\nKill zone Yâ‰ˆ0 â†’ jij loopt op Y="..M.S.GodWalkY,Duration=7})
    else
        Fluent:Notify({Title="MzD Hub v10.7",Content="Geladen! Klik 'Zoek Base' in Config.\nðŸ›¡ï¸ God Mode v18 beschikbaar!",Duration=6})
    end
end)

W:SelectTab(1)
Fluent:Notify({Title="MzD Hub v10.7",Content="Geladen âœ¦ RightCtrl = minimaliseer\nâš¡ INSTANT + Corridor 1500\nðŸ›¡ï¸ God Mode: Vloer vervangen methode\nKill zone Yâ‰ˆ0 â†’ jij op Y=-17\nðŸ’ Valentine debug in Config",Duration=7})
print("[MzD Hub] v10.7 VOLLEDIG GELADEN âœ¦")
